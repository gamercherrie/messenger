{"ast":null,"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2021 */\n\n/* jshint ignore:start */\nvar ICAL;\n\n(function () {\n  /* istanbul ignore next */\n  if (typeof module === 'object') {\n    // CommonJS, where exports may be different each time.\n    ICAL = module.exports;\n  } else if (typeof HTMLScriptElement !== 'undefined' && 'noModule' in HTMLScriptElement.prototype) {\n    // Until we use ES6 exports, using <script type=\"module\"> we define ICAL on the window global.\n    window.ICAL = ICAL = {};\n  } else if (typeof ICAL !== 'object') {\n    ICAL = {};\n  }\n})();\n/* jshint ignore:end */\n\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * The number of characters before iCalendar line folding should occur\n * @type {Number}\n * @default 75\n */\n\n\nICAL.foldLength = 75;\n/**\n * The character(s) to be used for a newline. The default value is provided by\n * rfc5545.\n * @type {String}\n * @default \"\\r\\n\"\n */\n\nICAL.newLineChar = '\\r\\n';\n/**\n * Helper functions used in various places within ical.js\n * @namespace\n */\n\nICAL.helpers = {\n  /**\n   * Compiles a list of all referenced TZIDs in all subcomponents and\n   * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs\n   * are referenced by a component, but a VTIMEZONE does not exist,\n   * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.\n   *\n   * @param {ICAL.Component} vcal     The top-level VCALENDAR component.\n   * @return {ICAL.Component}         The ICAL.Component that was passed in.\n   */\n  updateTimezones: function (vcal) {\n    var allsubs, properties, vtimezones, reqTzid, i, tzid;\n\n    if (!vcal || vcal.name !== \"vcalendar\") {\n      //not a top-level vcalendar component\n      return vcal;\n    } //Store vtimezone subcomponents in an object reference by tzid.\n    //Store properties from everything else in another array\n\n\n    allsubs = vcal.getAllSubcomponents();\n    properties = [];\n    vtimezones = {};\n\n    for (i = 0; i < allsubs.length; i++) {\n      if (allsubs[i].name === \"vtimezone\") {\n        tzid = allsubs[i].getFirstProperty(\"tzid\").getFirstValue();\n        vtimezones[tzid] = allsubs[i];\n      } else {\n        properties = properties.concat(allsubs[i].getAllProperties());\n      }\n    } //create an object with one entry for each required tz\n\n\n    reqTzid = {};\n\n    for (i = 0; i < properties.length; i++) {\n      if (tzid = properties[i].getParameter(\"tzid\")) {\n        reqTzid[tzid] = true;\n      }\n    } //delete any vtimezones that are not on the reqTzid list.\n\n\n    for (i in vtimezones) {\n      if (vtimezones.hasOwnProperty(i) && !reqTzid[i]) {\n        vcal.removeSubcomponent(vtimezones[i]);\n      }\n    } //create any missing, but registered timezones\n\n\n    for (i in reqTzid) {\n      if (reqTzid.hasOwnProperty(i) && !vtimezones[i] && ICAL.TimezoneService.has(i)) {\n        vcal.addSubcomponent(ICAL.TimezoneService.get(i).component);\n      }\n    }\n\n    return vcal;\n  },\n\n  /**\n   * Checks if the given type is of the number type and also NaN.\n   *\n   * @param {Number} number     The number to check\n   * @return {Boolean}          True, if the number is strictly NaN\n   */\n  isStrictlyNaN: function (number) {\n    return typeof number === 'number' && isNaN(number);\n  },\n\n  /**\n   * Parses a string value that is expected to be an integer, when the valid is\n   * not an integer throws a decoration error.\n   *\n   * @param {String} string     Raw string input\n   * @return {Number}           Parsed integer\n   */\n  strictParseInt: function (string) {\n    var result = parseInt(string, 10);\n\n    if (ICAL.helpers.isStrictlyNaN(result)) {\n      throw new Error('Could not extract integer from \"' + string + '\"');\n    }\n\n    return result;\n  },\n\n  /**\n   * Creates or returns a class instance of a given type with the initialization\n   * data if the data is not already an instance of the given type.\n   *\n   * @example\n   * var time = new ICAL.Time(...);\n   * var result = ICAL.helpers.formatClassType(time, ICAL.Time);\n   *\n   * (result instanceof ICAL.Time)\n   * // => true\n   *\n   * result = ICAL.helpers.formatClassType({}, ICAL.Time);\n   * (result isntanceof ICAL.Time)\n   * // => true\n   *\n   *\n   * @param {Object} data       object initialization data\n   * @param {Object} type       object type (like ICAL.Time)\n   * @return {?}                An instance of the found type.\n   */\n  formatClassType: function formatClassType(data, type) {\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    if (data instanceof type) {\n      return data;\n    }\n\n    return new type(data);\n  },\n\n  /**\n   * Identical to indexOf but will only match values when they are not preceded\n   * by a backslash character.\n   *\n   * @param {String} buffer         String to search\n   * @param {String} search         Value to look for\n   * @param {Number} pos            Start position\n   * @return {Number}               The position, or -1 if not found\n   */\n  unescapedIndexOf: function (buffer, search, pos) {\n    while ((pos = buffer.indexOf(search, pos)) !== -1) {\n      if (pos > 0 && buffer[pos - 1] === '\\\\') {\n        pos += 1;\n      } else {\n        return pos;\n      }\n    }\n\n    return -1;\n  },\n\n  /**\n   * Find the index for insertion using binary search.\n   *\n   * @param {Array} list            The list to search\n   * @param {?} seekVal             The value to insert\n   * @param {function(?,?)} cmpfunc The comparison func, that can\n   *                                  compare two seekVals\n   * @return {Number}               The insert position\n   */\n  binsearchInsert: function (list, seekVal, cmpfunc) {\n    if (!list.length) return 0;\n    var low = 0,\n        high = list.length - 1,\n        mid,\n        cmpval;\n\n    while (low <= high) {\n      mid = low + Math.floor((high - low) / 2);\n      cmpval = cmpfunc(seekVal, list[mid]);\n      if (cmpval < 0) high = mid - 1;else if (cmpval > 0) low = mid + 1;else break;\n    }\n\n    if (cmpval < 0) return mid; // insertion is displacing, so use mid outright.\n    else if (cmpval > 0) return mid + 1;else return mid;\n  },\n\n  /**\n   * Convenience function for debug output\n   * @private\n   */\n  dumpn:\n  /* istanbul ignore next */\n  function () {\n    if (!ICAL.debug) {\n      return;\n    }\n\n    if (typeof console !== 'undefined' && 'log' in console) {\n      ICAL.helpers.dumpn = function consoleDumpn(input) {\n        console.log(input);\n      };\n    } else {\n      ICAL.helpers.dumpn = function geckoDumpn(input) {\n        dump(input + '\\n');\n      };\n    }\n\n    ICAL.helpers.dumpn(arguments[0]);\n  },\n\n  /**\n   * Clone the passed object or primitive. By default a shallow clone will be\n   * executed.\n   *\n   * @param {*} aSrc            The thing to clone\n   * @param {Boolean=} aDeep    If true, a deep clone will be performed\n   * @return {*}                The copy of the thing\n   */\n  clone: function (aSrc, aDeep) {\n    if (!aSrc || typeof aSrc != \"object\") {\n      return aSrc;\n    } else if (aSrc instanceof Date) {\n      return new Date(aSrc.getTime());\n    } else if (\"clone\" in aSrc) {\n      return aSrc.clone();\n    } else if (Array.isArray(aSrc)) {\n      var arr = [];\n\n      for (var i = 0; i < aSrc.length; i++) {\n        arr.push(aDeep ? ICAL.helpers.clone(aSrc[i], true) : aSrc[i]);\n      }\n\n      return arr;\n    } else {\n      var obj = {};\n\n      for (var name in aSrc) {\n        // uses prototype method to allow use of Object.create(null);\n\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(aSrc, name)) {\n          if (aDeep) {\n            obj[name] = ICAL.helpers.clone(aSrc[name], true);\n          } else {\n            obj[name] = aSrc[name];\n          }\n        }\n      }\n\n      return obj;\n    }\n  },\n\n  /**\n   * Performs iCalendar line folding. A line ending character is inserted and\n   * the next line begins with a whitespace.\n   *\n   * @example\n   * SUMMARY:This line will be fold\n   *  ed right in the middle of a word.\n   *\n   * @param {String} aLine      The line to fold\n   * @return {String}           The folded line\n   */\n  foldline: function foldline(aLine) {\n    var result = \"\";\n    var line = aLine || \"\",\n        pos = 0,\n        line_length = 0; //pos counts position in line for the UTF-16 presentation\n    //line_length counts the bytes for the UTF-8 presentation\n\n    while (line.length) {\n      var cp = line.codePointAt(pos);\n      if (cp < 128) ++line_length;else if (cp < 2048) line_length += 2; //needs 2 UTF-8 bytes\n      else if (cp < 65536) line_length += 3;else line_length += 4; //cp is less than 1114112\n\n      if (line_length < ICAL.foldLength + 1) pos += cp > 65535 ? 2 : 1;else {\n        result += ICAL.newLineChar + \" \" + line.substring(0, pos);\n        line = line.substring(pos);\n        pos = line_length = 0;\n      }\n    }\n\n    return result.substr(ICAL.newLineChar.length + 1);\n  },\n\n  /**\n   * Pads the given string or number with zeros so it will have at least two\n   * characters.\n   *\n   * @param {String|Number} data    The string or number to pad\n   * @return {String}               The number padded as a string\n   */\n  pad2: function pad(data) {\n    if (typeof data !== 'string') {\n      // handle fractions.\n      if (typeof data === 'number') {\n        data = parseInt(data);\n      }\n\n      data = String(data);\n    }\n\n    var len = data.length;\n\n    switch (len) {\n      case 0:\n        return '00';\n\n      case 1:\n        return '0' + data;\n\n      default:\n        return data;\n    }\n  },\n\n  /**\n   * Truncates the given number, correctly handling negative numbers.\n   *\n   * @param {Number} number     The number to truncate\n   * @return {Number}           The truncated number\n   */\n  trunc: function trunc(number) {\n    return number < 0 ? Math.ceil(number) : Math.floor(number);\n  },\n\n  /**\n   * Poor-man's cross-browser inheritance for JavaScript. Doesn't support all\n   * the features, but enough for our usage.\n   *\n   * @param {Function} base     The base class constructor function.\n   * @param {Function} child    The child class constructor function.\n   * @param {Object} extra      Extends the prototype with extra properties\n   *                              and methods\n   */\n  inherits: function (base, child, extra) {\n    function F() {}\n\n    F.prototype = base.prototype;\n    child.prototype = new F();\n\n    if (extra) {\n      ICAL.helpers.extend(extra, child.prototype);\n    }\n  },\n\n  /**\n   * Poor-man's cross-browser object extension. Doesn't support all the\n   * features, but enough for our usage. Note that the target's properties are\n   * not overwritten with the source properties.\n   *\n   * @example\n   * var child = ICAL.helpers.extend(parent, {\n   *   \"bar\": 123\n   * });\n   *\n   * @param {Object} source     The object to extend\n   * @param {Object} target     The object to extend with\n   * @return {Object}           Returns the target.\n   */\n  extend: function (source, target) {\n    for (var key in source) {\n      var descr = Object.getOwnPropertyDescriptor(source, key);\n\n      if (descr && !Object.getOwnPropertyDescriptor(target, key)) {\n        Object.defineProperty(target, key, descr);\n      }\n    }\n\n    return target;\n  }\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/** @namespace ICAL */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\nICAL.design = function () {\n  'use strict';\n\n  var FROM_ICAL_NEWLINE = /\\\\\\\\|\\\\;|\\\\,|\\\\[Nn]/g;\n  var TO_ICAL_NEWLINE = /\\\\|;|,|\\n/g;\n  var FROM_VCARD_NEWLINE = /\\\\\\\\|\\\\,|\\\\[Nn]/g;\n  var TO_VCARD_NEWLINE = /\\\\|,|\\n/g;\n\n  function createTextType(fromNewline, toNewline) {\n    var result = {\n      matches: /.*/,\n      fromICAL: function (aValue, structuredEscape) {\n        return replaceNewline(aValue, fromNewline, structuredEscape);\n      },\n      toICAL: function (aValue, structuredEscape) {\n        var regEx = toNewline;\n        if (structuredEscape) regEx = new RegExp(regEx.source + '|' + structuredEscape);\n        return aValue.replace(regEx, function (str) {\n          switch (str) {\n            case \"\\\\\":\n              return \"\\\\\\\\\";\n\n            case \";\":\n              return \"\\\\;\";\n\n            case \",\":\n              return \"\\\\,\";\n\n            case \"\\n\":\n              return \"\\\\n\";\n\n            /* istanbul ignore next */\n\n            default:\n              return str;\n          }\n        });\n      }\n    };\n    return result;\n  } // default types used multiple times\n\n\n  var DEFAULT_TYPE_TEXT = {\n    defaultType: \"text\"\n  };\n  var DEFAULT_TYPE_TEXT_MULTI = {\n    defaultType: \"text\",\n    multiValue: \",\"\n  };\n  var DEFAULT_TYPE_TEXT_STRUCTURED = {\n    defaultType: \"text\",\n    structuredValue: \";\"\n  };\n  var DEFAULT_TYPE_INTEGER = {\n    defaultType: \"integer\"\n  };\n  var DEFAULT_TYPE_DATETIME_DATE = {\n    defaultType: \"date-time\",\n    allowedTypes: [\"date-time\", \"date\"]\n  };\n  var DEFAULT_TYPE_DATETIME = {\n    defaultType: \"date-time\"\n  };\n  var DEFAULT_TYPE_URI = {\n    defaultType: \"uri\"\n  };\n  var DEFAULT_TYPE_UTCOFFSET = {\n    defaultType: \"utc-offset\"\n  };\n  var DEFAULT_TYPE_RECUR = {\n    defaultType: \"recur\"\n  };\n  var DEFAULT_TYPE_DATE_ANDOR_TIME = {\n    defaultType: \"date-and-or-time\",\n    allowedTypes: [\"date-time\", \"date\", \"text\"]\n  };\n\n  function replaceNewlineReplace(string) {\n    switch (string) {\n      case \"\\\\\\\\\":\n        return \"\\\\\";\n\n      case \"\\\\;\":\n        return \";\";\n\n      case \"\\\\,\":\n        return \",\";\n\n      case \"\\\\n\":\n      case \"\\\\N\":\n        return \"\\n\";\n\n      /* istanbul ignore next */\n\n      default:\n        return string;\n    }\n  }\n\n  function replaceNewline(value, newline, structuredEscape) {\n    // avoid regex when possible.\n    if (value.indexOf('\\\\') === -1) {\n      return value;\n    }\n\n    if (structuredEscape) newline = new RegExp(newline.source + '|\\\\\\\\' + structuredEscape);\n    return value.replace(newline, replaceNewlineReplace);\n  }\n\n  var commonProperties = {\n    \"categories\": DEFAULT_TYPE_TEXT_MULTI,\n    \"url\": DEFAULT_TYPE_URI,\n    \"version\": DEFAULT_TYPE_TEXT,\n    \"uid\": DEFAULT_TYPE_TEXT\n  };\n  var commonValues = {\n    \"boolean\": {\n      values: [\"TRUE\", \"FALSE\"],\n      fromICAL: function (aValue) {\n        switch (aValue) {\n          case 'TRUE':\n            return true;\n\n          case 'FALSE':\n            return false;\n\n          default:\n            //TODO: parser warning\n            return false;\n        }\n      },\n      toICAL: function (aValue) {\n        if (aValue) {\n          return 'TRUE';\n        }\n\n        return 'FALSE';\n      }\n    },\n    float: {\n      matches: /^[+-]?\\d+\\.\\d+$/,\n      fromICAL: function (aValue) {\n        var parsed = parseFloat(aValue);\n\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          // TODO: parser warning\n          return 0.0;\n        }\n\n        return parsed;\n      },\n      toICAL: function (aValue) {\n        return String(aValue);\n      }\n    },\n    integer: {\n      fromICAL: function (aValue) {\n        var parsed = parseInt(aValue);\n\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          return 0;\n        }\n\n        return parsed;\n      },\n      toICAL: function (aValue) {\n        return String(aValue);\n      }\n    },\n    \"utc-offset\": {\n      toICAL: function (aValue) {\n        if (aValue.length < 7) {\n          // no seconds\n          // -0500\n          return aValue.substr(0, 3) + aValue.substr(4, 2);\n        } else {\n          // seconds\n          // -050000\n          return aValue.substr(0, 3) + aValue.substr(4, 2) + aValue.substr(7, 2);\n        }\n      },\n      fromICAL: function (aValue) {\n        if (aValue.length < 6) {\n          // no seconds\n          // -05:00\n          return aValue.substr(0, 3) + ':' + aValue.substr(3, 2);\n        } else {\n          // seconds\n          // -05:00:00\n          return aValue.substr(0, 3) + ':' + aValue.substr(3, 2) + ':' + aValue.substr(5, 2);\n        }\n      },\n      decorate: function (aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      }\n    }\n  };\n  var icalParams = {\n    // Although the syntax is DQUOTE uri DQUOTE, I don't think we should\n    // enfoce anything aside from it being a valid content line.\n    //\n    // At least some params require - if multi values are used - DQUOTEs\n    // for each of its values - e.g. delegated-from=\"uri1\",\"uri2\"\n    // To indicate this, I introduced the new k/v pair\n    // multiValueSeparateDQuote: true\n    //\n    // \"ALTREP\": { ... },\n    // CN just wants a param-value\n    // \"CN\": { ... }\n    \"cutype\": {\n      values: [\"INDIVIDUAL\", \"GROUP\", \"RESOURCE\", \"ROOM\", \"UNKNOWN\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"delegated-from\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"delegated-to\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    // \"DIR\": { ... }, // See ALTREP\n    \"encoding\": {\n      values: [\"8BIT\", \"BASE64\"]\n    },\n    // \"FMTTYPE\": { ... }, // See ALTREP\n    \"fbtype\": {\n      values: [\"FREE\", \"BUSY\", \"BUSY-UNAVAILABLE\", \"BUSY-TENTATIVE\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    // \"LANGUAGE\": { ... }, // See ALTREP\n    \"member\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"partstat\": {\n      // TODO These values are actually different per-component\n      values: [\"NEEDS-ACTION\", \"ACCEPTED\", \"DECLINED\", \"TENTATIVE\", \"DELEGATED\", \"COMPLETED\", \"IN-PROCESS\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"range\": {\n      values: [\"THISANDFUTURE\"]\n    },\n    \"related\": {\n      values: [\"START\", \"END\"]\n    },\n    \"reltype\": {\n      values: [\"PARENT\", \"CHILD\", \"SIBLING\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"role\": {\n      values: [\"REQ-PARTICIPANT\", \"CHAIR\", \"OPT-PARTICIPANT\", \"NON-PARTICIPANT\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"rsvp\": {\n      values: [\"TRUE\", \"FALSE\"]\n    },\n    \"sent-by\": {\n      valueType: \"cal-address\"\n    },\n    \"tzid\": {\n      matches: /^\\//\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"binary\", \"boolean\", \"cal-address\", \"date\", \"date-time\", \"duration\", \"float\", \"integer\", \"period\", \"recur\", \"text\", \"time\", \"uri\", \"utc-offset\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  }; // When adding a value here, be sure to add it to the parameter types!\n\n  var icalValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),\n    uri: {// TODO\n\n      /* ... */\n    },\n    \"binary\": {\n      decorate: function (aString) {\n        return ICAL.Binary.fromString(aString);\n      },\n      undecorate: function (aBinary) {\n        return aBinary.toString();\n      }\n    },\n    \"cal-address\": {// needs to be an uri\n    },\n    \"date\": {\n      decorate: function (aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n\n      /**\n       * undecorates a time object.\n       */\n      undecorate: function (aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function (aValue) {\n        // from: 20120901\n        // to: 2012-09-01\n        if (!design.strict && aValue.length >= 15) {\n          // This is probably a date-time, e.g. 20120901T130000Z\n          return icalValues[\"date-time\"].fromICAL(aValue);\n        } else {\n          return aValue.substr(0, 4) + '-' + aValue.substr(4, 2) + '-' + aValue.substr(6, 2);\n        }\n      },\n      toICAL: function (aValue) {\n        // from: 2012-09-01\n        // to: 20120901\n        var len = aValue.length;\n\n        if (len == 10) {\n          return aValue.substr(0, 4) + aValue.substr(5, 2) + aValue.substr(8, 2);\n        } else if (len >= 19) {\n          return icalValues[\"date-time\"].toICAL(aValue);\n        } else {\n          //TODO: serialize warning?\n          return aValue;\n        }\n      }\n    },\n    \"date-time\": {\n      fromICAL: function (aValue) {\n        // from: 20120901T130000\n        // to: 2012-09-01T13:00:00\n        if (!design.strict && aValue.length == 8) {\n          // This is probably a date, e.g. 20120901\n          return icalValues.date.fromICAL(aValue);\n        } else {\n          var result = aValue.substr(0, 4) + '-' + aValue.substr(4, 2) + '-' + aValue.substr(6, 2) + 'T' + aValue.substr(9, 2) + ':' + aValue.substr(11, 2) + ':' + aValue.substr(13, 2);\n\n          if (aValue[15] && aValue[15] === 'Z') {\n            result += 'Z';\n          }\n\n          return result;\n        }\n      },\n      toICAL: function (aValue) {\n        // from: 2012-09-01T13:00:00\n        // to: 20120901T130000\n        var len = aValue.length;\n\n        if (len == 10 && !design.strict) {\n          return icalValues.date.toICAL(aValue);\n        } else if (len >= 19) {\n          var result = aValue.substr(0, 4) + aValue.substr(5, 2) + // grab the (DDTHH) segment\n          aValue.substr(8, 5) + // MM\n          aValue.substr(14, 2) + // SS\n          aValue.substr(17, 2);\n\n          if (aValue[19] && aValue[19] === 'Z') {\n            result += 'Z';\n          }\n\n          return result;\n        } else {\n          // TODO: error\n          return aValue;\n        }\n      },\n      decorate: function (aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateTimeString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      }\n    },\n    duration: {\n      decorate: function (aValue) {\n        return ICAL.Duration.fromString(aValue);\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      }\n    },\n    period: {\n      fromICAL: function (string) {\n        var parts = string.split('/');\n        parts[0] = icalValues['date-time'].fromICAL(parts[0]);\n\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          parts[1] = icalValues['date-time'].fromICAL(parts[1]);\n        }\n\n        return parts;\n      },\n      toICAL: function (parts) {\n        if (!design.strict && parts[0].length == 10) {\n          parts[0] = icalValues.date.toICAL(parts[0]);\n        } else {\n          parts[0] = icalValues['date-time'].toICAL(parts[0]);\n        }\n\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          if (!design.strict && parts[1].length == 10) {\n            parts[1] = icalValues.date.toICAL(parts[1]);\n          } else {\n            parts[1] = icalValues['date-time'].toICAL(parts[1]);\n          }\n        }\n\n        return parts.join(\"/\");\n      },\n      decorate: function (aValue, aProp) {\n        return ICAL.Period.fromJSON(aValue, aProp, !design.strict);\n      },\n      undecorate: function (aValue) {\n        return aValue.toJSON();\n      }\n    },\n    recur: {\n      fromICAL: function (string) {\n        return ICAL.Recur._stringToData(string, true);\n      },\n      toICAL: function (data) {\n        var str = \"\";\n\n        for (var k in data) {\n          /* istanbul ignore if */\n          if (!Object.prototype.hasOwnProperty.call(data, k)) {\n            continue;\n          }\n\n          var val = data[k];\n\n          if (k == \"until\") {\n            if (val.length > 10) {\n              val = icalValues['date-time'].toICAL(val);\n            } else {\n              val = icalValues.date.toICAL(val);\n            }\n          } else if (k == \"wkst\") {\n            if (typeof val === 'number') {\n              val = ICAL.Recur.numericDayToIcalDay(val);\n            }\n          } else if (Array.isArray(val)) {\n            val = val.join(\",\");\n          }\n\n          str += k.toUpperCase() + \"=\" + val + \";\";\n        }\n\n        return str.substr(0, str.length - 1);\n      },\n      decorate: function decorate(aValue) {\n        return ICAL.Recur.fromData(aValue);\n      },\n      undecorate: function (aRecur) {\n        return aRecur.toJSON();\n      }\n    },\n    time: {\n      fromICAL: function (aValue) {\n        // from: MMHHSS(Z)?\n        // to: HH:MM:SS(Z)?\n        if (aValue.length < 6) {\n          // TODO: parser exception?\n          return aValue;\n        } // HH::MM::SSZ?\n\n\n        var result = aValue.substr(0, 2) + ':' + aValue.substr(2, 2) + ':' + aValue.substr(4, 2);\n\n        if (aValue[6] === 'Z') {\n          result += 'Z';\n        }\n\n        return result;\n      },\n      toICAL: function (aValue) {\n        // from: HH:MM:SS(Z)?\n        // to: MMHHSS(Z)?\n        if (aValue.length < 8) {\n          //TODO: error\n          return aValue;\n        }\n\n        var result = aValue.substr(0, 2) + aValue.substr(3, 2) + aValue.substr(6, 2);\n\n        if (aValue[8] === 'Z') {\n          result += 'Z';\n        }\n\n        return result;\n      }\n    }\n  });\n  var icalProperties = ICAL.helpers.extend(commonProperties, {\n    \"action\": DEFAULT_TYPE_TEXT,\n    \"attach\": {\n      defaultType: \"uri\"\n    },\n    \"attendee\": {\n      defaultType: \"cal-address\"\n    },\n    \"calscale\": DEFAULT_TYPE_TEXT,\n    \"class\": DEFAULT_TYPE_TEXT,\n    \"comment\": DEFAULT_TYPE_TEXT,\n    \"completed\": DEFAULT_TYPE_DATETIME,\n    \"contact\": DEFAULT_TYPE_TEXT,\n    \"created\": DEFAULT_TYPE_DATETIME,\n    \"description\": DEFAULT_TYPE_TEXT,\n    \"dtend\": DEFAULT_TYPE_DATETIME_DATE,\n    \"dtstamp\": DEFAULT_TYPE_DATETIME,\n    \"dtstart\": DEFAULT_TYPE_DATETIME_DATE,\n    \"due\": DEFAULT_TYPE_DATETIME_DATE,\n    \"duration\": {\n      defaultType: \"duration\"\n    },\n    \"exdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      multiValue: ','\n    },\n    \"exrule\": DEFAULT_TYPE_RECUR,\n    \"freebusy\": {\n      defaultType: \"period\",\n      multiValue: \",\"\n    },\n    \"geo\": {\n      defaultType: \"float\",\n      structuredValue: \";\"\n    },\n    \"last-modified\": DEFAULT_TYPE_DATETIME,\n    \"location\": DEFAULT_TYPE_TEXT,\n    \"method\": DEFAULT_TYPE_TEXT,\n    \"organizer\": {\n      defaultType: \"cal-address\"\n    },\n    \"percent-complete\": DEFAULT_TYPE_INTEGER,\n    \"priority\": DEFAULT_TYPE_INTEGER,\n    \"prodid\": DEFAULT_TYPE_TEXT,\n    \"related-to\": DEFAULT_TYPE_TEXT,\n    \"repeat\": DEFAULT_TYPE_INTEGER,\n    \"rdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\", \"period\"],\n      multiValue: ',',\n      detectType: function (string) {\n        if (string.indexOf('/') !== -1) {\n          return 'period';\n        }\n\n        return string.indexOf('T') === -1 ? 'date' : 'date-time';\n      }\n    },\n    \"recurrence-id\": DEFAULT_TYPE_DATETIME_DATE,\n    \"resources\": DEFAULT_TYPE_TEXT_MULTI,\n    \"request-status\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"rrule\": DEFAULT_TYPE_RECUR,\n    \"sequence\": DEFAULT_TYPE_INTEGER,\n    \"status\": DEFAULT_TYPE_TEXT,\n    \"summary\": DEFAULT_TYPE_TEXT,\n    \"transp\": DEFAULT_TYPE_TEXT,\n    \"trigger\": {\n      defaultType: \"duration\",\n      allowedTypes: [\"duration\", \"date-time\"]\n    },\n    \"tzoffsetfrom\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzoffsetto\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzurl\": DEFAULT_TYPE_URI,\n    \"tzid\": DEFAULT_TYPE_TEXT,\n    \"tzname\": DEFAULT_TYPE_TEXT\n  }); // When adding a value here, be sure to add it to the parameter types!\n\n  var vcardValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n    uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n    date: {\n      decorate: function (aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date\");\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function (aValue) {\n        if (aValue.length == 8) {\n          return icalValues.date.fromICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 6) {\n          return aValue.substr(0, 4) + '-' + aValue.substr(4);\n        } else {\n          return aValue;\n        }\n      },\n      toICAL: function (aValue) {\n        if (aValue.length == 10) {\n          return icalValues.date.toICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 7) {\n          return aValue.substr(0, 4) + aValue.substr(5);\n        } else {\n          return aValue;\n        }\n      }\n    },\n    time: {\n      decorate: function (aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(\"T\" + aValue, \"time\");\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function (aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue, true);\n\n        var zone = splitzone[0],\n            value = splitzone[1]; //console.log(\"SPLIT: \",splitzone);\n\n        if (value.length == 6) {\n          value = value.substr(0, 2) + ':' + value.substr(2, 2) + ':' + value.substr(4, 2);\n        } else if (value.length == 4 && value[0] != '-') {\n          value = value.substr(0, 2) + ':' + value.substr(2, 2);\n        } else if (value.length == 5) {\n          value = value.substr(0, 3) + ':' + value.substr(3, 2);\n        }\n\n        if (zone.length == 5 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + ':' + zone.substr(3);\n        }\n\n        return value + zone;\n      },\n      toICAL: function (aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue);\n\n        var zone = splitzone[0],\n            value = splitzone[1];\n\n        if (value.length == 8) {\n          value = value.substr(0, 2) + value.substr(3, 2) + value.substr(6, 2);\n        } else if (value.length == 5 && value[0] != '-') {\n          value = value.substr(0, 2) + value.substr(3, 2);\n        } else if (value.length == 6) {\n          value = value.substr(0, 3) + value.substr(4, 2);\n        }\n\n        if (zone.length == 6 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + zone.substr(4);\n        }\n\n        return value + zone;\n      },\n      _splitZone: function (aValue, isFromIcal) {\n        var lastChar = aValue.length - 1;\n        var signChar = aValue.length - (isFromIcal ? 5 : 6);\n        var sign = aValue[signChar];\n        var zone, value;\n\n        if (aValue[lastChar] == 'Z') {\n          zone = aValue[lastChar];\n          value = aValue.substr(0, lastChar);\n        } else if (aValue.length > 6 && (sign == '-' || sign == '+')) {\n          zone = aValue.substr(signChar);\n          value = aValue.substr(0, signChar);\n        } else {\n          zone = \"\";\n          value = aValue;\n        }\n\n        return [zone, value];\n      }\n    },\n    \"date-time\": {\n      decorate: function (aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-time\");\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function (aValue) {\n        return vcardValues['date-and-or-time'].fromICAL(aValue);\n      },\n      toICAL: function (aValue) {\n        return vcardValues['date-and-or-time'].toICAL(aValue);\n      }\n    },\n    \"date-and-or-time\": {\n      decorate: function (aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-and-or-time\");\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function (aValue) {\n        var parts = aValue.split('T');\n        return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : '') + (parts[1] ? 'T' + vcardValues.time.fromICAL(parts[1]) : '');\n      },\n      toICAL: function (aValue) {\n        var parts = aValue.split('T');\n        return vcardValues.date.toICAL(parts[0]) + (parts[1] ? 'T' + vcardValues.time.toICAL(parts[1]) : '');\n      }\n    },\n    timestamp: icalValues['date-time'],\n    \"language-tag\": {\n      matches: /^[a-zA-Z0-9-]+$/ // Could go with a more strict regex here\n\n    }\n  });\n  var vcardParams = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"time\", \"date-time\", \"date-and-or-time\", \"timestamp\", \"boolean\", \"integer\", \"float\", \"utc-offset\", \"language-tag\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n  var vcardProperties = ICAL.helpers.extend(commonProperties, {\n    \"adr\": {\n      defaultType: \"text\",\n      structuredValue: \";\",\n      multiValue: \",\"\n    },\n    \"anniversary\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"bday\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"caladruri\": DEFAULT_TYPE_URI,\n    \"caluri\": DEFAULT_TYPE_URI,\n    \"clientpidmap\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"email\": DEFAULT_TYPE_TEXT,\n    \"fburl\": DEFAULT_TYPE_URI,\n    \"fn\": DEFAULT_TYPE_TEXT,\n    \"gender\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"geo\": DEFAULT_TYPE_URI,\n    \"impp\": DEFAULT_TYPE_URI,\n    \"key\": DEFAULT_TYPE_URI,\n    \"kind\": DEFAULT_TYPE_TEXT,\n    \"lang\": {\n      defaultType: \"language-tag\"\n    },\n    \"logo\": DEFAULT_TYPE_URI,\n    \"member\": DEFAULT_TYPE_URI,\n    \"n\": {\n      defaultType: \"text\",\n      structuredValue: \";\",\n      multiValue: \",\"\n    },\n    \"nickname\": DEFAULT_TYPE_TEXT_MULTI,\n    \"note\": DEFAULT_TYPE_TEXT,\n    \"org\": {\n      defaultType: \"text\",\n      structuredValue: \";\"\n    },\n    \"photo\": DEFAULT_TYPE_URI,\n    \"related\": DEFAULT_TYPE_URI,\n    \"rev\": {\n      defaultType: \"timestamp\"\n    },\n    \"role\": DEFAULT_TYPE_TEXT,\n    \"sound\": DEFAULT_TYPE_URI,\n    \"source\": DEFAULT_TYPE_URI,\n    \"tel\": {\n      defaultType: \"uri\",\n      allowedTypes: [\"uri\", \"text\"]\n    },\n    \"title\": DEFAULT_TYPE_TEXT,\n    \"tz\": {\n      defaultType: \"text\",\n      allowedTypes: [\"text\", \"utc-offset\", \"uri\"]\n    },\n    \"xml\": DEFAULT_TYPE_TEXT\n  });\n  var vcard3Values = ICAL.helpers.extend(commonValues, {\n    binary: icalValues.binary,\n    date: vcardValues.date,\n    \"date-time\": vcardValues[\"date-time\"],\n    \"phone-number\": {// TODO\n\n      /* ... */\n    },\n    uri: icalValues.uri,\n    text: icalValues.text,\n    time: icalValues.time,\n    vcard: icalValues.text,\n    \"utc-offset\": {\n      toICAL: function (aValue) {\n        return aValue.substr(0, 7);\n      },\n      fromICAL: function (aValue) {\n        return aValue.substr(0, 7);\n      },\n      decorate: function (aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n      undecorate: function (aValue) {\n        return aValue.toString();\n      }\n    }\n  });\n  var vcard3Params = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"date-time\", \"phone-number\", \"time\", \"boolean\", \"integer\", \"float\", \"utc-offset\", \"vcard\", \"binary\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n  var vcard3Properties = ICAL.helpers.extend(commonProperties, {\n    fn: DEFAULT_TYPE_TEXT,\n    n: {\n      defaultType: \"text\",\n      structuredValue: \";\",\n      multiValue: \",\"\n    },\n    nickname: DEFAULT_TYPE_TEXT_MULTI,\n    photo: {\n      defaultType: \"binary\",\n      allowedTypes: [\"binary\", \"uri\"]\n    },\n    bday: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function (string) {\n        return string.indexOf('T') === -1 ? 'date' : 'date-time';\n      }\n    },\n    adr: {\n      defaultType: \"text\",\n      structuredValue: \";\",\n      multiValue: \",\"\n    },\n    label: DEFAULT_TYPE_TEXT,\n    tel: {\n      defaultType: \"phone-number\"\n    },\n    email: DEFAULT_TYPE_TEXT,\n    mailer: DEFAULT_TYPE_TEXT,\n    tz: {\n      defaultType: \"utc-offset\",\n      allowedTypes: [\"utc-offset\", \"text\"]\n    },\n    geo: {\n      defaultType: \"float\",\n      structuredValue: \";\"\n    },\n    title: DEFAULT_TYPE_TEXT,\n    role: DEFAULT_TYPE_TEXT,\n    logo: {\n      defaultType: \"binary\",\n      allowedTypes: [\"binary\", \"uri\"]\n    },\n    agent: {\n      defaultType: \"vcard\",\n      allowedTypes: [\"vcard\", \"text\", \"uri\"]\n    },\n    org: DEFAULT_TYPE_TEXT_STRUCTURED,\n    note: DEFAULT_TYPE_TEXT_MULTI,\n    prodid: DEFAULT_TYPE_TEXT,\n    rev: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function (string) {\n        return string.indexOf('T') === -1 ? 'date' : 'date-time';\n      }\n    },\n    \"sort-string\": DEFAULT_TYPE_TEXT,\n    sound: {\n      defaultType: \"binary\",\n      allowedTypes: [\"binary\", \"uri\"]\n    },\n    class: DEFAULT_TYPE_TEXT,\n    key: {\n      defaultType: \"binary\",\n      allowedTypes: [\"binary\", \"text\"]\n    }\n  });\n  /**\n   * iCalendar design set\n   * @type {ICAL.design.designSet}\n   */\n\n  var icalSet = {\n    value: icalValues,\n    param: icalParams,\n    property: icalProperties\n  };\n  /**\n   * vCard 4.0 design set\n   * @type {ICAL.design.designSet}\n   */\n\n  var vcardSet = {\n    value: vcardValues,\n    param: vcardParams,\n    property: vcardProperties\n  };\n  /**\n   * vCard 3.0 design set\n   * @type {ICAL.design.designSet}\n   */\n\n  var vcard3Set = {\n    value: vcard3Values,\n    param: vcard3Params,\n    property: vcard3Properties\n  };\n  /**\n   * The design data, used by the parser to determine types for properties and\n   * other metadata needed to produce correct jCard/jCal data.\n   *\n   * @alias ICAL.design\n   * @namespace\n   */\n\n  var design = {\n    /**\n     * A designSet describes value, parameter and property data. It is used by\n     * ther parser and stringifier in components and properties to determine they\n     * should be represented.\n     *\n     * @typedef {Object} designSet\n     * @memberOf ICAL.design\n     * @property {Object} value       Definitions for value types, keys are type names\n     * @property {Object} param       Definitions for params, keys are param names\n     * @property {Object} property    Defintions for properties, keys are property names\n     */\n\n    /**\n     * Can be set to false to make the parser more lenient.\n     */\n    strict: true,\n\n    /**\n     * The default set for new properties and components if none is specified.\n     * @type {ICAL.design.designSet}\n     */\n    defaultSet: icalSet,\n\n    /**\n     * The default type for unknown properties\n     * @type {String}\n     */\n    defaultType: 'unknown',\n\n    /**\n     * Holds the design set for known top-level components\n     *\n     * @type {Object}\n     * @property {ICAL.design.designSet} vcard       vCard VCARD\n     * @property {ICAL.design.designSet} vevent      iCalendar VEVENT\n     * @property {ICAL.design.designSet} vtodo       iCalendar VTODO\n     * @property {ICAL.design.designSet} vjournal    iCalendar VJOURNAL\n     * @property {ICAL.design.designSet} valarm      iCalendar VALARM\n     * @property {ICAL.design.designSet} vtimezone   iCalendar VTIMEZONE\n     * @property {ICAL.design.designSet} daylight    iCalendar DAYLIGHT\n     * @property {ICAL.design.designSet} standard    iCalendar STANDARD\n     *\n     * @example\n     * var propertyName = 'fn';\n     * var componentDesign = ICAL.design.components.vcard;\n     * var propertyDetails = componentDesign.property[propertyName];\n     * if (propertyDetails.defaultType == 'text') {\n     *   // Yep, sure is...\n     * }\n     */\n    components: {\n      vcard: vcardSet,\n      vcard3: vcard3Set,\n      vevent: icalSet,\n      vtodo: icalSet,\n      vjournal: icalSet,\n      valarm: icalSet,\n      vtimezone: icalSet,\n      daylight: icalSet,\n      standard: icalSet\n    },\n\n    /**\n     * The design set for iCalendar (rfc5545/rfc7265) components.\n     * @type {ICAL.design.designSet}\n     */\n    icalendar: icalSet,\n\n    /**\n     * The design set for vCard (rfc6350/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */\n    vcard: vcardSet,\n\n    /**\n     * The design set for vCard (rfc2425/rfc2426/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */\n    vcard3: vcard3Set,\n\n    /**\n     * Gets the design set for the given component name.\n     *\n     * @param {String} componentName        The name of the component\n     * @return {ICAL.design.designSet}      The design set for the component\n     */\n    getDesignSet: function (componentName) {\n      var isInDesign = componentName && componentName in design.components;\n      return isInDesign ? design.components[componentName] : design.defaultSet;\n    }\n  };\n  return design;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * Contains various functions to convert jCal and jCard data back into\n * iCalendar and vCard.\n * @namespace\n */\n\n\nICAL.stringify = function () {\n  'use strict';\n\n  var LINE_ENDING = '\\r\\n';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n  /**\n   * Convert a full jCal/jCard array into a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify\n   * @variation function\n   * @param {Array} jCal    The jCal/jCard document\n   * @return {String}       The stringified iCalendar/vCard document\n   */\n\n  function stringify(jCal) {\n    if (typeof jCal[0] == \"string\") {\n      // This is a single component\n      jCal = [jCal];\n    }\n\n    var i = 0;\n    var len = jCal.length;\n    var result = '';\n\n    for (; i < len; i++) {\n      result += stringify.component(jCal[i]) + LINE_ENDING;\n    }\n\n    return result;\n  }\n  /**\n   * Converts an jCal component array into a ICAL string.\n   * Recursive will resolve sub-components.\n   *\n   * Exact component/property order is not saved all\n   * properties will come before subcomponents.\n   *\n   * @function ICAL.stringify.component\n   * @param {Array} component\n   *        jCal/jCard fragment of a component\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this component\n   * @return {String}       The iCalendar/vCard string\n   */\n\n\n  stringify.component = function (component, designSet) {\n    var name = component[0].toUpperCase();\n    var result = 'BEGIN:' + name + LINE_ENDING;\n    var props = component[1];\n    var propIdx = 0;\n    var propLen = props.length;\n    var designSetName = component[0]; // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n\n    if (designSetName === 'vcard' && component[1].length > 0 && !(component[1][0][0] === \"version\" && component[1][0][3] === \"4.0\")) {\n      designSetName = \"vcard3\";\n    }\n\n    designSet = designSet || design.getDesignSet(designSetName);\n\n    for (; propIdx < propLen; propIdx++) {\n      result += stringify.property(props[propIdx], designSet) + LINE_ENDING;\n    } // Ignore subcomponents if none exist, e.g. in vCard.\n\n\n    var comps = component[2] || [];\n    var compIdx = 0;\n    var compLen = comps.length;\n\n    for (; compIdx < compLen; compIdx++) {\n      result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;\n    }\n\n    result += 'END:' + name;\n    return result;\n  };\n  /**\n   * Converts a single jCal/jCard property to a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify.property\n   * @param {Array} property\n   *        jCal/jCard property array\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   * @param {Boolean} noFold\n   *        If true, the line is not folded\n   * @return {String}       The iCalendar/vCard string\n   */\n\n\n  stringify.property = function (property, designSet, noFold) {\n    var name = property[0].toUpperCase();\n    var jsName = property[0];\n    var params = property[1];\n    var line = name;\n    var paramName;\n\n    for (paramName in params) {\n      var value = params[paramName];\n      /* istanbul ignore else */\n\n      if (params.hasOwnProperty(paramName)) {\n        var multiValue = paramName in designSet.param && designSet.param[paramName].multiValue;\n\n        if (multiValue && Array.isArray(value)) {\n          if (designSet.param[paramName].multiValueSeparateDQuote) {\n            multiValue = '\"' + multiValue + '\"';\n          }\n\n          value = value.map(stringify._rfc6868Unescape);\n          value = stringify.multiValue(value, multiValue, \"unknown\", null, designSet);\n        } else {\n          value = stringify._rfc6868Unescape(value);\n        }\n\n        line += ';' + paramName.toUpperCase();\n        line += '=' + stringify.propertyValue(value);\n      }\n    }\n\n    if (property.length === 3) {\n      // If there are no values, we must assume a blank value\n      return line + ':';\n    }\n\n    var valueType = property[2];\n\n    if (!designSet) {\n      designSet = design.defaultSet;\n    }\n\n    var propDetails;\n    var multiValue = false;\n    var structuredValue = false;\n    var isDefault = false;\n\n    if (jsName in designSet.property) {\n      propDetails = designSet.property[jsName];\n\n      if ('multiValue' in propDetails) {\n        multiValue = propDetails.multiValue;\n      }\n\n      if ('structuredValue' in propDetails && Array.isArray(property[3])) {\n        structuredValue = propDetails.structuredValue;\n      }\n\n      if ('defaultType' in propDetails) {\n        if (valueType === propDetails.defaultType) {\n          isDefault = true;\n        }\n      } else {\n        if (valueType === DEFAULT_VALUE_TYPE) {\n          isDefault = true;\n        }\n      }\n    } else {\n      if (valueType === DEFAULT_VALUE_TYPE) {\n        isDefault = true;\n      }\n    } // push the VALUE property if type is not the default\n    // for the current property.\n\n\n    if (!isDefault) {\n      // value will never contain ;/:/, so we don't escape it here.\n      line += ';VALUE=' + valueType.toUpperCase();\n    }\n\n    line += ':';\n\n    if (multiValue && structuredValue) {\n      line += stringify.multiValue(property[3], structuredValue, valueType, multiValue, designSet, structuredValue);\n    } else if (multiValue) {\n      line += stringify.multiValue(property.slice(3), multiValue, valueType, null, designSet, false);\n    } else if (structuredValue) {\n      line += stringify.multiValue(property[3], structuredValue, valueType, null, designSet, structuredValue);\n    } else {\n      line += stringify.value(property[3], valueType, designSet, false);\n    }\n\n    return noFold ? line : ICAL.helpers.foldline(line);\n  };\n  /**\n   * Handles escaping of property values that may contain:\n   *\n   *    COLON (:), SEMICOLON (;), or COMMA (,)\n   *\n   * If any of the above are present the result is wrapped\n   * in double quotes.\n   *\n   * @function ICAL.stringify.propertyValue\n   * @param {String} value      Raw property value\n   * @return {String}           Given or escaped value when needed\n   */\n\n\n  stringify.propertyValue = function (value) {\n    if (helpers.unescapedIndexOf(value, ',') === -1 && helpers.unescapedIndexOf(value, ':') === -1 && helpers.unescapedIndexOf(value, ';') === -1) {\n      return value;\n    }\n\n    return '\"' + value + '\"';\n  };\n  /**\n   * Converts an array of ical values into a single\n   * string based on a type and a delimiter value (like \",\").\n   *\n   * @function ICAL.stringify.multiValue\n   * @param {Array} values      List of values to convert\n   * @param {String} delim      Used to join the values (\",\", \";\", \":\")\n   * @param {String} type       Lowecase ical value type\n   *        (like boolean, date-time, etc..)\n   * @param {?String} innerMulti If set, each value will again be processed\n   *        Used for structured values\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   *\n   * @return {String}           iCalendar/vCard string for value\n   */\n\n\n  stringify.multiValue = function (values, delim, type, innerMulti, designSet, structuredValue) {\n    var result = '';\n    var len = values.length;\n    var i = 0;\n\n    for (; i < len; i++) {\n      if (innerMulti && Array.isArray(values[i])) {\n        result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);\n      } else {\n        result += stringify.value(values[i], type, designSet, structuredValue);\n      }\n\n      if (i !== len - 1) {\n        result += delim;\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Processes a single ical value runs the associated \"toICAL\" method from the\n   * design value type if available to convert the value.\n   *\n   * @function ICAL.stringify.value\n   * @param {String|Number} value       A formatted value\n   * @param {String} type               Lowercase iCalendar/vCard value type\n   *  (like boolean, date-time, etc..)\n   * @return {String}                   iCalendar/vCard value for single value\n   */\n\n\n  stringify.value = function (value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'toICAL' in designSet.value[type]) {\n      return designSet.value[type].toICAL(value, structuredValue);\n    }\n\n    return value;\n  };\n  /**\n   * Internal helper for rfc6868. Exposing this on ICAL.stringify so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @param {String} val        The value to unescape\n   * @return {String}           The escaped value\n   */\n\n\n  stringify._rfc6868Unescape = function (val) {\n    return val.replace(/[\\n^\"]/g, function (x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n\n  var RFC6868_REPLACE_MAP = {\n    '\"': \"^'\",\n    \"\\n\": \"^n\",\n    \"^\": \"^^\"\n  };\n  return stringify;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * Contains various functions to parse iCalendar and vCard data.\n * @namespace\n */\n\n\nICAL.parse = function () {\n  'use strict';\n\n  var CHAR = /[^ \\t]/;\n  var MULTIVALUE_DELIMITER = ',';\n  var VALUE_DELIMITER = ':';\n  var PARAM_DELIMITER = ';';\n  var PARAM_NAME_DELIMITER = '=';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n  var DEFAULT_PARAM_TYPE = 'text';\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n  /**\n   * An error that occurred during parsing.\n   *\n   * @param {String} message        The error message\n   * @memberof ICAL.parse\n   * @extends {Error}\n   * @class\n   */\n\n  function ParserError(message) {\n    this.message = message;\n    this.name = 'ParserError';\n\n    try {\n      throw new Error();\n    } catch (e) {\n      if (e.stack) {\n        var split = e.stack.split('\\n');\n        split.shift();\n        this.stack = split.join('\\n');\n      }\n    }\n  }\n\n  ParserError.prototype = Error.prototype;\n  /**\n   * Parses iCalendar or vCard data into a raw jCal object. Consult\n   * documentation on the {@tutorial layers|layers of parsing} for more\n   * details.\n   *\n   * @function ICAL.parse\n   * @variation function\n   * @todo Fix the API to be more clear on the return type\n   * @param {String} input      The string data to parse\n   * @return {Object|Object[]}  A single jCal object, or an array thereof\n   */\n\n  function parser(input) {\n    var state = {};\n    var root = state.component = [];\n    state.stack = [root];\n\n    parser._eachLine(input, function (err, line) {\n      parser._handleContentLine(line, state);\n    }); // when there are still items on the stack\n    // throw a fatal error, a component was not closed\n    // correctly in that case.\n\n\n    if (state.stack.length > 1) {\n      throw new ParserError('invalid ical body. component began but did not end');\n    }\n\n    state = null;\n    return root.length == 1 ? root[0] : root;\n  }\n  /**\n   * Parse an iCalendar property value into the jCal for a single property\n   *\n   * @function ICAL.parse.property\n   * @param {String} str\n   *   The iCalendar property string to parse\n   * @param {ICAL.design.designSet=} designSet\n   *   The design data to use for this property\n   * @return {Object}\n   *   The jCal Object containing the property\n   */\n\n\n  parser.property = function (str, designSet) {\n    var state = {\n      component: [[], []],\n      designSet: designSet || design.defaultSet\n    };\n\n    parser._handleContentLine(str, state);\n\n    return state.component[1][0];\n  };\n  /**\n   * Convenience method to parse a component. You can use ICAL.parse() directly\n   * instead.\n   *\n   * @function ICAL.parse.component\n   * @see ICAL.parse(function)\n   * @param {String} str    The iCalendar component string to parse\n   * @return {Object}       The jCal Object containing the component\n   */\n\n\n  parser.component = function (str) {\n    return parser(str);\n  }; // classes & constants\n\n\n  parser.ParserError = ParserError;\n  /**\n   * The state for parsing content lines from an iCalendar/vCard string.\n   *\n   * @private\n   * @memberof ICAL.parse\n   * @typedef {Object} parserState\n   * @property {ICAL.design.designSet} designSet    The design set to use for parsing\n   * @property {ICAL.Component[]} stack             The stack of components being processed\n   * @property {ICAL.Component} component           The currently active component\n   */\n\n  /**\n   * Handles a single line of iCalendar/vCard, updating the state.\n   *\n   * @private\n   * @function ICAL.parse._handleContentLine\n   * @param {String} line               The content line to process\n   * @param {ICAL.parse.parserState}    The current state of the line parsing\n   */\n\n  parser._handleContentLine = function (line, state) {\n    // break up the parts of the line\n    var valuePos = line.indexOf(VALUE_DELIMITER);\n    var paramPos = line.indexOf(PARAM_DELIMITER);\n    var lastParamIndex;\n    var lastValuePos; // name of property or begin/end\n\n    var name;\n    var value; // params is only overridden if paramPos !== -1.\n    // we can't do params = params || {} later on\n    // because it sacrifices ops.\n\n    var params = {};\n    /**\n     * Different property cases\n     *\n     *\n     * 1. RRULE:FREQ=foo\n     *    // FREQ= is not a param but the value\n     *\n     * 2. ATTENDEE;ROLE=REQ-PARTICIPANT;\n     *    // ROLE= is a param because : has not happened yet\n     */\n    // when the parameter delimiter is after the\n    // value delimiter then it is not a parameter.\n\n    if (paramPos !== -1 && valuePos !== -1) {\n      // when the parameter delimiter is after the\n      // value delimiter then it is not a parameter.\n      if (paramPos > valuePos) {\n        paramPos = -1;\n      }\n    }\n\n    var parsedParams;\n\n    if (paramPos !== -1) {\n      name = line.substring(0, paramPos).toLowerCase();\n      parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);\n\n      if (parsedParams[2] == -1) {\n        throw new ParserError(\"Invalid parameters in '\" + line + \"'\");\n      }\n\n      params = parsedParams[0];\n      lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;\n\n      if ((lastValuePos = line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {\n        value = line.substring(lastParamIndex + lastValuePos + 1);\n      } else {\n        throw new ParserError(\"Missing parameter value in '\" + line + \"'\");\n      }\n    } else if (valuePos !== -1) {\n      // without parmeters (BEGIN:VCAENDAR, CLASS:PUBLIC)\n      name = line.substring(0, valuePos).toLowerCase();\n      value = line.substring(valuePos + 1);\n\n      if (name === 'begin') {\n        var newComponent = [value.toLowerCase(), [], []];\n\n        if (state.stack.length === 1) {\n          state.component.push(newComponent);\n        } else {\n          state.component[2].push(newComponent);\n        }\n\n        state.stack.push(state.component);\n        state.component = newComponent;\n\n        if (!state.designSet) {\n          state.designSet = design.getDesignSet(state.component[0]);\n        }\n\n        return;\n      } else if (name === 'end') {\n        state.component = state.stack.pop();\n        return;\n      } // If it is not begin/end, then this is a property with an empty value,\n      // which should be considered valid.\n\n    } else {\n      /**\n       * Invalid line.\n       * The rational to throw an error is we will\n       * never be certain that the rest of the file\n       * is sane and it is unlikely that we can serialize\n       * the result correctly either.\n       */\n      throw new ParserError('invalid line (no token \";\" or \":\") \"' + line + '\"');\n    }\n\n    var valueType;\n    var multiValue = false;\n    var structuredValue = false;\n    var propertyDetails;\n\n    if (name in state.designSet.property) {\n      propertyDetails = state.designSet.property[name];\n\n      if ('multiValue' in propertyDetails) {\n        multiValue = propertyDetails.multiValue;\n      }\n\n      if ('structuredValue' in propertyDetails) {\n        structuredValue = propertyDetails.structuredValue;\n      }\n\n      if (value && 'detectType' in propertyDetails) {\n        valueType = propertyDetails.detectType(value);\n      }\n    } // attempt to determine value\n\n\n    if (!valueType) {\n      if (!('value' in params)) {\n        if (propertyDetails) {\n          valueType = propertyDetails.defaultType;\n        } else {\n          valueType = DEFAULT_VALUE_TYPE;\n        }\n      } else {\n        // possible to avoid this?\n        valueType = params.value.toLowerCase();\n      }\n    }\n\n    delete params.value;\n    /**\n     * Note on `var result` juggling:\n     *\n     * I observed that building the array in pieces has adverse\n     * effects on performance, so where possible we inline the creation.\n     * It is a little ugly but resulted in ~2000 additional ops/sec.\n     */\n\n    var result;\n\n    if (multiValue && structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else if (multiValue) {\n      result = [name, params, valueType];\n\n      parser._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);\n    } else if (structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else {\n      value = parser._parseValue(value, valueType, state.designSet, false);\n      result = [name, params, valueType, value];\n    } // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n\n\n    if (state.component[0] === 'vcard' && state.component[1].length === 0 && !(name === 'version' && value === '4.0')) {\n      state.designSet = design.getDesignSet(\"vcard3\");\n    }\n\n    state.component[1].push(result);\n  };\n  /**\n   * Parse a value from the raw value into the jCard/jCal value.\n   *\n   * @private\n   * @function ICAL.parse._parseValue\n   * @param {String} value          Original value\n   * @param {String} type           Type of value\n   * @param {Object} designSet      The design data to use for this value\n   * @return {Object} varies on type\n   */\n\n\n  parser._parseValue = function (value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'fromICAL' in designSet.value[type]) {\n      return designSet.value[type].fromICAL(value, structuredValue);\n    }\n\n    return value;\n  };\n  /**\n   * Parse parameters from a string to object.\n   *\n   * @function ICAL.parse._parseParameters\n   * @private\n   * @param {String} line           A single unfolded line\n   * @param {Numeric} start         Position to start looking for properties\n   * @param {Object} designSet      The design data to use for this property\n   * @return {Object} key/value pairs\n   */\n\n\n  parser._parseParameters = function (line, start, designSet) {\n    var lastParam = start;\n    var pos = 0;\n    var delim = PARAM_NAME_DELIMITER;\n    var result = {};\n    var name, lcname;\n    var value,\n        valuePos = -1;\n    var type, multiValue, mvdelim; // find the next '=' sign\n    // use lastParam and pos to find name\n    // check if \" is used if so get value from \"->\"\n    // then increment pos to find next ;\n\n    while (pos !== false && (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {\n      name = line.substr(lastParam + 1, pos - lastParam - 1);\n\n      if (name.length == 0) {\n        throw new ParserError(\"Empty parameter name in '\" + line + \"'\");\n      }\n\n      lcname = name.toLowerCase();\n      mvdelim = false;\n      multiValue = false;\n\n      if (lcname in designSet.param && designSet.param[lcname].valueType) {\n        type = designSet.param[lcname].valueType;\n      } else {\n        type = DEFAULT_PARAM_TYPE;\n      }\n\n      if (lcname in designSet.param) {\n        multiValue = designSet.param[lcname].multiValue;\n\n        if (designSet.param[lcname].multiValueSeparateDQuote) {\n          mvdelim = parser._rfc6868Escape('\"' + multiValue + '\"');\n        }\n      }\n\n      var nextChar = line[pos + 1];\n\n      if (nextChar === '\"') {\n        valuePos = pos + 2;\n        pos = helpers.unescapedIndexOf(line, '\"', valuePos);\n\n        if (multiValue && pos != -1) {\n          var extendedValue = true;\n\n          while (extendedValue) {\n            if (line[pos + 1] == multiValue && line[pos + 2] == '\"') {\n              pos = helpers.unescapedIndexOf(line, '\"', pos + 3);\n            } else {\n              extendedValue = false;\n            }\n          }\n        }\n\n        if (pos === -1) {\n          throw new ParserError('invalid line (no matching double quote) \"' + line + '\"');\n        }\n\n        value = line.substr(valuePos, pos - valuePos);\n        lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);\n\n        if (lastParam === -1) {\n          pos = false;\n        }\n      } else {\n        valuePos = pos + 1; // move to next \";\"\n\n        var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);\n        var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);\n\n        if (propValuePos !== -1 && nextPos > propValuePos) {\n          // this is a delimiter in the property value, let's stop here\n          nextPos = propValuePos;\n          pos = false;\n        } else if (nextPos === -1) {\n          // no \";\"\n          if (propValuePos === -1) {\n            nextPos = line.length;\n          } else {\n            nextPos = propValuePos;\n          }\n\n          pos = false;\n        } else {\n          lastParam = nextPos;\n          pos = nextPos;\n        }\n\n        value = line.substr(valuePos, nextPos - valuePos);\n      }\n\n      value = parser._rfc6868Escape(value);\n\n      if (multiValue) {\n        var delimiter = mvdelim || multiValue;\n        value = parser._parseMultiValue(value, delimiter, type, [], null, designSet);\n      } else {\n        value = parser._parseValue(value, type, designSet);\n      }\n\n      if (multiValue && lcname in result) {\n        if (Array.isArray(result[lcname])) {\n          result[lcname].push(value);\n        } else {\n          result[lcname] = [result[lcname], value];\n        }\n      } else {\n        result[lcname] = value;\n      }\n    }\n\n    return [result, value, valuePos];\n  };\n  /**\n   * Internal helper for rfc6868. Exposing this on ICAL.parse so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @function ICAL.parse._rfc6868Escape\n   * @param {String} val        The value to escape\n   * @return {String}           The escaped value\n   */\n\n\n  parser._rfc6868Escape = function (val) {\n    return val.replace(/\\^['n^]/g, function (x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n\n  var RFC6868_REPLACE_MAP = {\n    \"^'\": '\"',\n    \"^n\": \"\\n\",\n    \"^^\": \"^\"\n  };\n  /**\n   * Parse a multi value string. This function is used either for parsing\n   * actual multi-value property's values, or for handling parameter values. It\n   * can be used for both multi-value properties and structured value properties.\n   *\n   * @private\n   * @function ICAL.parse._parseMultiValue\n   * @param {String} buffer     The buffer containing the full value\n   * @param {String} delim      The multi-value delimiter\n   * @param {String} type       The value type to be parsed\n   * @param {Array.<?>} result        The array to append results to, varies on value type\n   * @param {String} innerMulti The inner delimiter to split each value with\n   * @param {ICAL.design.designSet} designSet   The design data for this value\n   * @return {?|Array.<?>}            Either an array of results, or the first result\n   */\n\n  parser._parseMultiValue = function (buffer, delim, type, result, innerMulti, designSet, structuredValue) {\n    var pos = 0;\n    var lastPos = 0;\n    var value;\n\n    if (delim.length === 0) {\n      return buffer;\n    } // split each piece\n\n\n    while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {\n      value = buffer.substr(lastPos, pos - lastPos);\n\n      if (innerMulti) {\n        value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n      } else {\n        value = parser._parseValue(value, type, designSet, structuredValue);\n      }\n\n      result.push(value);\n      lastPos = pos + delim.length;\n    } // on the last piece take the rest of string\n\n\n    value = buffer.substr(lastPos);\n\n    if (innerMulti) {\n      value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n    } else {\n      value = parser._parseValue(value, type, designSet, structuredValue);\n    }\n\n    result.push(value);\n    return result.length == 1 ? result[0] : result;\n  };\n  /**\n   * Process a complete buffer of iCalendar/vCard data line by line, correctly\n   * unfolding content. Each line will be processed with the given callback\n   *\n   * @private\n   * @function ICAL.parse._eachLine\n   * @param {String} buffer                         The buffer to process\n   * @param {function(?String, String)} callback    The callback for each line\n   */\n\n\n  parser._eachLine = function (buffer, callback) {\n    var len = buffer.length;\n    var lastPos = buffer.search(CHAR);\n    var pos = lastPos;\n    var line;\n    var firstChar;\n    var newlineOffset;\n\n    do {\n      pos = buffer.indexOf('\\n', lastPos) + 1;\n\n      if (pos > 1 && buffer[pos - 2] === '\\r') {\n        newlineOffset = 2;\n      } else {\n        newlineOffset = 1;\n      }\n\n      if (pos === 0) {\n        pos = len;\n        newlineOffset = 0;\n      }\n\n      firstChar = buffer[lastPos];\n\n      if (firstChar === ' ' || firstChar === '\\t') {\n        // add to line\n        line += buffer.substr(lastPos + 1, pos - lastPos - (newlineOffset + 1));\n      } else {\n        if (line) callback(null, line); // push line\n\n        line = buffer.substr(lastPos, pos - lastPos - newlineOffset);\n      }\n\n      lastPos = pos;\n    } while (pos !== len); // extra ending line\n\n\n    line = line.trim();\n    if (line.length) callback(null, line);\n  };\n\n  return parser;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.Component = function () {\n  'use strict';\n\n  var PROPERTY_INDEX = 1;\n  var COMPONENT_INDEX = 2;\n  var NAME_INDEX = 0;\n  /**\n   * @classdesc\n   * Wraps a jCal component, adding convenience methods to add, remove and\n   * update subcomponents and properties.\n   *\n   * @class\n   * @alias ICAL.Component\n   * @param {Array|String} jCal         Raw jCal component data OR name of new\n   *                                      component\n   * @param {ICAL.Component} parent     Parent component to associate\n   */\n\n  function Component(jCal, parent) {\n    if (typeof jCal === 'string') {\n      // jCal spec (name, properties, components)\n      jCal = [jCal, [], []];\n    } // mostly for legacy reasons.\n\n\n    this.jCal = jCal;\n    this.parent = parent || null;\n  }\n\n  Component.prototype = {\n    /**\n     * Hydrated properties are inserted into the _properties array at the same\n     * position as in the jCal array, so it is possible that the array contains\n     * undefined values for unhydrdated properties. To avoid iterating the\n     * array when checking if all properties have been hydrated, we save the\n     * count here.\n     *\n     * @type {Number}\n     * @private\n     */\n    _hydratedPropertyCount: 0,\n\n    /**\n     * The same count as for _hydratedPropertyCount, but for subcomponents\n     *\n     * @type {Number}\n     * @private\n     */\n    _hydratedComponentCount: 0,\n\n    /**\n     * The name of this component\n     * @readonly\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n\n    /**\n     * The design set for this component, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */\n    get _designSet() {\n      var parentDesign = this.parent && this.parent._designSet;\n      return parentDesign || ICAL.design.getDesignSet(this.name);\n    },\n\n    _hydrateComponent: function (index) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n\n      if (this._components[index]) {\n        return this._components[index];\n      }\n\n      var comp = new Component(this.jCal[COMPONENT_INDEX][index], this);\n      this._hydratedComponentCount++;\n      return this._components[index] = comp;\n    },\n    _hydrateProperty: function (index) {\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n\n      if (this._properties[index]) {\n        return this._properties[index];\n      }\n\n      var prop = new ICAL.Property(this.jCal[PROPERTY_INDEX][index], this);\n      this._hydratedPropertyCount++;\n      return this._properties[index] = prop;\n    },\n\n    /**\n     * Finds first sub component, optionally filtered by name.\n     *\n     * @param {String=} name        Optional name to filter by\n     * @return {?ICAL.Component}     The found subcomponent\n     */\n    getFirstSubcomponent: function (name) {\n      if (name) {\n        var i = 0;\n        var comps = this.jCal[COMPONENT_INDEX];\n        var len = comps.length;\n\n        for (; i < len; i++) {\n          if (comps[i][NAME_INDEX] === name) {\n            var result = this._hydrateComponent(i);\n\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[COMPONENT_INDEX].length) {\n          return this._hydrateComponent(0);\n        }\n      } // ensure we return a value (strict mode)\n\n\n      return null;\n    },\n\n    /**\n     * Finds all sub components, optionally filtering by name.\n     *\n     * @param {String=} name            Optional name to filter by\n     * @return {ICAL.Component[]}       The found sub components\n     */\n    getAllSubcomponents: function (name) {\n      var jCalLen = this.jCal[COMPONENT_INDEX].length;\n      var i = 0;\n\n      if (name) {\n        var comps = this.jCal[COMPONENT_INDEX];\n        var result = [];\n\n        for (; i < jCalLen; i++) {\n          if (name === comps[i][NAME_INDEX]) {\n            result.push(this._hydrateComponent(i));\n          }\n        }\n\n        return result;\n      } else {\n        if (!this._components || this._hydratedComponentCount !== jCalLen) {\n          for (; i < jCalLen; i++) {\n            this._hydrateComponent(i);\n          }\n        }\n\n        return this._components || [];\n      }\n    },\n\n    /**\n     * Returns true when a named property exists.\n     *\n     * @param {String} name     The property name\n     * @return {Boolean}        True, when property is found\n     */\n    hasProperty: function (name) {\n      var props = this.jCal[PROPERTY_INDEX];\n      var len = props.length;\n      var i = 0;\n\n      for (; i < len; i++) {\n        // 0 is property name\n        if (props[i][NAME_INDEX] === name) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Finds the first property, optionally with the given name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {?ICAL.Property}     The found property\n     */\n    getFirstProperty: function (name) {\n      if (name) {\n        var i = 0;\n        var props = this.jCal[PROPERTY_INDEX];\n        var len = props.length;\n\n        for (; i < len; i++) {\n          if (props[i][NAME_INDEX] === name) {\n            var result = this._hydrateProperty(i);\n\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[PROPERTY_INDEX].length) {\n          return this._hydrateProperty(0);\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Returns first property's value, if available.\n     *\n     * @param {String=} name    Lowercase property name\n     * @return {?String}        The found property value.\n     */\n    getFirstPropertyValue: function (name) {\n      var prop = this.getFirstProperty(name);\n\n      if (prop) {\n        return prop.getFirstValue();\n      }\n\n      return null;\n    },\n\n    /**\n     * Get all properties in the component, optionally filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {ICAL.Property[]}    List of properties\n     */\n    getAllProperties: function (name) {\n      var jCalLen = this.jCal[PROPERTY_INDEX].length;\n      var i = 0;\n\n      if (name) {\n        var props = this.jCal[PROPERTY_INDEX];\n        var result = [];\n\n        for (; i < jCalLen; i++) {\n          if (name === props[i][NAME_INDEX]) {\n            result.push(this._hydrateProperty(i));\n          }\n        }\n\n        return result;\n      } else {\n        if (!this._properties || this._hydratedPropertyCount !== jCalLen) {\n          for (; i < jCalLen; i++) {\n            this._hydrateProperty(i);\n          }\n        }\n\n        return this._properties || [];\n      }\n    },\n    _removeObjectByIndex: function (jCalIndex, cache, index) {\n      cache = cache || []; // remove cached version\n\n      if (cache[index]) {\n        var obj = cache[index];\n\n        if (\"parent\" in obj) {\n          obj.parent = null;\n        }\n      }\n\n      cache.splice(index, 1); // remove it from the jCal\n\n      this.jCal[jCalIndex].splice(index, 1);\n    },\n    _removeObject: function (jCalIndex, cache, nameOrObject) {\n      var i = 0;\n      var objects = this.jCal[jCalIndex];\n      var len = objects.length;\n      var cached = this[cache];\n\n      if (typeof nameOrObject === 'string') {\n        for (; i < len; i++) {\n          if (objects[i][NAME_INDEX] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n\n            return true;\n          }\n        }\n      } else if (cached) {\n        for (; i < len; i++) {\n          if (cached[i] && cached[i] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    _removeAllObjects: function (jCalIndex, cache, name) {\n      var cached = this[cache]; // Unfortunately we have to run through all children to reset their\n      // parent property.\n\n      var objects = this.jCal[jCalIndex];\n      var i = objects.length - 1; // descending search required because splice\n      // is used and will effect the indices.\n\n      for (; i >= 0; i--) {\n        if (!name || objects[i][NAME_INDEX] === name) {\n          this._removeObjectByIndex(jCalIndex, cached, i);\n        }\n      }\n    },\n\n    /**\n     * Adds a single sub component.\n     *\n     * @param {ICAL.Component} component        The component to add\n     * @return {ICAL.Component}                 The passed in component\n     */\n    addSubcomponent: function (component) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n\n      if (component.parent) {\n        component.parent.removeSubcomponent(component);\n      }\n\n      var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);\n      this._components[idx - 1] = component;\n      this._hydratedComponentCount++;\n      component.parent = this;\n      return component;\n    },\n\n    /**\n     * Removes a single component by name or the instance of a specific\n     * component.\n     *\n     * @param {ICAL.Component|String} nameOrComp    Name of component, or component\n     * @return {Boolean}                            True when comp is removed\n     */\n    removeSubcomponent: function (nameOrComp) {\n      var removed = this._removeObject(COMPONENT_INDEX, '_components', nameOrComp);\n\n      if (removed) {\n        this._hydratedComponentCount--;\n      }\n\n      return removed;\n    },\n\n    /**\n     * Removes all components or (if given) all components by a particular\n     * name.\n     *\n     * @param {String=} name            Lowercase component name\n     */\n    removeAllSubcomponents: function (name) {\n      var removed = this._removeAllObjects(COMPONENT_INDEX, '_components', name);\n\n      this._hydratedComponentCount = 0;\n      return removed;\n    },\n\n    /**\n     * Adds an {@link ICAL.Property} to the component.\n     *\n     * @param {ICAL.Property} property      The property to add\n     * @return {ICAL.Property}              The passed in property\n     */\n    addProperty: function (property) {\n      if (!(property instanceof ICAL.Property)) {\n        throw new TypeError('must instance of ICAL.Property');\n      }\n\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n\n      if (property.parent) {\n        property.parent.removeProperty(property);\n      }\n\n      var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);\n      this._properties[idx - 1] = property;\n      this._hydratedPropertyCount++;\n      property.parent = this;\n      return property;\n    },\n\n    /**\n     * Helper method to add a property with a value to the component.\n     *\n     * @param {String}               name         Property name to add\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */\n    addPropertyWithValue: function (name, value) {\n      var prop = new ICAL.Property(name);\n      prop.setValue(value);\n      this.addProperty(prop);\n      return prop;\n    },\n\n    /**\n     * Helper method that will update or create a property of the given name\n     * and sets its value. If multiple properties with the given name exist,\n     * only the first is updated.\n     *\n     * @param {String}               name         Property name to update\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */\n    updatePropertyWithValue: function (name, value) {\n      var prop = this.getFirstProperty(name);\n\n      if (prop) {\n        prop.setValue(value);\n      } else {\n        prop = this.addPropertyWithValue(name, value);\n      }\n\n      return prop;\n    },\n\n    /**\n     * Removes a single property by name or the instance of the specific\n     * property.\n     *\n     * @param {String|ICAL.Property} nameOrProp     Property name or instance to remove\n     * @return {Boolean}                            True, when deleted\n     */\n    removeProperty: function (nameOrProp) {\n      var removed = this._removeObject(PROPERTY_INDEX, '_properties', nameOrProp);\n\n      if (removed) {\n        this._hydratedPropertyCount--;\n      }\n\n      return removed;\n    },\n\n    /**\n     * Removes all properties associated with this component, optionally\n     * filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {Boolean}            True, when deleted\n     */\n    removeAllProperties: function (name) {\n      var removed = this._removeAllObjects(PROPERTY_INDEX, '_properties', name);\n\n      this._hydratedPropertyCount = 0;\n      return removed;\n    },\n\n    /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */\n    toJSON: function () {\n      return this.jCal;\n    },\n\n    /**\n     * The string representation of this component.\n     * @return {String}\n     */\n    toString: function () {\n      return ICAL.stringify.component(this.jCal, this._designSet);\n    }\n  };\n  /**\n   * Create an {@link ICAL.Component} by parsing the passed iCalendar string.\n   *\n   * @param {String} str        The iCalendar string to parse\n   */\n\n  Component.fromString = function (str) {\n    return new Component(ICAL.parse.component(str));\n  };\n\n  return Component;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.Property = function () {\n  'use strict';\n\n  var NAME_INDEX = 0;\n  var PROP_INDEX = 1;\n  var TYPE_INDEX = 2;\n  var VALUE_INDEX = 3;\n  var design = ICAL.design;\n  /**\n   * @classdesc\n   * Provides a layer on top of the raw jCal object for manipulating a single\n   * property, with its parameters and value.\n   *\n   * @description\n   * It is important to note that mutations done in the wrapper\n   * directly mutate the jCal object used to initialize.\n   *\n   * Can also be used to create new properties by passing\n   * the name of the property (as a String).\n   *\n   * @class\n   * @alias ICAL.Property\n   * @param {Array|String} jCal         Raw jCal representation OR\n   *  the new name of the property\n   *\n   * @param {ICAL.Component=} parent    Parent component\n   */\n\n  function Property(jCal, parent) {\n    this._parent = parent || null;\n\n    if (typeof jCal === 'string') {\n      // We are creating the property by name and need to detect the type\n      this.jCal = [jCal, {}, design.defaultType];\n      this.jCal[TYPE_INDEX] = this.getDefaultType();\n    } else {\n      this.jCal = jCal;\n    }\n\n    this._updateType();\n  }\n\n  Property.prototype = {\n    /**\n     * The value type for this property\n     * @readonly\n     * @type {String}\n     */\n    get type() {\n      return this.jCal[TYPE_INDEX];\n    },\n\n    /**\n     * The name of this property, in lowercase.\n     * @readonly\n     * @type {String}\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n\n    /**\n     * The parent component for this property.\n     * @type {ICAL.Component}\n     */\n    get parent() {\n      return this._parent;\n    },\n\n    set parent(p) {\n      // Before setting the parent, check if the design set has changed. If it\n      // has, we later need to update the type if it was unknown before.\n      var designSetChanged = !this._parent || p && p._designSet != this._parent._designSet;\n      this._parent = p;\n\n      if (this.type == design.defaultType && designSetChanged) {\n        this.jCal[TYPE_INDEX] = this.getDefaultType();\n\n        this._updateType();\n      }\n\n      return p;\n    },\n\n    /**\n     * The design set for this property, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */\n    get _designSet() {\n      return this.parent ? this.parent._designSet : design.defaultSet;\n    },\n\n    /**\n     * Updates the type metadata from the current jCal type and design set.\n     *\n     * @private\n     */\n    _updateType: function () {\n      var designSet = this._designSet;\n\n      if (this.type in designSet.value) {\n        var designType = designSet.value[this.type];\n\n        if ('decorate' in designSet.value[this.type]) {\n          this.isDecorated = true;\n        } else {\n          this.isDecorated = false;\n        }\n\n        if (this.name in designSet.property) {\n          this.isMultiValue = 'multiValue' in designSet.property[this.name];\n          this.isStructuredValue = 'structuredValue' in designSet.property[this.name];\n        }\n      }\n    },\n\n    /**\n     * Hydrate a single value. The act of hydrating means turning the raw jCal\n     * value into a potentially wrapped object, for example {@link ICAL.Time}.\n     *\n     * @private\n     * @param {Number} index        The index of the value to hydrate\n     * @return {Object}             The decorated value.\n     */\n    _hydrateValue: function (index) {\n      if (this._values && this._values[index]) {\n        return this._values[index];\n      } // for the case where there is no value.\n\n\n      if (this.jCal.length <= VALUE_INDEX + index) {\n        return null;\n      }\n\n      if (this.isDecorated) {\n        if (!this._values) {\n          this._values = [];\n        }\n\n        return this._values[index] = this._decorate(this.jCal[VALUE_INDEX + index]);\n      } else {\n        return this.jCal[VALUE_INDEX + index];\n      }\n    },\n\n    /**\n     * Decorate a single value, returning its wrapped object. This is used by\n     * the hydrate function to actually wrap the value.\n     *\n     * @private\n     * @param {?} value         The value to decorate\n     * @return {Object}         The decorated value\n     */\n    _decorate: function (value) {\n      return this._designSet.value[this.type].decorate(value, this);\n    },\n\n    /**\n     * Undecorate a single value, returning its raw jCal data.\n     *\n     * @private\n     * @param {Object} value         The value to undecorate\n     * @return {?}                   The undecorated value\n     */\n    _undecorate: function (value) {\n      return this._designSet.value[this.type].undecorate(value, this);\n    },\n\n    /**\n     * Sets the value at the given index while also hydrating it. The passed\n     * value can either be a decorated or undecorated value.\n     *\n     * @private\n     * @param {?} value             The value to set\n     * @param {Number} index        The index to set it at\n     */\n    _setDecoratedValue: function (value, index) {\n      if (!this._values) {\n        this._values = [];\n      }\n\n      if (typeof value === 'object' && 'icaltype' in value) {\n        // decorated value\n        this.jCal[VALUE_INDEX + index] = this._undecorate(value);\n        this._values[index] = value;\n      } else {\n        // undecorated value\n        this.jCal[VALUE_INDEX + index] = value;\n        this._values[index] = this._decorate(value);\n      }\n    },\n\n    /**\n     * Gets a parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {Array|String}        Parameter value\n     */\n    getParameter: function (name) {\n      if (name in this.jCal[PROP_INDEX]) {\n        return this.jCal[PROP_INDEX][name];\n      } else {\n        return undefined;\n      }\n    },\n\n    /**\n     * Gets first parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {String}        Parameter value\n     */\n    getFirstParameter: function (name) {\n      var parameters = this.getParameter(name);\n\n      if (Array.isArray(parameters)) {\n        return parameters[0];\n      }\n\n      return parameters;\n    },\n\n    /**\n     * Sets a parameter on the property.\n     *\n     * @param {String}       name     The parameter name\n     * @param {Array|String} value    The parameter value\n     */\n    setParameter: function (name, value) {\n      var lcname = name.toLowerCase();\n\n      if (typeof value === \"string\" && lcname in this._designSet.param && 'multiValue' in this._designSet.param[lcname]) {\n        value = [value];\n      }\n\n      this.jCal[PROP_INDEX][name] = value;\n    },\n\n    /**\n     * Removes a parameter\n     *\n     * @param {String} name     The parameter name\n     */\n    removeParameter: function (name) {\n      delete this.jCal[PROP_INDEX][name];\n    },\n\n    /**\n     * Get the default type based on this property's name.\n     *\n     * @return {String}     The default type for this property\n     */\n    getDefaultType: function () {\n      var name = this.jCal[NAME_INDEX];\n      var designSet = this._designSet;\n\n      if (name in designSet.property) {\n        var details = designSet.property[name];\n\n        if ('defaultType' in details) {\n          return details.defaultType;\n        }\n      }\n\n      return design.defaultType;\n    },\n\n    /**\n     * Sets type of property and clears out any existing values of the current\n     * type.\n     *\n     * @param {String} type     New iCAL type (see design.*.values)\n     */\n    resetType: function (type) {\n      this.removeAllValues();\n      this.jCal[TYPE_INDEX] = type;\n\n      this._updateType();\n    },\n\n    /**\n     * Finds the first property value.\n     *\n     * @return {String}         First property value\n     */\n    getFirstValue: function () {\n      return this._hydrateValue(0);\n    },\n\n    /**\n     * Gets all values on the property.\n     *\n     * NOTE: this creates an array during each call.\n     *\n     * @return {Array}          List of values\n     */\n    getValues: function () {\n      var len = this.jCal.length - VALUE_INDEX;\n\n      if (len < 1) {\n        // it is possible for a property to have no value.\n        return [];\n      }\n\n      var i = 0;\n      var result = [];\n\n      for (; i < len; i++) {\n        result[i] = this._hydrateValue(i);\n      }\n\n      return result;\n    },\n\n    /**\n     * Removes all values from this property\n     */\n    removeAllValues: function () {\n      if (this._values) {\n        this._values.length = 0;\n      }\n\n      this.jCal.length = 3;\n    },\n\n    /**\n     * Sets the values of the property.  Will overwrite the existing values.\n     * This can only be used for multi-value properties.\n     *\n     * @param {Array} values    An array of values\n     */\n    setValues: function (values) {\n      if (!this.isMultiValue) {\n        throw new Error(this.name + ': does not not support mulitValue.\\n' + 'override isMultiValue');\n      }\n\n      var len = values.length;\n      var i = 0;\n      this.removeAllValues();\n\n      if (len > 0 && typeof values[0] === 'object' && 'icaltype' in values[0]) {\n        this.resetType(values[0].icaltype);\n      }\n\n      if (this.isDecorated) {\n        for (; i < len; i++) {\n          this._setDecoratedValue(values[i], i);\n        }\n      } else {\n        for (; i < len; i++) {\n          this.jCal[VALUE_INDEX + i] = values[i];\n        }\n      }\n    },\n\n    /**\n     * Sets the current value of the property. If this is a multi-value\n     * property, all other values will be removed.\n     *\n     * @param {String|Object} value     New property value.\n     */\n    setValue: function (value) {\n      this.removeAllValues();\n\n      if (typeof value === 'object' && 'icaltype' in value) {\n        this.resetType(value.icaltype);\n      }\n\n      if (this.isDecorated) {\n        this._setDecoratedValue(value, 0);\n      } else {\n        this.jCal[VALUE_INDEX] = value;\n      }\n    },\n\n    /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */\n    toJSON: function () {\n      return this.jCal;\n    },\n\n    /**\n     * The string representation of this component.\n     * @return {String}\n     */\n    toICALString: function () {\n      return ICAL.stringify.property(this.jCal, this._designSet, true);\n    }\n  };\n  /**\n   * Create an {@link ICAL.Property} by parsing the passed iCalendar string.\n   *\n   * @param {String} str                        The iCalendar string to parse\n   * @param {ICAL.design.designSet=} designSet  The design data to use for this property\n   * @return {ICAL.Property}                    The created iCalendar property\n   */\n\n  Property.fromString = function (str, designSet) {\n    return new Property(ICAL.parse.property(str, designSet));\n  };\n\n  return Property;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.UtcOffset = function () {\n  /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.UtcOffset\n   * @param {Object} aData          An object with members of the utc offset\n   * @param {Number=} aData.hours   The hours for the utc offset\n   * @param {Number=} aData.minutes The minutes in the utc offset\n   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n   */\n  function UtcOffset(aData) {\n    this.fromData(aData);\n  }\n\n  UtcOffset.prototype = {\n    /**\n     * The hours in the utc-offset\n     * @type {Number}\n     */\n    hours: 0,\n\n    /**\n     * The minutes in the utc-offset\n     * @type {Number}\n     */\n    minutes: 0,\n\n    /**\n     * The sign of the utc offset, 1 for positive offset, -1 for negative\n     * offsets.\n     * @type {Number}\n     */\n    factor: 1,\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"utc-offset\"\n     */\n    icaltype: \"utc-offset\",\n\n    /**\n     * Returns a clone of the utc offset object.\n     *\n     * @return {ICAL.UtcOffset}     The cloned object\n     */\n    clone: function () {\n      return ICAL.UtcOffset.fromSeconds(this.toSeconds());\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData          An object with members of the utc offset\n     * @param {Number=} aData.hours   The hours for the utc offset\n     * @param {Number=} aData.minutes The minutes in the utc offset\n     * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n     */\n    fromData: function (aData) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (aData.hasOwnProperty(key)) {\n            this[key] = aData[key];\n          }\n        }\n      }\n\n      this._normalize();\n    },\n\n    /**\n     * Sets up the current instance from the given seconds value. The seconds\n     * value is truncated to the minute. Offsets are wrapped when the world\n     * ends, the hour after UTC+14:00 is UTC-12:00.\n     *\n     * @param {Number} aSeconds         The seconds to convert into an offset\n     */\n    fromSeconds: function (aSeconds) {\n      var secs = Math.abs(aSeconds);\n      this.factor = aSeconds < 0 ? -1 : 1;\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n      secs -= this.hours * 3600;\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      return this;\n    },\n\n    /**\n     * Convert the current offset to a value in seconds\n     *\n     * @return {Number}                 The offset in seconds\n     */\n    toSeconds: function () {\n      return this.factor * (60 * this.minutes + 3600 * this.hours);\n    },\n\n    /**\n     * Compare this utc offset with another one.\n     *\n     * @param {ICAL.UtcOffset} other        The other offset to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toSeconds();\n      var b = other.toSeconds();\n      return (a > b) - (b > a);\n    },\n    _normalize: function () {\n      // Range: 97200 seconds (with 1 hour inbetween)\n      var secs = this.toSeconds();\n      var factor = this.factor;\n\n      while (secs < -43200) {\n        // = UTC-12:00\n        secs += 97200;\n      }\n\n      while (secs > 50400) {\n        // = UTC+14:00\n        secs -= 97200;\n      }\n\n      this.fromSeconds(secs); // Avoid changing the factor when on zero seconds\n\n      if (secs == 0) {\n        this.factor = factor;\n      }\n    },\n\n    /**\n     * The iCalendar string representation of this utc-offset.\n     * @return {String}\n     */\n    toICALString: function () {\n      return ICAL.design.icalendar.value['utc-offset'].toICAL(this.toString());\n    },\n\n    /**\n     * The string representation of this utc-offset.\n     * @return {String}\n     */\n    toString: function toString() {\n      return (this.factor == 1 ? \"+\" : \"-\") + ICAL.helpers.pad2(this.hours) + ':' + ICAL.helpers.pad2(this.minutes);\n    }\n  };\n  /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed string.\n   *\n   * @param {String} aString    The string to parse\n   * @return {ICAL.Duration}    The created utc-offset instance\n   */\n\n  UtcOffset.fromString = function (aString) {\n    // -05:00\n    var options = {}; //TODO: support seconds per rfc5545 ?\n\n    options.factor = aString[0] === '+' ? 1 : -1;\n    options.hours = ICAL.helpers.strictParseInt(aString.substr(1, 2));\n    options.minutes = ICAL.helpers.strictParseInt(aString.substr(4, 2));\n    return new ICAL.UtcOffset(options);\n  };\n  /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed seconds\n   * value.\n   *\n   * @param {Number} aSeconds       The number of seconds to convert\n   */\n\n\n  UtcOffset.fromSeconds = function (aSeconds) {\n    var instance = new UtcOffset();\n    instance.fromSeconds(aSeconds);\n    return instance;\n  };\n\n  return UtcOffset;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.Binary = function () {\n  /**\n   * @classdesc\n   * Represents the BINARY value type, which contains extra methods for\n   * encoding and decoding.\n   *\n   * @class\n   * @alias ICAL.Binary\n   * @param {String} aValue     The binary data for this value\n   */\n  function Binary(aValue) {\n    this.value = aValue;\n  }\n\n  Binary.prototype = {\n    /**\n     * The type name, to be used in the jCal object.\n     * @default \"binary\"\n     * @constant\n     */\n    icaltype: \"binary\",\n\n    /**\n     * Base64 decode the current value\n     *\n     * @return {String}         The base64-decoded value\n     */\n    decodeValue: function decodeValue() {\n      return this._b64_decode(this.value);\n    },\n\n    /**\n     * Encodes the passed parameter with base64 and sets the internal\n     * value to the result.\n     *\n     * @param {String} aValue      The raw binary value to encode\n     */\n    setEncodedValue: function setEncodedValue(aValue) {\n      this.value = this._b64_encode(aValue);\n    },\n    _b64_encode: function base64_encode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Bayron Guevara\n      // +   improved by: Thunder.m\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   improved by: Rafa Kukawski (http://kukawski.pl)\n      // *     example 1: base64_encode('Kevin van Zonneveld');\n      // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['atob'] == 'function') {\n      //    return atob(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1,\n          o2,\n          o3,\n          h1,\n          h2,\n          h3,\n          h4,\n          bits,\n          i = 0,\n          ac = 0,\n          enc = \"\",\n          tmp_arr = [];\n\n      if (!data) {\n        return data;\n      }\n\n      do {\n        // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n        bits = o1 << 16 | o2 << 8 | o3;\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f; // use hexets to index into b64, and append result to encoded string\n\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n      } while (i < data.length);\n\n      enc = tmp_arr.join('');\n      var r = data.length % 3;\n      return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);\n    },\n    _b64_decode: function base64_decode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Thunder.m\n      // +      input by: Aman Gupta\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Onno Marsman\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +      input by: Brett Zamir (http://brett-zamir.me)\n      // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');\n      // *     returns 1: 'Kevin van Zonneveld'\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['btoa'] == 'function') {\n      //    return btoa(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1,\n          o2,\n          o3,\n          h1,\n          h2,\n          h3,\n          h4,\n          bits,\n          i = 0,\n          ac = 0,\n          dec = \"\",\n          tmp_arr = [];\n\n      if (!data) {\n        return data;\n      }\n\n      data += '';\n\n      do {\n        // unpack four hexets into three octets using index points in b64\n        h1 = b64.indexOf(data.charAt(i++));\n        h2 = b64.indexOf(data.charAt(i++));\n        h3 = b64.indexOf(data.charAt(i++));\n        h4 = b64.indexOf(data.charAt(i++));\n        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n        o1 = bits >> 16 & 0xff;\n        o2 = bits >> 8 & 0xff;\n        o3 = bits & 0xff;\n\n        if (h3 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1);\n        } else if (h4 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2);\n        } else {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);\n        }\n      } while (i < data.length);\n\n      dec = tmp_arr.join('');\n      return dec;\n    },\n\n    /**\n     * The string representation of this value\n     * @return {String}\n     */\n    toString: function () {\n      return this.value;\n    }\n  };\n  /**\n   * Creates a binary value from the given string.\n   *\n   * @param {String} aString        The binary value string\n   * @return {ICAL.Binary}          The binary value instance\n   */\n\n  Binary.fromString = function (aString) {\n    return new Binary(aString);\n  };\n\n  return Binary;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n(function () {\n  /**\n   * @classdesc\n   * This class represents the \"period\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @description\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @class\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   */\n  ICAL.Period = function icalperiod(aData) {\n    this.wrappedJSObject = this;\n\n    if (aData && 'start' in aData) {\n      if (aData.start && !(aData.start instanceof ICAL.Time)) {\n        throw new TypeError('.start must be an instance of ICAL.Time');\n      }\n\n      this.start = aData.start;\n    }\n\n    if (aData && aData.end && aData.duration) {\n      throw new Error('cannot accept both end and duration');\n    }\n\n    if (aData && 'end' in aData) {\n      if (aData.end && !(aData.end instanceof ICAL.Time)) {\n        throw new TypeError('.end must be an instance of ICAL.Time');\n      }\n\n      this.end = aData.end;\n    }\n\n    if (aData && 'duration' in aData) {\n      if (aData.duration && !(aData.duration instanceof ICAL.Duration)) {\n        throw new TypeError('.duration must be an instance of ICAL.Duration');\n      }\n\n      this.duration = aData.duration;\n    }\n  };\n\n  ICAL.Period.prototype = {\n    /**\n     * The start of the period\n     * @type {ICAL.Time}\n     */\n    start: null,\n\n    /**\n     * The end of the period\n     * @type {ICAL.Time}\n     */\n    end: null,\n\n    /**\n     * The duration of the period\n     * @type {ICAL.Duration}\n     */\n    duration: null,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalperiod\"\n     */\n    icalclass: \"icalperiod\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"period\"\n     */\n    icaltype: \"period\",\n\n    /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Period}      The cloned object\n     */\n    clone: function () {\n      return ICAL.Period.fromData({\n        start: this.start ? this.start.clone() : null,\n        end: this.end ? this.end.clone() : null,\n        duration: this.duration ? this.duration.clone() : null\n      });\n    },\n\n    /**\n     * Calculates the duration of the period, either directly or by subtracting\n     * start from end date.\n     *\n     * @return {ICAL.Duration}      The calculated duration\n     */\n    getDuration: function duration() {\n      if (this.duration) {\n        return this.duration;\n      } else {\n        return this.end.subtractDate(this.start);\n      }\n    },\n\n    /**\n     * Calculates the end date of the period, either directly or by adding\n     * duration to start date.\n     *\n     * @return {ICAL.Time}          The calculated end date\n     */\n    getEnd: function () {\n      if (this.end) {\n        return this.end;\n      } else {\n        var end = this.start.clone();\n        end.addDuration(this.duration);\n        return end;\n      }\n    },\n\n    /**\n     * The string representation of this period.\n     * @return {String}\n     */\n    toString: function toString() {\n      return this.start + \"/\" + (this.end || this.duration);\n    },\n\n    /**\n     * The jCal representation of this period type.\n     * @return {Object}\n     */\n    toJSON: function () {\n      return [this.start.toString(), (this.end || this.duration).toString()];\n    },\n\n    /**\n     * The iCalendar string representation of this period.\n     * @return {String}\n     */\n    toICALString: function () {\n      return this.start.toICALString() + \"/\" + (this.end || this.duration).toICALString();\n    }\n  };\n  /**\n   * Creates a new {@link ICAL.Period} instance from the passed string.\n   *\n   * @param {String} str            The string to parse\n   * @param {ICAL.Property} prop    The property this period will be on\n   * @return {ICAL.Period}          The created period instance\n   */\n\n  ICAL.Period.fromString = function fromString(str, prop) {\n    var parts = str.split('/');\n\n    if (parts.length !== 2) {\n      throw new Error('Invalid string value: \"' + str + '\" must contain a \"/\" char.');\n    }\n\n    var options = {\n      start: ICAL.Time.fromDateTimeString(parts[0], prop)\n    };\n    var end = parts[1];\n\n    if (ICAL.Duration.isValueString(end)) {\n      options.duration = ICAL.Duration.fromString(end);\n    } else {\n      options.end = ICAL.Time.fromDateTimeString(end, prop);\n    }\n\n    return new ICAL.Period(options);\n  };\n  /**\n   * Creates a new {@link ICAL.Period} instance from the given data object.\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   * @return {ICAL.Period}                  The period instance\n   */\n\n\n  ICAL.Period.fromData = function fromData(aData) {\n    return new ICAL.Period(aData);\n  };\n  /**\n   * Returns a new period instance from the given jCal data array. The first\n   * member is always the start date string, the second member is either a\n   * duration or end date string.\n   *\n   * @param {Array<String,String>} aData    The jCal data array\n   * @param {ICAL.Property} aProp           The property this jCal data is on\n   * @param {Boolean} aLenient              If true, data value can be both date and date-time\n   * @return {ICAL.Period}                  The period instance\n   */\n\n\n  ICAL.Period.fromJSON = function (aData, aProp, aLenient) {\n    function fromDateOrDateTimeString(aValue, aProp) {\n      if (aLenient) {\n        return ICAL.Time.fromString(aValue, aProp);\n      } else {\n        return ICAL.Time.fromDateTimeString(aValue, aProp);\n      }\n    }\n\n    if (ICAL.Duration.isValueString(aData[1])) {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        duration: ICAL.Duration.fromString(aData[1])\n      });\n    } else {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        end: fromDateOrDateTimeString(aData[1], aProp)\n      });\n    }\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n(function () {\n  var DURATION_LETTERS = /([PDWHMTS]{1,1})/;\n  /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Duration\n   * @param {Object} data               An object with members of the duration\n   * @param {Number} data.weeks         Duration in weeks\n   * @param {Number} data.days          Duration in days\n   * @param {Number} data.hours         Duration in hours\n   * @param {Number} data.minutes       Duration in minutes\n   * @param {Number} data.seconds       Duration in seconds\n   * @param {Boolean} data.isNegative   If true, the duration is negative\n   */\n\n  ICAL.Duration = function icalduration(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n\n  ICAL.Duration.prototype = {\n    /**\n     * The weeks in this duration\n     * @type {Number}\n     * @default 0\n     */\n    weeks: 0,\n\n    /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */\n    days: 0,\n\n    /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */\n    hours: 0,\n\n    /**\n     * The minutes in this duration\n     * @type {Number}\n     * @default 0\n     */\n    minutes: 0,\n\n    /**\n     * The seconds in this duration\n     * @type {Number}\n     * @default 0\n     */\n    seconds: 0,\n\n    /**\n     * The seconds in this duration\n     * @type {Boolean}\n     * @default false\n     */\n    isNegative: false,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalduration\"\n     */\n    icalclass: \"icalduration\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"duration\"\n     */\n    icaltype: \"duration\",\n\n    /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Duration}      The cloned object\n     */\n    clone: function clone() {\n      return ICAL.Duration.fromData(this);\n    },\n\n    /**\n     * The duration value expressed as a number of seconds.\n     *\n     * @return {Number}             The duration value in seconds\n     */\n    toSeconds: function toSeconds() {\n      var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours + 86400 * this.days + 7 * 86400 * this.weeks;\n      return this.isNegative ? -seconds : seconds;\n    },\n\n    /**\n     * Reads the passed seconds value into this duration object. Afterwards,\n     * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up\n     * accordingly.\n     *\n     * @param {Number} aSeconds     The duration value in seconds\n     * @return {ICAL.Duration}      Returns this instance\n     */\n    fromSeconds: function fromSeconds(aSeconds) {\n      var secs = Math.abs(aSeconds);\n      this.isNegative = aSeconds < 0;\n      this.days = ICAL.helpers.trunc(secs / 86400); // If we have a flat number of weeks, use them.\n\n      if (this.days % 7 == 0) {\n        this.weeks = this.days / 7;\n        this.days = 0;\n      } else {\n        this.weeks = 0;\n      }\n\n      secs -= (this.days + 7 * this.weeks) * 86400;\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n      secs -= this.hours * 3600;\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      secs -= this.minutes * 60;\n      this.seconds = secs;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData               An object with members of the duration\n     * @param {Number} aData.weeks         Duration in weeks\n     * @param {Number} aData.days          Duration in days\n     * @param {Number} aData.hours         Duration in hours\n     * @param {Number} aData.minutes       Duration in minutes\n     * @param {Number} aData.seconds       Duration in seconds\n     * @param {Boolean} aData.isNegative   If true, the duration is negative\n     */\n    fromData: function fromData(aData) {\n      var propsToCopy = [\"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\", \"isNegative\"];\n\n      for (var key in propsToCopy) {\n        /* istanbul ignore if */\n        if (!propsToCopy.hasOwnProperty(key)) {\n          continue;\n        }\n\n        var prop = propsToCopy[key];\n\n        if (aData && prop in aData) {\n          this[prop] = aData[prop];\n        } else {\n          this[prop] = 0;\n        }\n      }\n    },\n\n    /**\n     * Resets the duration instance to the default values, i.e. PT0S\n     */\n    reset: function reset() {\n      this.isNegative = false;\n      this.weeks = 0;\n      this.days = 0;\n      this.hours = 0;\n      this.minutes = 0;\n      this.seconds = 0;\n    },\n\n    /**\n     * Compares the duration instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function compare(aOther) {\n      var thisSeconds = this.toSeconds();\n      var otherSeconds = aOther.toSeconds();\n      return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);\n    },\n\n    /**\n     * Normalizes the duration instance. For example, a duration with a value\n     * of 61 seconds will be normalized to 1 minute and 1 second.\n     */\n    normalize: function normalize() {\n      this.fromSeconds(this.toSeconds());\n    },\n\n    /**\n     * The string representation of this duration.\n     * @return {String}\n     */\n    toString: function toString() {\n      if (this.toSeconds() == 0) {\n        return \"PT0S\";\n      } else {\n        var str = \"\";\n        if (this.isNegative) str += \"-\";\n        str += \"P\";\n        if (this.weeks) str += this.weeks + \"W\";\n        if (this.days) str += this.days + \"D\";\n\n        if (this.hours || this.minutes || this.seconds) {\n          str += \"T\";\n          if (this.hours) str += this.hours + \"H\";\n          if (this.minutes) str += this.minutes + \"M\";\n          if (this.seconds) str += this.seconds + \"S\";\n        }\n\n        return str;\n      }\n    },\n\n    /**\n     * The iCalendar string representation of this duration.\n     * @return {String}\n     */\n    toICALString: function () {\n      return this.toString();\n    }\n  };\n  /**\n   * Returns a new ICAL.Duration instance from the passed seconds value.\n   *\n   * @param {Number} aSeconds       The seconds to create the instance from\n   * @return {ICAL.Duration}        The newly created duration instance\n   */\n\n  ICAL.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {\n    return new ICAL.Duration().fromSeconds(aSeconds);\n  };\n  /**\n   * Internal helper function to handle a chunk of a duration.\n   *\n   * @param {String} letter type of duration chunk\n   * @param {String} number numeric value or -/+\n   * @param {Object} dict target to assign values to\n   */\n\n\n  function parseDurationChunk(letter, number, object) {\n    var type;\n\n    switch (letter) {\n      case 'P':\n        if (number && number === '-') {\n          object.isNegative = true;\n        } else {\n          object.isNegative = false;\n        } // period\n\n\n        break;\n\n      case 'D':\n        type = 'days';\n        break;\n\n      case 'W':\n        type = 'weeks';\n        break;\n\n      case 'H':\n        type = 'hours';\n        break;\n\n      case 'M':\n        type = 'minutes';\n        break;\n\n      case 'S':\n        type = 'seconds';\n        break;\n\n      default:\n        // Not a valid chunk\n        return 0;\n    }\n\n    if (type) {\n      if (!number && number !== 0) {\n        throw new Error('invalid duration value: Missing number before \"' + letter + '\"');\n      }\n\n      var num = parseInt(number, 10);\n\n      if (ICAL.helpers.isStrictlyNaN(num)) {\n        throw new Error('invalid duration value: Invalid number \"' + number + '\" before \"' + letter + '\"');\n      }\n\n      object[type] = num;\n    }\n\n    return 1;\n  }\n  /**\n   * Checks if the given string is an iCalendar duration value.\n   *\n   * @param {String} value      The raw ical value\n   * @return {Boolean}          True, if the given value is of the\n   *                              duration ical type\n   */\n\n\n  ICAL.Duration.isValueString = function (string) {\n    return string[0] === 'P' || string[1] === 'P';\n  };\n  /**\n   * Creates a new {@link ICAL.Duration} instance from the passed string.\n   *\n   * @param {String} aStr       The string to parse\n   * @return {ICAL.Duration}    The created duration instance\n   */\n\n\n  ICAL.Duration.fromString = function icalduration_from_string(aStr) {\n    var pos = 0;\n    var dict = Object.create(null);\n    var chunks = 0;\n\n    while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {\n      var type = aStr[pos];\n      var numeric = aStr.substr(0, pos);\n      aStr = aStr.substr(pos + 1);\n      chunks += parseDurationChunk(type, numeric, dict);\n    }\n\n    if (chunks < 2) {\n      // There must be at least a chunk with \"P\" and some unit chunk\n      throw new Error('invalid duration value: Not enough duration components in \"' + aStr + '\"');\n    }\n\n    return new ICAL.Duration(dict);\n  };\n  /**\n   * Creates a new ICAL.Duration instance from the given data object.\n   *\n   * @param {Object} aData               An object with members of the duration\n   * @param {Number} aData.weeks         Duration in weeks\n   * @param {Number} aData.days          Duration in days\n   * @param {Number} aData.hours         Duration in hours\n   * @param {Number} aData.minutes       Duration in minutes\n   * @param {Number} aData.seconds       Duration in seconds\n   * @param {Boolean} aData.isNegative   If true, the duration is negative\n   * @return {ICAL.Duration}             The createad duration instance\n   */\n\n\n  ICAL.Duration.fromData = function icalduration_from_data(aData) {\n    return new ICAL.Duration(aData);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2012 */\n\n\n(function () {\n  var OPTIONS = [\"tzid\", \"location\", \"tznames\", \"latitude\", \"longitude\"];\n  /**\n   * @classdesc\n   * Timezone representation, created by passing in a tzid and component.\n   *\n   * @example\n   * var vcalendar;\n   * var timezoneComp = vcalendar.getFirstSubcomponent('vtimezone');\n   * var tzid = timezoneComp.getFirstPropertyValue('tzid');\n   *\n   * var timezone = new ICAL.Timezone({\n   *   component: timezoneComp,\n   *   tzid\n   * });\n   *\n   * @class\n   * @param {ICAL.Component|Object} data options for class\n   * @param {String|ICAL.Component} data.component\n   *        If data is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} data.tzid      The timezone identifier\n   * @param {String} data.location  The timezone locationw\n   * @param {String} data.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} data.latitude  The latitude of the timezone\n   * @param {Number} data.longitude The longitude of the timezone\n   */\n\n  ICAL.Timezone = function icaltimezone(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n\n  ICAL.Timezone.prototype = {\n    /**\n     * Timezone identifier\n     * @type {String}\n     */\n    tzid: \"\",\n\n    /**\n     * Timezone location\n     * @type {String}\n     */\n    location: \"\",\n\n    /**\n     * Alternative timezone name, for the string representation\n     * @type {String}\n     */\n    tznames: \"\",\n\n    /**\n     * The primary latitude for the timezone.\n     * @type {Number}\n     */\n    latitude: 0.0,\n\n    /**\n     * The primary longitude for the timezone.\n     * @type {Number}\n     */\n    longitude: 0.0,\n\n    /**\n     * The vtimezone component for this timezone.\n     * @type {ICAL.Component}\n     */\n    component: null,\n\n    /**\n     * The year this timezone has been expanded to. All timezone transition\n     * dates until this year are known and can be used for calculation\n     *\n     * @private\n     * @type {Number}\n     */\n    expandedUntilYear: 0,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltimezone\"\n     */\n    icalclass: \"icaltimezone\",\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {ICAL.Component|Object} aData options for class\n     * @param {String|ICAL.Component} aData.component\n     *        If aData is a simple object, then this member can be set to either a\n     *        string containing the component data, or an already parsed\n     *        ICAL.Component\n     * @param {String} aData.tzid      The timezone identifier\n     * @param {String} aData.location  The timezone locationw\n     * @param {String} aData.tznames   An alternative string representation of the\n     *                                  timezone\n     * @param {Number} aData.latitude  The latitude of the timezone\n     * @param {Number} aData.longitude The longitude of the timezone\n     */\n    fromData: function fromData(aData) {\n      this.expandedUntilYear = 0;\n      this.changes = [];\n\n      if (aData instanceof ICAL.Component) {\n        // Either a component is passed directly\n        this.component = aData;\n      } else {\n        // Otherwise the component may be in the data object\n        if (aData && \"component\" in aData) {\n          if (typeof aData.component == \"string\") {\n            // If a string was passed, parse it as a component\n            var jCal = ICAL.parse(aData.component);\n            this.component = new ICAL.Component(jCal);\n          } else if (aData.component instanceof ICAL.Component) {\n            // If it was a component already, then just set it\n            this.component = aData.component;\n          } else {\n            // Otherwise just null out the component\n            this.component = null;\n          }\n        } // Copy remaining passed properties\n\n\n        for (var key in OPTIONS) {\n          /* istanbul ignore else */\n          if (OPTIONS.hasOwnProperty(key)) {\n            var prop = OPTIONS[key];\n\n            if (aData && prop in aData) {\n              this[prop] = aData[prop];\n            }\n          }\n        }\n      } // If we have a component but no TZID, attempt to get it from the\n      // component's properties.\n\n\n      if (this.component instanceof ICAL.Component && !this.tzid) {\n        this.tzid = this.component.getFirstPropertyValue('tzid');\n      }\n\n      return this;\n    },\n\n    /**\n     * Finds the utcOffset the given time would occur in this timezone.\n     *\n     * @param {ICAL.Time} tt        The time to check for\n     * @return {Number} utc offset in seconds\n     */\n    utcOffset: function utcOffset(tt) {\n      if (this == ICAL.Timezone.utcTimezone || this == ICAL.Timezone.localTimezone) {\n        return 0;\n      }\n\n      this._ensureCoverage(tt.year);\n\n      if (!this.changes.length) {\n        return 0;\n      }\n\n      var tt_change = {\n        year: tt.year,\n        month: tt.month,\n        day: tt.day,\n        hour: tt.hour,\n        minute: tt.minute,\n        second: tt.second\n      };\n\n      var change_num = this._findNearbyChange(tt_change);\n\n      var change_num_to_use = -1;\n      var step = 1; // TODO: replace with bin search?\n\n      for (;;) {\n        var change = ICAL.helpers.clone(this.changes[change_num], true);\n\n        if (change.utcOffset < change.prevUtcOffset) {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);\n        } else {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0, change.prevUtcOffset);\n        }\n\n        var cmp = ICAL.Timezone._compare_change_fn(tt_change, change);\n\n        if (cmp >= 0) {\n          change_num_to_use = change_num;\n        } else {\n          step = -1;\n        }\n\n        if (step == -1 && change_num_to_use != -1) {\n          break;\n        }\n\n        change_num += step;\n\n        if (change_num < 0) {\n          return 0;\n        }\n\n        if (change_num >= this.changes.length) {\n          break;\n        }\n      }\n\n      var zone_change = this.changes[change_num_to_use];\n      var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;\n\n      if (utcOffset_change < 0 && change_num_to_use > 0) {\n        var tmp_change = ICAL.helpers.clone(zone_change, true);\n        ICAL.Timezone.adjust_change(tmp_change, 0, 0, 0, tmp_change.prevUtcOffset);\n\n        if (ICAL.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {\n          var prev_zone_change = this.changes[change_num_to_use - 1];\n          var want_daylight = false; // TODO\n\n          if (zone_change.is_daylight != want_daylight && prev_zone_change.is_daylight == want_daylight) {\n            zone_change = prev_zone_change;\n          }\n        }\n      } // TODO return is_daylight?\n\n\n      return zone_change.utcOffset;\n    },\n    _findNearbyChange: function icaltimezone_find_nearby_change(change) {\n      // find the closest match\n      var idx = ICAL.helpers.binsearchInsert(this.changes, change, ICAL.Timezone._compare_change_fn);\n\n      if (idx >= this.changes.length) {\n        return this.changes.length - 1;\n      }\n\n      return idx;\n    },\n    _ensureCoverage: function (aYear) {\n      if (ICAL.Timezone._minimumExpansionYear == -1) {\n        var today = ICAL.Time.now();\n        ICAL.Timezone._minimumExpansionYear = today.year;\n      }\n\n      var changesEndYear = aYear;\n\n      if (changesEndYear < ICAL.Timezone._minimumExpansionYear) {\n        changesEndYear = ICAL.Timezone._minimumExpansionYear;\n      }\n\n      changesEndYear += ICAL.Timezone.EXTRA_COVERAGE;\n\n      if (changesEndYear > ICAL.Timezone.MAX_YEAR) {\n        changesEndYear = ICAL.Timezone.MAX_YEAR;\n      }\n\n      if (!this.changes.length || this.expandedUntilYear < aYear) {\n        var subcomps = this.component.getAllSubcomponents();\n        var compLen = subcomps.length;\n        var compIdx = 0;\n\n        for (; compIdx < compLen; compIdx++) {\n          this._expandComponent(subcomps[compIdx], changesEndYear, this.changes);\n        }\n\n        this.changes.sort(ICAL.Timezone._compare_change_fn);\n        this.expandedUntilYear = changesEndYear;\n      }\n    },\n    _expandComponent: function (aComponent, aYear, changes) {\n      if (!aComponent.hasProperty(\"dtstart\") || !aComponent.hasProperty(\"tzoffsetto\") || !aComponent.hasProperty(\"tzoffsetfrom\")) {\n        return null;\n      }\n\n      var dtstart = aComponent.getFirstProperty(\"dtstart\").getFirstValue();\n      var change;\n\n      function convert_tzoffset(offset) {\n        return offset.factor * (offset.hours * 3600 + offset.minutes * 60);\n      }\n\n      function init_changes() {\n        var changebase = {};\n        changebase.is_daylight = aComponent.name == \"daylight\";\n        changebase.utcOffset = convert_tzoffset(aComponent.getFirstProperty(\"tzoffsetto\").getFirstValue());\n        changebase.prevUtcOffset = convert_tzoffset(aComponent.getFirstProperty(\"tzoffsetfrom\").getFirstValue());\n        return changebase;\n      }\n\n      if (!aComponent.hasProperty(\"rrule\") && !aComponent.hasProperty(\"rdate\")) {\n        change = init_changes();\n        change.year = dtstart.year;\n        change.month = dtstart.month;\n        change.day = dtstart.day;\n        change.hour = dtstart.hour;\n        change.minute = dtstart.minute;\n        change.second = dtstart.second;\n        ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n        changes.push(change);\n      } else {\n        var props = aComponent.getAllProperties(\"rdate\");\n\n        for (var rdatekey in props) {\n          /* istanbul ignore if */\n          if (!props.hasOwnProperty(rdatekey)) {\n            continue;\n          }\n\n          var rdate = props[rdatekey];\n          var time = rdate.getFirstValue();\n          change = init_changes();\n          change.year = time.year;\n          change.month = time.month;\n          change.day = time.day;\n\n          if (time.isDate) {\n            change.hour = dtstart.hour;\n            change.minute = dtstart.minute;\n            change.second = dtstart.second;\n\n            if (dtstart.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n            }\n          } else {\n            change.hour = time.hour;\n            change.minute = time.minute;\n            change.second = time.second;\n\n            if (time.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n            }\n          }\n\n          changes.push(change);\n        }\n\n        var rrule = aComponent.getFirstProperty(\"rrule\");\n\n        if (rrule) {\n          rrule = rrule.getFirstValue();\n          change = init_changes();\n\n          if (rrule.until && rrule.until.zone == ICAL.Timezone.utcTimezone) {\n            rrule.until.adjust(0, 0, 0, change.prevUtcOffset);\n            rrule.until.zone = ICAL.Timezone.localTimezone;\n          }\n\n          var iterator = rrule.iterator(dtstart);\n          var occ;\n\n          while (occ = iterator.next()) {\n            change = init_changes();\n\n            if (occ.year > aYear || !occ) {\n              break;\n            }\n\n            change.year = occ.year;\n            change.month = occ.month;\n            change.day = occ.day;\n            change.hour = occ.hour;\n            change.minute = occ.minute;\n            change.second = occ.second;\n            change.isDate = occ.isDate;\n            ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n            changes.push(change);\n          }\n        }\n      }\n\n      return changes;\n    },\n\n    /**\n     * The string representation of this timezone.\n     * @return {String}\n     */\n    toString: function toString() {\n      return this.tznames ? this.tznames : this.tzid;\n    }\n  };\n\n  ICAL.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a, b) {\n    if (a.year < b.year) return -1;else if (a.year > b.year) return 1;\n    if (a.month < b.month) return -1;else if (a.month > b.month) return 1;\n    if (a.day < b.day) return -1;else if (a.day > b.day) return 1;\n    if (a.hour < b.hour) return -1;else if (a.hour > b.hour) return 1;\n    if (a.minute < b.minute) return -1;else if (a.minute > b.minute) return 1;\n    if (a.second < b.second) return -1;else if (a.second > b.second) return 1;\n    return 0;\n  };\n  /**\n   * Convert the date/time from one zone to the next.\n   *\n   * @param {ICAL.Time} tt                  The time to convert\n   * @param {ICAL.Timezone} from_zone       The source zone to convert from\n   * @param {ICAL.Timezone} to_zone         The target zone to convert to\n   * @return {ICAL.Time}                    The converted date/time object\n   */\n\n\n  ICAL.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {\n    if (tt.isDate || from_zone.tzid == to_zone.tzid || from_zone == ICAL.Timezone.localTimezone || to_zone == ICAL.Timezone.localTimezone) {\n      tt.zone = to_zone;\n      return tt;\n    }\n\n    var utcOffset = from_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, -utcOffset);\n    utcOffset = to_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, utcOffset);\n    return null;\n  };\n  /**\n   * Creates a new ICAL.Timezone instance from the passed data object.\n   *\n   * @param {ICAL.Component|Object} aData options for class\n   * @param {String|ICAL.Component} aData.component\n   *        If aData is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} aData.tzid      The timezone identifier\n   * @param {String} aData.location  The timezone locationw\n   * @param {String} aData.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} aData.latitude  The latitude of the timezone\n   * @param {Number} aData.longitude The longitude of the timezone\n   */\n\n\n  ICAL.Timezone.fromData = function icaltimezone_fromData(aData) {\n    var tt = new ICAL.Timezone();\n    return tt.fromData(aData);\n  };\n  /**\n   * The instance describing the UTC timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */\n\n\n  ICAL.Timezone.utcTimezone = ICAL.Timezone.fromData({\n    tzid: \"UTC\"\n  });\n  /**\n   * The instance describing the local timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */\n\n  ICAL.Timezone.localTimezone = ICAL.Timezone.fromData({\n    tzid: \"floating\"\n  });\n  /**\n   * Adjust a timezone change object.\n   * @private\n   * @param {Object} change     The timezone change object\n   * @param {Number} days       The extra amount of days\n   * @param {Number} hours      The extra amount of hours\n   * @param {Number} minutes    The extra amount of minutes\n   * @param {Number} seconds    The extra amount of seconds\n   */\n\n  ICAL.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {\n    return ICAL.Time.prototype.adjust.call(change, days, hours, minutes, seconds, change);\n  };\n\n  ICAL.Timezone._minimumExpansionYear = -1;\n  ICAL.Timezone.MAX_YEAR = 2035; // TODO this is because of time_t, which we don't need. Still usefull?\n\n  ICAL.Timezone.EXTRA_COVERAGE = 5;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.TimezoneService = function () {\n  var zones;\n  /**\n   * @classdesc\n   * Singleton class to contain timezones.  Right now it is all manual registry in\n   * the future we may use this class to download timezone information or handle\n   * loading pre-expanded timezones.\n   *\n   * @namespace\n   * @alias ICAL.TimezoneService\n   */\n\n  var TimezoneService = {\n    get count() {\n      return Object.keys(zones).length;\n    },\n\n    reset: function () {\n      zones = Object.create(null);\n      var utc = ICAL.Timezone.utcTimezone;\n      zones.Z = utc;\n      zones.UTC = utc;\n      zones.GMT = utc;\n    },\n\n    /**\n     * Checks if timezone id has been registered.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {Boolean}        False, when not present\n     */\n    has: function (tzid) {\n      return !!zones[tzid];\n    },\n\n    /**\n     * Returns a timezone by its tzid if present.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The timezone, or null if not found\n     */\n    get: function (tzid) {\n      return zones[tzid];\n    },\n\n    /**\n     * Registers a timezone object or component.\n     *\n     * @param {String=} name\n     *        The name of the timezone. Defaults to the component's TZID if not\n     *        passed.\n     * @param {ICAL.Component|ICAL.Timezone} zone\n     *        The initialized zone or vtimezone.\n     */\n    register: function (name, timezone) {\n      if (name instanceof ICAL.Component) {\n        if (name.name === 'vtimezone') {\n          timezone = new ICAL.Timezone(name);\n          name = timezone.tzid;\n        }\n      }\n\n      if (timezone instanceof ICAL.Timezone) {\n        zones[name] = timezone;\n      } else {\n        throw new TypeError('timezone must be ICAL.Timezone or ICAL.Component');\n      }\n    },\n\n    /**\n     * Removes a timezone by its tzid from the list.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The removed timezone, or null if not registered\n     */\n    remove: function (tzid) {\n      return delete zones[tzid];\n    }\n  }; // initialize defaults\n\n  TimezoneService.reset();\n  return TimezoneService;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n(function () {\n  /**\n   * @classdesc\n   * iCalendar Time representation (similar to JS Date object).  Fully\n   * independent of system (OS) timezone / time.  Unlike JS Date, the month\n   * January is 1, not zero.\n   *\n   * @example\n   * var time = new ICAL.Time({\n   *   year: 2012,\n   *   month: 10,\n   *   day: 11\n   *   minute: 0,\n   *   second: 0,\n   *   isDate: false\n   * });\n   *\n   *\n   * @alias ICAL.Time\n   * @class\n   * @param {Object} data           Time initialization\n   * @param {Number=} data.year     The year for this date\n   * @param {Number=} data.month    The month for this date\n   * @param {Number=} data.day      The day for this date\n   * @param {Number=} data.hour     The hour for this date\n   * @param {Number=} data.minute   The minute for this date\n   * @param {Number=} data.second   The second for this date\n   * @param {Boolean=} data.isDate  If true, the instance represents a date (as\n   *                                  opposed to a date-time)\n   * @param {ICAL.Timezone} zone timezone this position occurs in\n   */\n  ICAL.Time = function icaltime(data, zone) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n    /* time defaults */\n\n    time.year = 0;\n    time.month = 1;\n    time.day = 1;\n    time.hour = 0;\n    time.minute = 0;\n    time.second = 0;\n    time.isDate = false;\n    this.fromData(data, zone);\n  };\n\n  ICAL.Time._dowCache = {};\n  ICAL.Time._wnCache = {};\n  ICAL.Time.prototype = {\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltime\"\n     */\n    icalclass: \"icaltime\",\n    _cachedUnixTime: null,\n\n    /**\n     * The type name, to be used in the jCal object. This value may change and\n     * is strictly defined by the {@link ICAL.Time#isDate isDate} member.\n     * @readonly\n     * @type {String}\n     * @default \"date-time\"\n     */\n    get icaltype() {\n      return this.isDate ? 'date' : 'date-time';\n    },\n\n    /**\n     * The timezone for this time.\n     * @type {ICAL.Timezone}\n     */\n    zone: null,\n\n    /**\n     * Internal uses to indicate that a change has been made and the next read\n     * operation must attempt to normalize the value (for example changing the\n     * day to 33).\n     *\n     * @type {Boolean}\n     * @private\n     */\n    _pendingNormalization: false,\n\n    /**\n     * Returns a clone of the time object.\n     *\n     * @return {ICAL.Time}              The cloned object\n     */\n    clone: function () {\n      return new ICAL.Time(this._time, this.zone);\n    },\n\n    /**\n     * Reset the time instance to epoch time\n     */\n    reset: function icaltime_reset() {\n      this.fromData(ICAL.Time.epochTime);\n      this.zone = ICAL.Timezone.utcTimezone;\n    },\n\n    /**\n     * Reset the time instance to the given date/time values.\n     *\n     * @param {Number} year             The year to set\n     * @param {Number} month            The month to set\n     * @param {Number} day              The day to set\n     * @param {Number} hour             The hour to set\n     * @param {Number} minute           The minute to set\n     * @param {Number} second           The second to set\n     * @param {ICAL.Timezone} timezone  The timezone to set\n     */\n    resetTo: function icaltime_resetTo(year, month, day, hour, minute, second, timezone) {\n      this.fromData({\n        year: year,\n        month: month,\n        day: day,\n        hour: hour,\n        minute: minute,\n        second: second,\n        zone: timezone\n      });\n    },\n\n    /**\n     * Set up the current instance from the Javascript date value.\n     *\n     * @param {?Date} aDate     The Javascript Date to read, or null to reset\n     * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n     */\n    fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {\n      if (!aDate) {\n        this.reset();\n      } else {\n        if (useUTC) {\n          this.zone = ICAL.Timezone.utcTimezone;\n          this.year = aDate.getUTCFullYear();\n          this.month = aDate.getUTCMonth() + 1;\n          this.day = aDate.getUTCDate();\n          this.hour = aDate.getUTCHours();\n          this.minute = aDate.getUTCMinutes();\n          this.second = aDate.getUTCSeconds();\n        } else {\n          this.zone = ICAL.Timezone.localTimezone;\n          this.year = aDate.getFullYear();\n          this.month = aDate.getMonth() + 1;\n          this.day = aDate.getDate();\n          this.hour = aDate.getHours();\n          this.minute = aDate.getMinutes();\n          this.second = aDate.getSeconds();\n        }\n      }\n\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData            Time initialization\n     * @param {Number=} aData.year      The year for this date\n     * @param {Number=} aData.month     The month for this date\n     * @param {Number=} aData.day       The day for this date\n     * @param {Number=} aData.hour      The hour for this date\n     * @param {Number=} aData.minute    The minute for this date\n     * @param {Number=} aData.second    The second for this date\n     * @param {Boolean=} aData.isDate   If true, the instance represents a date\n     *                                    (as opposed to a date-time)\n     * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n     */\n    fromData: function fromData(aData, aZone) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (Object.prototype.hasOwnProperty.call(aData, key)) {\n            // ical type cannot be set\n            if (key === 'icaltype') continue;\n            this[key] = aData[key];\n          }\n        }\n      }\n\n      if (aZone) {\n        this.zone = aZone;\n      }\n\n      if (aData && !(\"isDate\" in aData)) {\n        this.isDate = !(\"hour\" in aData);\n      } else if (aData && \"isDate\" in aData) {\n        this.isDate = aData.isDate;\n      }\n\n      if (aData && \"timezone\" in aData) {\n        var zone = ICAL.TimezoneService.get(aData.timezone);\n        this.zone = zone || ICAL.Timezone.localTimezone;\n      }\n\n      if (aData && \"zone\" in aData) {\n        this.zone = aData.zone;\n      }\n\n      if (!this.zone) {\n        this.zone = ICAL.Timezone.localTimezone;\n      }\n\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Calculate the day of week.\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time.weekDay}\n     */\n    dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;\n\n      if (dowCacheKey in ICAL.Time._dowCache) {\n        return ICAL.Time._dowCache[dowCacheKey];\n      } // Using Zeller's algorithm\n\n\n      var q = this.day;\n      var m = this.month + (this.month < 3 ? 12 : 0);\n      var Y = this.year - (this.month < 3 ? 1 : 0);\n      var h = q + Y + ICAL.helpers.trunc((m + 1) * 26 / 10) + ICAL.helpers.trunc(Y / 4);\n      /* istanbul ignore else */\n\n      if (true\n      /* gregorian */\n      ) {\n        h += ICAL.helpers.trunc(Y / 100) * 6 + ICAL.helpers.trunc(Y / 400);\n      } else {\n        h += 5;\n      } // Normalize to 1 = wkst\n\n\n      h = (h + 7 - firstDow) % 7 + 1;\n      ICAL.Time._dowCache[dowCacheKey] = h;\n      return h;\n    },\n\n    /**\n     * Calculate the day of year.\n     * @return {Number}\n     */\n    dayOfYear: function dayOfYear() {\n      var is_leap = ICAL.Time.isLeapYear(this.year) ? 1 : 0;\n      var diypm = ICAL.Time.daysInYearPassedMonth;\n      return diypm[is_leap][this.month - 1] + this.day;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * week. The resulting ICAL.Time instance is of icaltype date, even if this\n     * is a date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The start of the week (cloned)\n     */\n    startOfWeek: function startOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day -= (this.dayOfWeek() + 7 - firstDow) % 7;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the week.\n     * The resulting ICAL.Time instance is of icaltype date, even if this is a\n     * date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The end of the week (cloned)\n     */\n    endOfWeek: function endOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day += (7 - this.dayOfWeek() + firstDow - ICAL.Time.SUNDAY) % 7;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * month. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the month (cloned)\n     */\n    startOfMonth: function startOfMonth() {\n      var result = this.clone();\n      result.day = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * month.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the month (cloned)\n     */\n    endOfMonth: function endOfMonth() {\n      var result = this.clone();\n      result.day = ICAL.Time.daysInMonth(result.month, result.year);\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * year. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the year (cloned)\n     */\n    startOfYear: function startOfYear() {\n      var result = this.clone();\n      result.day = 1;\n      result.month = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * year.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the year (cloned)\n     */\n    endOfYear: function endOfYear() {\n      var result = this.clone();\n      result.day = 31;\n      result.month = 12;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * First calculates the start of the week, then returns the day of year for\n     * this date. If the day falls into the previous year, the day is zero or negative.\n     *\n     * @param {ICAL.Time.weekDay=} aFirstDayOfWeek\n     *        The week start weekday, defaults to SUNDAY\n     * @return {Number}     The calculated day of year\n     */\n    startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {\n      var firstDow = aFirstDayOfWeek || ICAL.Time.SUNDAY;\n      var delta = this.dayOfWeek() - firstDow;\n      if (delta < 0) delta += 7;\n      return this.dayOfYear() - delta;\n    },\n\n    /**\n     * Get the dominical letter for the current year. Letters range from A - G\n     * for common years, and AG to GF for leap years.\n     *\n     * @param {Number} yr           The year to retrieve the letter for\n     * @return {String}             The dominical letter.\n     */\n    getDominicalLetter: function () {\n      return ICAL.Time.getDominicalLetter(this.year);\n    },\n\n    /**\n     * Finds the nthWeekDay relative to the current month (not day).  The\n     * returned value is a day relative the month that this month belongs to so\n     * 1 would indicate the first of the month and 40 would indicate a day in\n     * the following month.\n     *\n     * @param {Number} aDayOfWeek   Day of the week see the day name constants\n     * @param {Number} aPos         Nth occurrence of a given week day values\n     *        of 1 and 0 both indicate the first weekday of that type. aPos may\n     *        be either positive or negative\n     *\n     * @return {Number} numeric value indicating a day relative\n     *                   to the current month of this time object\n     */\n    nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {\n      var daysInMonth = ICAL.Time.daysInMonth(this.month, this.year);\n      var weekday;\n      var pos = aPos;\n      var start = 0;\n      var otherDay = this.clone();\n\n      if (pos >= 0) {\n        otherDay.day = 1; // because 0 means no position has been given\n        // 1 and 0 indicate the same day.\n\n        if (pos != 0) {\n          // remove the extra numeric value\n          pos--;\n        } // set current start offset to current day.\n\n\n        start = otherDay.day; // find the current day of week\n\n        var startDow = otherDay.dayOfWeek(); // calculate the difference between current\n        // day of the week and desired day of the week\n\n        var offset = aDayOfWeek - startDow; // if the offset goes into the past\n        // week we add 7 so it goes into the next\n        // week. We only want to go forward in time here.\n\n        if (offset < 0) // this is really important otherwise we would\n          // end up with dates from in the past.\n          offset += 7; // add offset to start so start is the same\n        // day of the week as the desired day of week.\n\n        start += offset; // because we are going to add (and multiply)\n        // the numeric value of the day we subtract it\n        // from the start position so not to add it twice.\n\n        start -= aDayOfWeek; // set week day\n\n        weekday = aDayOfWeek;\n      } else {\n        // then we set it to the last day in the current month\n        otherDay.day = daysInMonth; // find the ends weekday\n\n        var endDow = otherDay.dayOfWeek();\n        pos++;\n        weekday = endDow - aDayOfWeek;\n\n        if (weekday < 0) {\n          weekday += 7;\n        }\n\n        weekday = daysInMonth - weekday;\n      }\n\n      weekday += pos * 7;\n      return start + weekday;\n    },\n\n    /**\n     * Checks if current time is the nth weekday, relative to the current\n     * month.  Will always return false when rule resolves outside of current\n     * month.\n     *\n     * @param {ICAL.Time.weekDay} aDayOfWeek       Day of week to check\n     * @param {Number} aPos                        Relative position\n     * @return {Boolean}                           True, if it is the nth weekday\n     */\n    isNthWeekDay: function (aDayOfWeek, aPos) {\n      var dow = this.dayOfWeek();\n\n      if (aPos === 0 && dow === aDayOfWeek) {\n        return true;\n      } // get pos\n\n\n      var day = this.nthWeekDay(aDayOfWeek, aPos);\n\n      if (day === this.day) {\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * Calculates the ISO 8601 week number. The first week of a year is the\n     * week that contains the first Thursday. The year can have 53 weeks, if\n     * January 1st is a Friday.\n     *\n     * Note there are regions where the first week of the year is the one that\n     * starts on January 1st, which may offset the week number. Also, if a\n     * different week start is specified, this will also affect the week\n     * number.\n     *\n     * @see ICAL.Time.weekOneStarts\n     * @param {ICAL.Time.weekDay} aWeekStart        The weekday the week starts with\n     * @return {Number}                             The ISO week number\n     */\n    weekNumber: function weekNumber(aWeekStart) {\n      var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;\n\n      if (wnCacheKey in ICAL.Time._wnCache) {\n        return ICAL.Time._wnCache[wnCacheKey];\n      } // This function courtesty of Julian Bucknall, published under the MIT license\n      // http://www.boyet.com/articles/publishedarticles/calculatingtheisoweeknumb.html\n      // plus some fixes to be able to use different week starts.\n\n\n      var week1;\n      var dt = this.clone();\n      dt.isDate = true;\n      var isoyear = this.year;\n\n      if (dt.month == 12 && dt.day > 25) {\n        week1 = ICAL.Time.weekOneStarts(isoyear + 1, aWeekStart);\n\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n        } else {\n          isoyear++;\n        }\n      } else {\n        week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(--isoyear, aWeekStart);\n        }\n      }\n\n      var daysBetween = dt.subtractDate(week1).toSeconds() / 86400;\n      var answer = ICAL.helpers.trunc(daysBetween / 7) + 1;\n      ICAL.Time._wnCache[wnCacheKey] = answer;\n      return answer;\n    },\n\n    /**\n     * Adds the duration to the current time. The instance is modified in\n     * place.\n     *\n     * @param {ICAL.Duration} aDuration         The duration to add\n     */\n    addDuration: function icaltime_add(aDuration) {\n      var mult = aDuration.isNegative ? -1 : 1; // because of the duration optimizations it is much\n      // more efficient to grab all the values up front\n      // then set them directly (which will avoid a normalization call).\n      // So we don't actually normalize until we need it.\n\n      var second = this.second;\n      var minute = this.minute;\n      var hour = this.hour;\n      var day = this.day;\n      second += mult * aDuration.seconds;\n      minute += mult * aDuration.minutes;\n      hour += mult * aDuration.hours;\n      day += mult * aDuration.days;\n      day += mult * 7 * aDuration.weeks;\n      this.second = second;\n      this.minute = minute;\n      this.hour = hour;\n      this.day = day;\n      this._cachedUnixTime = null;\n    },\n\n    /**\n     * Subtract the date details (_excluding_ timezone).  Useful for finding\n     * the relative difference between two time objects excluding their\n     * timezone differences.\n     *\n     * @param {ICAL.Time} aDate     The date to substract\n     * @return {ICAL.Duration}      The difference as a duration\n     */\n    subtractDate: function icaltime_subtract(aDate) {\n      var unixTime = this.toUnixTime() + this.utcOffset();\n      var other = aDate.toUnixTime() + aDate.utcOffset();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n\n    /**\n     * Subtract the date details, taking timezones into account.\n     *\n     * @param {ICAL.Time} aDate  The date to subtract\n     * @return {ICAL.Duration}  The difference in duration\n     */\n    subtractDateTz: function icaltime_subtract_abs(aDate) {\n      var unixTime = this.toUnixTime();\n      var other = aDate.toUnixTime();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n\n    /**\n     * Compares the ICAL.Time instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toUnixTime();\n      var b = other.toUnixTime();\n      if (a > b) return 1;\n      if (b > a) return -1;\n      return 0;\n    },\n\n    /**\n     * Compares only the date part of this instance with another one.\n     *\n     * @param {ICAL.Duration} other         The instance to compare with\n     * @param {ICAL.Timezone} tz            The timezone to compare in\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {\n      function cmp(attr) {\n        return ICAL.Time._cmp_attr(a, b, attr);\n      }\n\n      var a = this.convertToZone(tz);\n      var b = other.convertToZone(tz);\n      var rc = 0;\n      if ((rc = cmp(\"year\")) != 0) return rc;\n      if ((rc = cmp(\"month\")) != 0) return rc;\n      if ((rc = cmp(\"day\")) != 0) return rc;\n      return rc;\n    },\n\n    /**\n     * Convert the instance into another timezone. The returned ICAL.Time\n     * instance is always a copy.\n     *\n     * @param {ICAL.Timezone} zone      The zone to convert to\n     * @return {ICAL.Time}              The copy, converted to the zone\n     */\n    convertToZone: function convertToZone(zone) {\n      var copy = this.clone();\n      var zone_equals = this.zone.tzid == zone.tzid;\n\n      if (!this.isDate && !zone_equals) {\n        ICAL.Timezone.convert_time(copy, this.zone, zone);\n      }\n\n      copy.zone = zone;\n      return copy;\n    },\n\n    /**\n     * Calculates the UTC offset of the current date/time in the timezone it is\n     * in.\n     *\n     * @return {Number}     UTC offset in seconds\n     */\n    utcOffset: function utc_offset() {\n      if (this.zone == ICAL.Timezone.localTimezone || this.zone == ICAL.Timezone.utcTimezone) {\n        return 0;\n      } else {\n        return this.zone.utcOffset(this);\n      }\n    },\n\n    /**\n     * Returns an RFC 5545 compliant ical representation of this object.\n     *\n     * @return {String} ical date/date-time\n     */\n    toICALString: function () {\n      var string = this.toString();\n\n      if (string.length > 10) {\n        return ICAL.design.icalendar.value['date-time'].toICAL(string);\n      } else {\n        return ICAL.design.icalendar.value.date.toICAL(string);\n      }\n    },\n\n    /**\n     * The string representation of this date/time, in jCal form\n     * (including : and - separators).\n     * @return {String}\n     */\n    toString: function toString() {\n      var result = this.year + '-' + ICAL.helpers.pad2(this.month) + '-' + ICAL.helpers.pad2(this.day);\n\n      if (!this.isDate) {\n        result += 'T' + ICAL.helpers.pad2(this.hour) + ':' + ICAL.helpers.pad2(this.minute) + ':' + ICAL.helpers.pad2(this.second);\n\n        if (this.zone === ICAL.Timezone.utcTimezone) {\n          result += 'Z';\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * Converts the current instance to a Javascript date\n     * @return {Date}\n     */\n    toJSDate: function toJSDate() {\n      if (this.zone == ICAL.Timezone.localTimezone) {\n        if (this.isDate) {\n          return new Date(this.year, this.month - 1, this.day);\n        } else {\n          return new Date(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, 0);\n        }\n      } else {\n        return new Date(this.toUnixTime() * 1000);\n      }\n    },\n    _normalize: function icaltime_normalize() {\n      var isDate = this._time.isDate;\n\n      if (this._time.isDate) {\n        this._time.hour = 0;\n        this._time.minute = 0;\n        this._time.second = 0;\n      }\n\n      this.adjust(0, 0, 0, 0);\n      return this;\n    },\n\n    /**\n     * Adjust the date/time by the given offset\n     *\n     * @param {Number} aExtraDays       The extra amount of days\n     * @param {Number} aExtraHours      The extra amount of hours\n     * @param {Number} aExtraMinutes    The extra amount of minutes\n     * @param {Number} aExtraSeconds    The extra amount of seconds\n     * @param {Number=} aTime           The time to adjust, defaults to the\n     *                                    current instance.\n     */\n    adjust: function icaltime_adjust(aExtraDays, aExtraHours, aExtraMinutes, aExtraSeconds, aTime) {\n      var minutesOverflow,\n          hoursOverflow,\n          daysOverflow = 0,\n          yearsOverflow = 0;\n      var second, minute, hour, day;\n      var daysInMonth;\n      var time = aTime || this._time;\n\n      if (!time.isDate) {\n        second = time.second + aExtraSeconds;\n        time.second = second % 60;\n        minutesOverflow = ICAL.helpers.trunc(second / 60);\n\n        if (time.second < 0) {\n          time.second += 60;\n          minutesOverflow--;\n        }\n\n        minute = time.minute + aExtraMinutes + minutesOverflow;\n        time.minute = minute % 60;\n        hoursOverflow = ICAL.helpers.trunc(minute / 60);\n\n        if (time.minute < 0) {\n          time.minute += 60;\n          hoursOverflow--;\n        }\n\n        hour = time.hour + aExtraHours + hoursOverflow;\n        time.hour = hour % 24;\n        daysOverflow = ICAL.helpers.trunc(hour / 24);\n\n        if (time.hour < 0) {\n          time.hour += 24;\n          daysOverflow--;\n        }\n      } // Adjust month and year first, because we need to know what month the day\n      // is in before adjusting it.\n\n\n      if (time.month > 12) {\n        yearsOverflow = ICAL.helpers.trunc((time.month - 1) / 12);\n      } else if (time.month < 1) {\n        yearsOverflow = ICAL.helpers.trunc(time.month / 12) - 1;\n      }\n\n      time.year += yearsOverflow;\n      time.month -= 12 * yearsOverflow; // Now take care of the days (and adjust month if needed)\n\n      day = time.day + aExtraDays + daysOverflow;\n\n      if (day > 0) {\n        for (;;) {\n          daysInMonth = ICAL.Time.daysInMonth(time.month, time.year);\n\n          if (day <= daysInMonth) {\n            break;\n          }\n\n          time.month++;\n\n          if (time.month > 12) {\n            time.year++;\n            time.month = 1;\n          }\n\n          day -= daysInMonth;\n        }\n      } else {\n        while (day <= 0) {\n          if (time.month == 1) {\n            time.year--;\n            time.month = 12;\n          } else {\n            time.month--;\n          }\n\n          day += ICAL.Time.daysInMonth(time.month, time.year);\n        }\n      }\n\n      time.day = day;\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance from unix time, the number of seconds since\n     * January 1st, 1970.\n     *\n     * @param {Number} seconds      The seconds to set up with\n     */\n    fromUnixTime: function fromUnixTime(seconds) {\n      this.zone = ICAL.Timezone.utcTimezone;\n      var epoch = ICAL.Time.epochTime.clone();\n      epoch.adjust(0, 0, 0, seconds);\n      this.year = epoch.year;\n      this.month = epoch.month;\n      this.day = epoch.day;\n      this.hour = epoch.hour;\n      this.minute = epoch.minute;\n      this.second = Math.floor(epoch.second);\n      this._cachedUnixTime = null;\n    },\n\n    /**\n     * Converts the current instance to seconds since January 1st 1970.\n     *\n     * @return {Number}         Seconds since 1970\n     */\n    toUnixTime: function toUnixTime() {\n      if (this._cachedUnixTime !== null) {\n        return this._cachedUnixTime;\n      }\n\n      var offset = this.utcOffset(); // we use the offset trick to ensure\n      // that we are getting the actual UTC time\n\n      var ms = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second - offset); // seconds\n\n      this._cachedUnixTime = ms / 1000;\n      return this._cachedUnixTime;\n    },\n\n    /**\n     * Converts time to into Object which can be serialized then re-created\n     * using the constructor.\n     *\n     * @example\n     * // toJSON will automatically be called\n     * var json = JSON.stringify(mytime);\n     *\n     * var deserialized = JSON.parse(json);\n     *\n     * var time = new ICAL.Time(deserialized);\n     *\n     * @return {Object}\n     */\n    toJSON: function () {\n      var copy = ['year', 'month', 'day', 'hour', 'minute', 'second', 'isDate'];\n      var result = Object.create(null);\n      var i = 0;\n      var len = copy.length;\n      var prop;\n\n      for (; i < len; i++) {\n        prop = copy[i];\n        result[prop] = this[prop];\n      }\n\n      if (this.zone) {\n        result.timezone = this.zone.tzid;\n      }\n\n      return result;\n    }\n  };\n\n  (function setupNormalizeAttributes() {\n    // This needs to run before any instances are created!\n    function defineAttr(attr) {\n      Object.defineProperty(ICAL.Time.prototype, attr, {\n        get: function getTimeAttr() {\n          if (this._pendingNormalization) {\n            this._normalize();\n\n            this._pendingNormalization = false;\n          }\n\n          return this._time[attr];\n        },\n        set: function setTimeAttr(val) {\n          // Check if isDate will be set and if was not set to normalize date.\n          // This avoids losing days when seconds, minutes and hours are zeroed\n          // what normalize will do when time is a date.\n          if (attr === \"isDate\" && val && !this._time.isDate) {\n            this.adjust(0, 0, 0, 0);\n          }\n\n          this._cachedUnixTime = null;\n          this._pendingNormalization = true;\n          this._time[attr] = val;\n          return val;\n        }\n      });\n    }\n    /* istanbul ignore else */\n\n\n    if (\"defineProperty\" in Object) {\n      defineAttr(\"year\");\n      defineAttr(\"month\");\n      defineAttr(\"day\");\n      defineAttr(\"hour\");\n      defineAttr(\"minute\");\n      defineAttr(\"second\");\n      defineAttr(\"isDate\");\n    }\n  })();\n  /**\n   * Returns the days in the given month\n   *\n   * @param {Number} month      The month to check\n   * @param {Number} year       The year to check\n   * @return {Number}           The number of days in the month\n   */\n\n\n  ICAL.Time.daysInMonth = function icaltime_daysInMonth(month, year) {\n    var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var days = 30;\n    if (month < 1 || month > 12) return days;\n    days = _daysInMonth[month];\n\n    if (month == 2) {\n      days += ICAL.Time.isLeapYear(year);\n    }\n\n    return days;\n  };\n  /**\n   * Checks if the year is a leap year\n   *\n   * @param {Number} year       The year to check\n   * @return {Boolean}          True, if the year is a leap year\n   */\n\n\n  ICAL.Time.isLeapYear = function isLeapYear(year) {\n    if (year <= 1752) {\n      return year % 4 == 0;\n    } else {\n      return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\n    }\n  };\n  /**\n   * Create a new ICAL.Time from the day of year and year. The date is returned\n   * in floating timezone.\n   *\n   * @param {Number} aDayOfYear     The day of year\n   * @param {Number} aYear          The year to create the instance in\n   * @return {ICAL.Time}            The created instance with the calculated date\n   */\n\n\n  ICAL.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {\n    var year = aYear;\n    var doy = aDayOfYear;\n    var tt = new ICAL.Time();\n    tt.auto_normalize = false;\n    var is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;\n\n    if (doy < 1) {\n      year--;\n      is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;\n      doy += ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      return ICAL.Time.fromDayOfYear(doy, year);\n    } else if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][12]) {\n      is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;\n      doy -= ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      year++;\n      return ICAL.Time.fromDayOfYear(doy, year);\n    }\n\n    tt.year = year;\n    tt.isDate = true;\n\n    for (var month = 11; month >= 0; month--) {\n      if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][month]) {\n        tt.month = month + 1;\n        tt.day = doy - ICAL.Time.daysInYearPassedMonth[is_leap][month];\n        break;\n      }\n    }\n\n    tt.auto_normalize = true;\n    return tt;\n  };\n  /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @deprecated                Use {@link ICAL.Time.fromDateString} instead\n   * @param {String} str        The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */\n\n\n  ICAL.Time.fromStringv2 = function fromString(str) {\n    return new ICAL.Time({\n      year: parseInt(str.substr(0, 4), 10),\n      month: parseInt(str.substr(5, 2), 10),\n      day: parseInt(str.substr(8, 2), 10),\n      isDate: true\n    });\n  };\n  /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @param {String} aValue     The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */\n\n\n  ICAL.Time.fromDateString = function (aValue) {\n    // Dates should have no timezone.\n    // Google likes to sometimes specify Z on dates\n    // we specifically ignore that to avoid issues.\n    // YYYY-MM-DD\n    // 2012-10-10\n    return new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      isDate: true\n    });\n  };\n  /**\n   * Returns a new ICAL.Time instance from a date-time string, e.g\n   * 2015-01-02T03:04:05. If a property is specified, the timezone is set up\n   * from the property's TZID parameter.\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */\n\n\n  ICAL.Time.fromDateTimeString = function (aValue, prop) {\n    if (aValue.length < 19) {\n      throw new Error('invalid date-time value: \"' + aValue + '\"');\n    }\n\n    var zone;\n\n    if (aValue[19] && aValue[19] === 'Z') {\n      zone = 'Z';\n    } else if (prop) {\n      zone = prop.getParameter('tzid');\n    } // 2012-10-10T10:10:10(Z)?\n\n\n    var time = new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      hour: ICAL.helpers.strictParseInt(aValue.substr(11, 2)),\n      minute: ICAL.helpers.strictParseInt(aValue.substr(14, 2)),\n      second: ICAL.helpers.strictParseInt(aValue.substr(17, 2)),\n      timezone: zone\n    });\n    return time;\n  };\n  /**\n   * Returns a new ICAL.Time instance from a date or date-time string,\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */\n\n\n  ICAL.Time.fromString = function fromString(aValue, aProperty) {\n    if (aValue.length > 10) {\n      return ICAL.Time.fromDateTimeString(aValue, aProperty);\n    } else {\n      return ICAL.Time.fromDateString(aValue);\n    }\n  };\n  /**\n   * Creates a new ICAL.Time instance from the given Javascript Date.\n   *\n   * @param {?Date} aDate     The Javascript Date to read, or null to reset\n   * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n   */\n\n\n  ICAL.Time.fromJSDate = function fromJSDate(aDate, useUTC) {\n    var tt = new ICAL.Time();\n    return tt.fromJSDate(aDate, useUTC);\n  };\n  /**\n   * Creates a new ICAL.Time instance from the the passed data object.\n   *\n   * @param {Object} aData            Time initialization\n   * @param {Number=} aData.year      The year for this date\n   * @param {Number=} aData.month     The month for this date\n   * @param {Number=} aData.day       The day for this date\n   * @param {Number=} aData.hour      The hour for this date\n   * @param {Number=} aData.minute    The minute for this date\n   * @param {Number=} aData.second    The second for this date\n   * @param {Boolean=} aData.isDate   If true, the instance represents a date\n   *                                    (as opposed to a date-time)\n   * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n   */\n\n\n  ICAL.Time.fromData = function fromData(aData, aZone) {\n    var t = new ICAL.Time();\n    return t.fromData(aData, aZone);\n  };\n  /**\n   * Creates a new ICAL.Time instance from the current moment.\n   * The instance is floating - has no timezone relation.\n   * To create an instance considering the time zone, call\n   * ICAL.Time.fromJSDate(new Date(), true)\n   * @return {ICAL.Time}\n   */\n\n\n  ICAL.Time.now = function icaltime_now() {\n    return ICAL.Time.fromJSDate(new Date(), false);\n  };\n  /**\n   * Returns the date on which ISO week number 1 starts.\n   *\n   * @see ICAL.Time#weekNumber\n   * @param {Number} aYear                  The year to search in\n   * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday, used for calculation.\n   * @return {ICAL.Time}                    The date on which week number 1 starts\n   */\n\n\n  ICAL.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {\n    var t = ICAL.Time.fromData({\n      year: aYear,\n      month: 1,\n      day: 1,\n      isDate: true\n    });\n    var dow = t.dayOfWeek();\n    var wkst = aWeekStart || ICAL.Time.DEFAULT_WEEK_START;\n\n    if (dow > ICAL.Time.THURSDAY) {\n      t.day += 7;\n    }\n\n    if (wkst > ICAL.Time.THURSDAY) {\n      t.day -= 7;\n    }\n\n    t.day -= dow - wkst;\n    return t;\n  };\n  /**\n   * Get the dominical letter for the given year. Letters range from A - G for\n   * common years, and AG to GF for leap years.\n   *\n   * @param {Number} yr           The year to retrieve the letter for\n   * @return {String}             The dominical letter.\n   */\n\n\n  ICAL.Time.getDominicalLetter = function (yr) {\n    var LTRS = \"GFEDCBA\";\n    var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;\n    var isLeap = ICAL.Time.isLeapYear(yr);\n\n    if (isLeap) {\n      return LTRS[(dom + 6) % 7] + LTRS[dom];\n    } else {\n      return LTRS[dom];\n    }\n  };\n  /**\n   * January 1st, 1970 as an ICAL.Time.\n   * @type {ICAL.Time}\n   * @constant\n   * @instance\n   */\n\n\n  ICAL.Time.epochTime = ICAL.Time.fromData({\n    year: 1970,\n    month: 1,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    isDate: false,\n    timezone: \"Z\"\n  });\n\n  ICAL.Time._cmp_attr = function _cmp_attr(a, b, attr) {\n    if (a[attr] > b[attr]) return 1;\n    if (a[attr] < b[attr]) return -1;\n    return 0;\n  };\n  /**\n   * The days that have passed in the year after a given month. The array has\n   * two members, one being an array of passed days for non-leap years, the\n   * other analog for leap years.\n   * @example\n   * var isLeapYear = ICAL.Time.isLeapYear(year);\n   * var passedDays = ICAL.Time.daysInYearPassedMonth[isLeapYear][month];\n   * @type {Array.<Array.<Number>>}\n   */\n\n\n  ICAL.Time.daysInYearPassedMonth = [[0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365], [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]];\n  /**\n   * The weekday, 1 = SUNDAY, 7 = SATURDAY. Access via\n   * ICAL.Time.MONDAY, ICAL.Time.TUESDAY, ...\n   *\n   * @typedef {Number} weekDay\n   * @memberof ICAL.Time\n   */\n\n  ICAL.Time.SUNDAY = 1;\n  ICAL.Time.MONDAY = 2;\n  ICAL.Time.TUESDAY = 3;\n  ICAL.Time.WEDNESDAY = 4;\n  ICAL.Time.THURSDAY = 5;\n  ICAL.Time.FRIDAY = 6;\n  ICAL.Time.SATURDAY = 7;\n  /**\n   * The default weekday for the WKST part.\n   * @constant\n   * @default ICAL.Time.MONDAY\n   */\n\n  ICAL.Time.DEFAULT_WEEK_START = ICAL.Time.MONDAY;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2015 */\n\n\n(function () {\n  /**\n   * Describes a vCard time, which has slight differences to the ICAL.Time.\n   * Properties can be null if not specified, for example for dates with\n   * reduced accuracy or truncation.\n   *\n   * Note that currently not all methods are correctly re-implemented for\n   * VCardTime. For example, comparison will have undefined results when some\n   * members are null.\n   *\n   * Also, normalization is not yet implemented for this class!\n   *\n   * @alias ICAL.VCardTime\n   * @class\n   * @extends {ICAL.Time}\n   * @param {Object} data                           The data for the time instance\n   * @param {Number=} data.year                     The year for this date\n   * @param {Number=} data.month                    The month for this date\n   * @param {Number=} data.day                      The day for this date\n   * @param {Number=} data.hour                     The hour for this date\n   * @param {Number=} data.minute                   The minute for this date\n   * @param {Number=} data.second                   The second for this date\n   * @param {ICAL.Timezone|ICAL.UtcOffset} zone     The timezone to use\n   * @param {String} icaltype                       The type for this date/time object\n   */\n  ICAL.VCardTime = function (data, zone, icaltype) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n    time.year = null;\n    time.month = null;\n    time.day = null;\n    time.hour = null;\n    time.minute = null;\n    time.second = null;\n    this.icaltype = icaltype || \"date-and-or-time\";\n    this.fromData(data, zone);\n  };\n\n  ICAL.helpers.inherits(ICAL.Time, ICAL.VCardTime,\n  /** @lends ICAL.VCardTime */\n  {\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"vcardtime\"\n     */\n    icalclass: \"vcardtime\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @type {String}\n     * @default \"date-and-or-time\"\n     */\n    icaltype: \"date-and-or-time\",\n\n    /**\n     * The timezone. This can either be floating, UTC, or an instance of\n     * ICAL.UtcOffset.\n     * @type {ICAL.Timezone|ICAL.UtcOFfset}\n     */\n    zone: null,\n\n    /**\n     * Returns a clone of the vcard date/time object.\n     *\n     * @return {ICAL.VCardTime}     The cloned object\n     */\n    clone: function () {\n      return new ICAL.VCardTime(this._time, this.zone, this.icaltype);\n    },\n    _normalize: function () {\n      return this;\n    },\n\n    /**\n     * @inheritdoc\n     */\n    utcOffset: function () {\n      if (this.zone instanceof ICAL.UtcOffset) {\n        return this.zone.toSeconds();\n      } else {\n        return ICAL.Time.prototype.utcOffset.apply(this, arguments);\n      }\n    },\n\n    /**\n     * Returns an RFC 6350 compliant representation of this object.\n     *\n     * @return {String}         vcard date/time string\n     */\n    toICALString: function () {\n      return ICAL.design.vcard.value[this.icaltype].toICAL(this.toString());\n    },\n\n    /**\n     * The string representation of this date/time, in jCard form\n     * (including : and - separators).\n     * @return {String}\n     */\n    toString: function toString() {\n      var p2 = ICAL.helpers.pad2;\n      var y = this.year,\n          m = this.month,\n          d = this.day;\n      var h = this.hour,\n          mm = this.minute,\n          s = this.second;\n      var hasYear = y !== null,\n          hasMonth = m !== null,\n          hasDay = d !== null;\n      var hasHour = h !== null,\n          hasMinute = mm !== null,\n          hasSecond = s !== null;\n      var datepart = (hasYear ? p2(y) + (hasMonth || hasDay ? '-' : '') : hasMonth || hasDay ? '--' : '') + (hasMonth ? p2(m) : '') + (hasDay ? '-' + p2(d) : '');\n      var timepart = (hasHour ? p2(h) : '-') + (hasHour && hasMinute ? ':' : '') + (hasMinute ? p2(mm) : '') + (!hasHour && !hasMinute ? '-' : '') + (hasMinute && hasSecond ? ':' : '') + (hasSecond ? p2(s) : '');\n      var zone;\n\n      if (this.zone === ICAL.Timezone.utcTimezone) {\n        zone = 'Z';\n      } else if (this.zone instanceof ICAL.UtcOffset) {\n        zone = this.zone.toString();\n      } else if (this.zone === ICAL.Timezone.localTimezone) {\n        zone = '';\n      } else if (this.zone instanceof ICAL.Timezone) {\n        var offset = ICAL.UtcOffset.fromSeconds(this.zone.utcOffset(this));\n        zone = offset.toString();\n      } else {\n        zone = '';\n      }\n\n      switch (this.icaltype) {\n        case \"time\":\n          return timepart + zone;\n\n        case \"date-and-or-time\":\n        case \"date-time\":\n          return datepart + (timepart == '--' ? '' : 'T' + timepart + zone);\n\n        case \"date\":\n          return datepart;\n      }\n\n      return null;\n    }\n  });\n  /**\n   * Returns a new ICAL.VCardTime instance from a date and/or time string.\n   *\n   * @param {String} aValue     The string to create from\n   * @param {String} aIcalType  The type for this instance, e.g. date-and-or-time\n   * @return {ICAL.VCardTime}   The date/time instance\n   */\n\n  ICAL.VCardTime.fromDateAndOrTimeString = function (aValue, aIcalType) {\n    function part(v, s, e) {\n      return v ? ICAL.helpers.strictParseInt(v.substr(s, e)) : null;\n    }\n\n    var parts = aValue.split('T');\n    var dt = parts[0],\n        tmz = parts[1];\n    var splitzone = tmz ? ICAL.design.vcard.value.time._splitZone(tmz) : [];\n    var zone = splitzone[0],\n        tm = splitzone[1];\n    var stoi = ICAL.helpers.strictParseInt;\n    var dtlen = dt ? dt.length : 0;\n    var tmlen = tm ? tm.length : 0;\n    var hasDashDate = dt && dt[0] == '-' && dt[1] == '-';\n    var hasDashTime = tm && tm[0] == '-';\n    var o = {\n      year: hasDashDate ? null : part(dt, 0, 4),\n      month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,\n      day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,\n      hour: hasDashTime ? null : part(tm, 0, 2),\n      minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,\n      second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null\n    };\n\n    if (zone == 'Z') {\n      zone = ICAL.Timezone.utcTimezone;\n    } else if (zone && zone[3] == ':') {\n      zone = ICAL.UtcOffset.fromString(zone);\n    } else {\n      zone = null;\n    }\n\n    return new ICAL.VCardTime(o, zone, aIcalType);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n(function () {\n  var DOW_MAP = {\n    SU: ICAL.Time.SUNDAY,\n    MO: ICAL.Time.MONDAY,\n    TU: ICAL.Time.TUESDAY,\n    WE: ICAL.Time.WEDNESDAY,\n    TH: ICAL.Time.THURSDAY,\n    FR: ICAL.Time.FRIDAY,\n    SA: ICAL.Time.SATURDAY\n  };\n  var REVERSE_DOW_MAP = {};\n\n  for (var key in DOW_MAP) {\n    /* istanbul ignore else */\n    if (DOW_MAP.hasOwnProperty(key)) {\n      REVERSE_DOW_MAP[DOW_MAP[key]] = key;\n    }\n  }\n\n  var COPY_PARTS = [\"BYSECOND\", \"BYMINUTE\", \"BYHOUR\", \"BYDAY\", \"BYMONTHDAY\", \"BYYEARDAY\", \"BYWEEKNO\", \"BYMONTH\", \"BYSETPOS\"];\n  /**\n   * @classdesc\n   * This class represents the \"recur\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Recur\n   * @param {Object} data                               An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n   * @param {Number=} data.interval                     The INTERVAL value\n   * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n   * @param {ICAL.Time=} data.until                     The end of the recurrence set\n   * @param {Number=} data.count                        The number of occurrences\n   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n   * @param {Array.<String>=} data.byday                The BYDAY values\n   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n   */\n\n  ICAL.Recur = function icalrecur(data) {\n    this.wrappedJSObject = this;\n    this.parts = {};\n\n    if (data && typeof data === 'object') {\n      this.fromData(data);\n    }\n  };\n\n  ICAL.Recur.prototype = {\n    /**\n     * An object holding the BY-parts of the recurrence rule\n     * @type {Object}\n     */\n    parts: null,\n\n    /**\n     * The interval value for the recurrence rule.\n     * @type {Number}\n     */\n    interval: 1,\n\n    /**\n     * The week start day\n     *\n     * @type {ICAL.Time.weekDay}\n     * @default ICAL.Time.MONDAY\n     */\n    wkst: ICAL.Time.MONDAY,\n\n    /**\n     * The end of the recurrence\n     * @type {?ICAL.Time}\n     */\n    until: null,\n\n    /**\n     * The maximum number of occurrences\n     * @type {?Number}\n     */\n    count: null,\n\n    /**\n     * The frequency value.\n     * @type {ICAL.Recur.frequencyValues}\n     */\n    freq: null,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalrecur\"\n     */\n    icalclass: \"icalrecur\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"recur\"\n     */\n    icaltype: \"recur\",\n\n    /**\n     * Create a new iterator for this recurrence rule. The passed start date\n     * must be the start date of the event, not the start of the range to\n     * search in.\n     *\n     * @example\n     * var recur = comp.getFirstPropertyValue('rrule');\n     * var dtstart = comp.getFirstPropertyValue('dtstart');\n     * var iter = recur.iterator(dtstart);\n     * for (var next = iter.next(); next; next = iter.next()) {\n     *   if (next.compare(rangeStart) < 0) {\n     *     continue;\n     *   }\n     *   console.log(next.toString());\n     * }\n     *\n     * @param {ICAL.Time} aStart        The item's start date\n     * @return {ICAL.RecurIterator}     The recurrence iterator\n     */\n    iterator: function (aStart) {\n      return new ICAL.RecurIterator({\n        rule: this,\n        dtstart: aStart\n      });\n    },\n\n    /**\n     * Returns a clone of the recurrence object.\n     *\n     * @return {ICAL.Recur}      The cloned object\n     */\n    clone: function clone() {\n      return new ICAL.Recur(this.toJSON());\n    },\n\n    /**\n     * Checks if the current rule is finite, i.e. has a count or until part.\n     *\n     * @return {Boolean}        True, if the rule is finite\n     */\n    isFinite: function isfinite() {\n      return !!(this.count || this.until);\n    },\n\n    /**\n     * Checks if the current rule has a count part, and not limited by an until\n     * part.\n     *\n     * @return {Boolean}        True, if the rule is by count\n     */\n    isByCount: function isbycount() {\n      return !!(this.count && !this.until);\n    },\n\n    /**\n     * Adds a component (part) to the recurrence rule. This is not a component\n     * in the sense of {@link ICAL.Component}, but a part of the recurrence\n     * rule, i.e. BYMONTH.\n     *\n     * @param {String} aType            The name of the component part\n     * @param {Array|String} aValue     The component value\n     */\n    addComponent: function addPart(aType, aValue) {\n      var ucname = aType.toUpperCase();\n\n      if (ucname in this.parts) {\n        this.parts[ucname].push(aValue);\n      } else {\n        this.parts[ucname] = [aValue];\n      }\n    },\n\n    /**\n     * Sets the component value for the given by-part.\n     *\n     * @param {String} aType        The component part name\n     * @param {Array} aValues       The component values\n     */\n    setComponent: function setComponent(aType, aValues) {\n      this.parts[aType.toUpperCase()] = aValues.slice();\n    },\n\n    /**\n     * Gets (a copy) of the requested component value.\n     *\n     * @param {String} aType        The component part name\n     * @return {Array}              The component part value\n     */\n    getComponent: function getComponent(aType) {\n      var ucname = aType.toUpperCase();\n      return ucname in this.parts ? this.parts[ucname].slice() : [];\n    },\n\n    /**\n     * Retrieves the next occurrence after the given recurrence id. See the\n     * guide on {@tutorial terminology} for more details.\n     *\n     * NOTE: Currently, this method iterates all occurrences from the start\n     * date. It should not be called in a loop for performance reasons. If you\n     * would like to get more than one occurrence, you can iterate the\n     * occurrences manually, see the example on the\n     * {@link ICAL.Recur#iterator iterator} method.\n     *\n     * @param {ICAL.Time} aStartTime        The start of the event series\n     * @param {ICAL.Time} aRecurrenceId     The date of the last occurrence\n     * @return {ICAL.Time}                  The next occurrence after\n     */\n    getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {\n      var iter = this.iterator(aStartTime);\n      var next, cdt;\n\n      do {\n        next = iter.next();\n      } while (next && next.compare(aRecurrenceId) <= 0);\n\n      if (next && aRecurrenceId.zone) {\n        next.zone = aRecurrenceId.zone;\n      }\n\n      return next;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} data                               An object with members of the recurrence\n     * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n     * @param {Number=} data.interval                     The INTERVAL value\n     * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n     * @param {ICAL.Time=} data.until                     The end of the recurrence set\n     * @param {Number=} data.count                        The number of occurrences\n     * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n     * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n     * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n     * @param {Array.<String>=} data.byday                The BYDAY values\n     * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n     * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n     * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n     * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n     * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n     */\n    fromData: function (data) {\n      for (var key in data) {\n        var uckey = key.toUpperCase();\n\n        if (uckey in partDesign) {\n          if (Array.isArray(data[key])) {\n            this.parts[uckey] = data[key];\n          } else {\n            this.parts[uckey] = [data[key]];\n          }\n        } else {\n          this[key] = data[key];\n        }\n      }\n\n      if (this.interval && typeof this.interval != \"number\") {\n        optionDesign.INTERVAL(this.interval, this);\n      }\n\n      if (this.wkst && typeof this.wkst != \"number\") {\n        this.wkst = ICAL.Recur.icalDayToNumericDay(this.wkst);\n      }\n\n      if (this.until && !(this.until instanceof ICAL.Time)) {\n        this.until = ICAL.Time.fromString(this.until);\n      }\n    },\n\n    /**\n     * The jCal representation of this recurrence type.\n     * @return {Object}\n     */\n    toJSON: function () {\n      var res = Object.create(null);\n      res.freq = this.freq;\n\n      if (this.count) {\n        res.count = this.count;\n      }\n\n      if (this.interval > 1) {\n        res.interval = this.interval;\n      }\n\n      for (var k in this.parts) {\n        /* istanbul ignore if */\n        if (!this.parts.hasOwnProperty(k)) {\n          continue;\n        }\n\n        var kparts = this.parts[k];\n\n        if (Array.isArray(kparts) && kparts.length == 1) {\n          res[k.toLowerCase()] = kparts[0];\n        } else {\n          res[k.toLowerCase()] = ICAL.helpers.clone(this.parts[k]);\n        }\n      }\n\n      if (this.until) {\n        res.until = this.until.toString();\n      }\n\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        res.wkst = ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n\n      return res;\n    },\n\n    /**\n     * The string representation of this recurrence rule.\n     * @return {String}\n     */\n    toString: function icalrecur_toString() {\n      // TODO retain order\n      var str = \"FREQ=\" + this.freq;\n\n      if (this.count) {\n        str += \";COUNT=\" + this.count;\n      }\n\n      if (this.interval > 1) {\n        str += \";INTERVAL=\" + this.interval;\n      }\n\n      for (var k in this.parts) {\n        /* istanbul ignore else */\n        if (this.parts.hasOwnProperty(k)) {\n          str += \";\" + k + \"=\" + this.parts[k];\n        }\n      }\n\n      if (this.until) {\n        str += ';UNTIL=' + this.until.toICALString();\n      }\n\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        str += ';WKST=' + ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n\n      return str;\n    }\n  };\n\n  function parseNumericValue(type, min, max, value) {\n    var result = value;\n\n    if (value[0] === '+') {\n      result = value.substr(1);\n    }\n\n    result = ICAL.helpers.strictParseInt(result);\n\n    if (min !== undefined && value < min) {\n      throw new Error(type + ': invalid value \"' + value + '\" must be > ' + min);\n    }\n\n    if (max !== undefined && value > max) {\n      throw new Error(type + ': invalid value \"' + value + '\" must be < ' + min);\n    }\n\n    return result;\n  }\n  /**\n   * Convert an ical representation of a day (SU, MO, etc..)\n   * into a numeric value of that day.\n   *\n   * @param {String} string     The iCalendar day name\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {Number}           Numeric value of given day\n   */\n\n\n  ICAL.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {\n    //XXX: this is here so we can deal\n    //     with possibly invalid string values.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    return (DOW_MAP[string] - firstDow + 7) % 7 + 1;\n  };\n  /**\n   * Convert a numeric day value into its ical representation (SU, MO, etc..)\n   *\n   * @param {Number} num        Numeric value of given day\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {String}           The ICAL day value, e.g SU,MO,...\n   */\n\n\n  ICAL.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {\n    //XXX: this is here so we can deal with possibly invalid number values.\n    //     Also, this allows consistent mapping between day numbers and day\n    //     names for external users.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    var dow = num + firstDow - ICAL.Time.SUNDAY;\n\n    if (dow > 7) {\n      dow -= 7;\n    }\n\n    return REVERSE_DOW_MAP[dow];\n  };\n\n  var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;\n  var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;\n  /**\n   * Possible frequency values for the FREQ part\n   * (YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY)\n   *\n   * @typedef {String} frequencyValues\n   * @memberof ICAL.Recur\n   */\n\n  var ALLOWED_FREQ = ['SECONDLY', 'MINUTELY', 'HOURLY', 'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'];\n  var optionDesign = {\n    FREQ: function (value, dict, fmtIcal) {\n      // yes this is actually equal or faster then regex.\n      // upside here is we can enumerate the valid values.\n      if (ALLOWED_FREQ.indexOf(value) !== -1) {\n        dict.freq = value;\n      } else {\n        throw new Error('invalid frequency \"' + value + '\" expected: \"' + ALLOWED_FREQ.join(', ') + '\"');\n      }\n    },\n    COUNT: function (value, dict, fmtIcal) {\n      dict.count = ICAL.helpers.strictParseInt(value);\n    },\n    INTERVAL: function (value, dict, fmtIcal) {\n      dict.interval = ICAL.helpers.strictParseInt(value);\n\n      if (dict.interval < 1) {\n        // 0 or negative values are not allowed, some engines seem to generate\n        // it though. Assume 1 instead.\n        dict.interval = 1;\n      }\n    },\n    UNTIL: function (value, dict, fmtIcal) {\n      if (value.length > 10) {\n        dict.until = ICAL.design.icalendar.value['date-time'].fromICAL(value);\n      } else {\n        dict.until = ICAL.design.icalendar.value.date.fromICAL(value);\n      }\n\n      if (!fmtIcal) {\n        dict.until = ICAL.Time.fromString(dict.until);\n      }\n    },\n    WKST: function (value, dict, fmtIcal) {\n      if (VALID_DAY_NAMES.test(value)) {\n        dict.wkst = ICAL.Recur.icalDayToNumericDay(value);\n      } else {\n        throw new Error('invalid WKST value \"' + value + '\"');\n      }\n    }\n  };\n  var partDesign = {\n    BYSECOND: parseNumericValue.bind(this, 'BYSECOND', 0, 60),\n    BYMINUTE: parseNumericValue.bind(this, 'BYMINUTE', 0, 59),\n    BYHOUR: parseNumericValue.bind(this, 'BYHOUR', 0, 23),\n    BYDAY: function (value) {\n      if (VALID_BYDAY_PART.test(value)) {\n        return value;\n      } else {\n        throw new Error('invalid BYDAY value \"' + value + '\"');\n      }\n    },\n    BYMONTHDAY: parseNumericValue.bind(this, 'BYMONTHDAY', -31, 31),\n    BYYEARDAY: parseNumericValue.bind(this, 'BYYEARDAY', -366, 366),\n    BYWEEKNO: parseNumericValue.bind(this, 'BYWEEKNO', -53, 53),\n    BYMONTH: parseNumericValue.bind(this, 'BYMONTH', 1, 12),\n    BYSETPOS: parseNumericValue.bind(this, 'BYSETPOS', -366, 366)\n  };\n  /**\n   * Creates a new {@link ICAL.Recur} instance from the passed string.\n   *\n   * @param {String} string         The string to parse\n   * @return {ICAL.Recur}           The created recurrence instance\n   */\n\n  ICAL.Recur.fromString = function (string) {\n    var data = ICAL.Recur._stringToData(string, false);\n\n    return new ICAL.Recur(data);\n  };\n  /**\n   * Creates a new {@link ICAL.Recur} instance using members from the passed\n   * data object.\n   *\n   * @param {Object} aData                              An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} aData.freq    The frequency value\n   * @param {Number=} aData.interval                    The INTERVAL value\n   * @param {ICAL.Time.weekDay=} aData.wkst             The week start value\n   * @param {ICAL.Time=} aData.until                    The end of the recurrence set\n   * @param {Number=} aData.count                       The number of occurrences\n   * @param {Array.<Number>=} aData.bysecond            The seconds for the BYSECOND part\n   * @param {Array.<Number>=} aData.byminute            The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} aData.byhour              The hours for the BYHOUR part\n   * @param {Array.<String>=} aData.byday               The BYDAY values\n   * @param {Array.<Number>=} aData.bymonthday          The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} aData.byyearday           The days for the BYYEARDAY part\n   * @param {Array.<Number>=} aData.byweekno            The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} aData.bymonth             The month for the BYMONTH part\n   * @param {Array.<Number>=} aData.bysetpos            The positionals for the BYSETPOS part\n   */\n\n\n  ICAL.Recur.fromData = function (aData) {\n    return new ICAL.Recur(aData);\n  };\n  /**\n   * Converts a recurrence string to a data object, suitable for the fromData\n   * method.\n   *\n   * @param {String} string     The string to parse\n   * @param {Boolean} fmtIcal   If true, the string is considered to be an\n   *                              iCalendar string\n   * @return {ICAL.Recur}       The recurrence instance\n   */\n\n\n  ICAL.Recur._stringToData = function (string, fmtIcal) {\n    var dict = Object.create(null); // split is slower in FF but fast enough.\n    // v8 however this is faster then manual split?\n\n    var values = string.split(';');\n    var len = values.length;\n\n    for (var i = 0; i < len; i++) {\n      var parts = values[i].split('=');\n      var ucname = parts[0].toUpperCase();\n      var lcname = parts[0].toLowerCase();\n      var name = fmtIcal ? lcname : ucname;\n      var value = parts[1];\n\n      if (ucname in partDesign) {\n        var partArr = value.split(',');\n        var partArrIdx = 0;\n        var partArrLen = partArr.length;\n\n        for (; partArrIdx < partArrLen; partArrIdx++) {\n          partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);\n        }\n\n        dict[name] = partArr.length == 1 ? partArr[0] : partArr;\n      } else if (ucname in optionDesign) {\n        optionDesign[ucname](value, dict, fmtIcal);\n      } else {\n        // Don't swallow unknown values. Just set them as they are.\n        dict[lcname] = value;\n      }\n    }\n\n    return dict;\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.RecurIterator = function () {\n  /**\n   * @classdesc\n   * An iterator for a single recurrence rule. This class usually doesn't have\n   * to be instanciated directly, the convenience method\n   * {@link ICAL.Recur#iterator} can be used.\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration from a previous run\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration\n   * from a previous run.\n   *\n   * @class\n   * @alias ICAL.RecurIterator\n   * @param {Object} options                The iterator options\n   * @param {ICAL.Recur} options.rule       The rule to iterate.\n   * @param {ICAL.Time} options.dtstart     The start date of the event.\n   * @param {Boolean=} options.initialized  When true, assume that options are\n   *        from a previously constructed iterator. Initialization will not be\n   *        repeated.\n   */\n  function icalrecur_iterator(options) {\n    this.fromData(options);\n  }\n\n  icalrecur_iterator.prototype = {\n    /**\n     * True when iteration is finished.\n     * @type {Boolean}\n     */\n    completed: false,\n\n    /**\n     * The rule that is being iterated\n     * @type {ICAL.Recur}\n     */\n    rule: null,\n\n    /**\n     * The start date of the event being iterated.\n     * @type {ICAL.Time}\n     */\n    dtstart: null,\n\n    /**\n     * The last occurrence that was returned from the\n     * {@link ICAL.RecurIterator#next} method.\n     * @type {ICAL.Time}\n     */\n    last: null,\n\n    /**\n     * The sequence number from the occurrence\n     * @type {Number}\n     */\n    occurrence_number: 0,\n\n    /**\n     * The indices used for the {@link ICAL.RecurIterator#by_data} object.\n     * @type {Object}\n     * @private\n     */\n    by_indices: null,\n\n    /**\n     * If true, the iterator has already been initialized\n     * @type {Boolean}\n     * @private\n     */\n    initialized: false,\n\n    /**\n     * The initializd by-data.\n     * @type {Object}\n     * @private\n     */\n    by_data: null,\n\n    /**\n     * The expanded yeardays\n     * @type {Array}\n     * @private\n     */\n    days: null,\n\n    /**\n     * The index in the {@link ICAL.RecurIterator#days} array.\n     * @type {Number}\n     * @private\n     */\n    days_index: 0,\n\n    /**\n     * Initialize the recurrence iterator from the passed data object. This\n     * method is usually not called directly, you can initialize the iterator\n     * through the constructor.\n     *\n     * @param {Object} options                The iterator options\n     * @param {ICAL.Recur} options.rule       The rule to iterate.\n     * @param {ICAL.Time} options.dtstart     The start date of the event.\n     * @param {Boolean=} options.initialized  When true, assume that options are\n     *        from a previously constructed iterator. Initialization will not be\n     *        repeated.\n     */\n    fromData: function (options) {\n      this.rule = ICAL.helpers.formatClassType(options.rule, ICAL.Recur);\n\n      if (!this.rule) {\n        throw new Error('iterator requires a (ICAL.Recur) rule');\n      }\n\n      this.dtstart = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n\n      if (!this.dtstart) {\n        throw new Error('iterator requires a (ICAL.Time) dtstart');\n      }\n\n      if (options.by_data) {\n        this.by_data = options.by_data;\n      } else {\n        this.by_data = ICAL.helpers.clone(this.rule.parts, true);\n      }\n\n      if (options.occurrence_number) this.occurrence_number = options.occurrence_number;\n      this.days = options.days || [];\n\n      if (options.last) {\n        this.last = ICAL.helpers.formatClassType(options.last, ICAL.Time);\n      }\n\n      this.by_indices = options.by_indices;\n\n      if (!this.by_indices) {\n        this.by_indices = {\n          \"BYSECOND\": 0,\n          \"BYMINUTE\": 0,\n          \"BYHOUR\": 0,\n          \"BYDAY\": 0,\n          \"BYMONTH\": 0,\n          \"BYWEEKNO\": 0,\n          \"BYMONTHDAY\": 0\n        };\n      }\n\n      this.initialized = options.initialized || false;\n\n      if (!this.initialized) {\n        this.init();\n      }\n    },\n\n    /**\n     * Intialize the iterator\n     * @private\n     */\n    init: function icalrecur_iterator_init() {\n      this.initialized = true;\n      this.last = this.dtstart.clone();\n      var parts = this.by_data;\n\n      if (\"BYDAY\" in parts) {\n        // libical does this earlier when the rule is loaded, but we postpone to\n        // now so we can preserve the original order.\n        this.sort_byday_rules(parts.BYDAY);\n      } // If the BYYEARDAY appares, no other date rule part may appear\n\n\n      if (\"BYYEARDAY\" in parts) {\n        if (\"BYMONTH\" in parts || \"BYWEEKNO\" in parts || \"BYMONTHDAY\" in parts || \"BYDAY\" in parts) {\n          throw new Error(\"Invalid BYYEARDAY rule\");\n        }\n      } // BYWEEKNO and BYMONTHDAY rule parts may not both appear\n\n\n      if (\"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {\n        throw new Error(\"BYWEEKNO does not fit to BYMONTHDAY\");\n      } // For MONTHLY recurrences (FREQ=MONTHLY) neither BYYEARDAY nor\n      // BYWEEKNO may appear.\n\n\n      if (this.rule.freq == \"MONTHLY\" && (\"BYYEARDAY\" in parts || \"BYWEEKNO\" in parts)) {\n        throw new Error(\"For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear\");\n      } // For WEEKLY recurrences (FREQ=WEEKLY) neither BYMONTHDAY nor\n      // BYYEARDAY may appear.\n\n\n      if (this.rule.freq == \"WEEKLY\" && (\"BYYEARDAY\" in parts || \"BYMONTHDAY\" in parts)) {\n        throw new Error(\"For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear\");\n      } // BYYEARDAY may only appear in YEARLY rules\n\n\n      if (this.rule.freq != \"YEARLY\" && \"BYYEARDAY\" in parts) {\n        throw new Error(\"BYYEARDAY may only appear in YEARLY rules\");\n      }\n\n      this.last.second = this.setup_defaults(\"BYSECOND\", \"SECONDLY\", this.dtstart.second);\n      this.last.minute = this.setup_defaults(\"BYMINUTE\", \"MINUTELY\", this.dtstart.minute);\n      this.last.hour = this.setup_defaults(\"BYHOUR\", \"HOURLY\", this.dtstart.hour);\n      this.last.day = this.setup_defaults(\"BYMONTHDAY\", \"DAILY\", this.dtstart.day);\n      this.last.month = this.setup_defaults(\"BYMONTH\", \"MONTHLY\", this.dtstart.month);\n\n      if (this.rule.freq == \"WEEKLY\") {\n        if (\"BYDAY\" in parts) {\n          var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);\n\n          if (this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0 || wkdy < 0) {\n            // Initial time is after first day of BYDAY data\n            this.last.day += wkdy;\n          }\n        } else {\n          var dayName = ICAL.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());\n          parts.BYDAY = [dayName];\n        }\n      }\n\n      if (this.rule.freq == \"YEARLY\") {\n        for (;;) {\n          this.expand_year_days(this.last.year);\n\n          if (this.days.length > 0) {\n            break;\n          }\n\n          this.increment_year(this.rule.interval);\n        }\n\n        this._nextByYearDay();\n      }\n\n      if (this.rule.freq == \"MONTHLY\" && this.has_by_data(\"BYDAY\")) {\n        var tempLast = null;\n        var initLast = this.last.clone();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year); // Check every weekday in BYDAY with relative dow and pos.\n\n        for (var i in this.by_data.BYDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYDAY.hasOwnProperty(i)) {\n            continue;\n          }\n\n          this.last = initLast.clone();\n          var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i]);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var dayOfMonth = this.last.nthWeekDay(dow, pos); // If |pos| >= 6, the byday is invalid for a monthly rule.\n\n          if (pos >= 6 || pos <= -6) {\n            throw new Error(\"Malformed values in BYDAY part\");\n          } // If a Byday with pos=+/-5 is not in the current month it\n          // must be searched in the next months.\n\n\n          if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n            // Skip if we have already found a \"last\" in this month.\n            if (tempLast && tempLast.month == initLast.month) {\n              continue;\n            }\n\n            while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n              this.increment_month();\n              daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n              dayOfMonth = this.last.nthWeekDay(dow, pos);\n            }\n          }\n\n          this.last.day = dayOfMonth;\n\n          if (!tempLast || this.last.compare(tempLast) < 0) {\n            tempLast = this.last.clone();\n          }\n        }\n\n        this.last = tempLast.clone(); //XXX: This feels like a hack, but we need to initialize\n        //     the BYMONTHDAY case correctly and byDayAndMonthDay handles\n        //     this case. It accepts a special flag which will avoid incrementing\n        //     the initial value without the flag days that match the start time\n        //     would be missed.\n\n        if (this.has_by_data('BYMONTHDAY')) {\n          this._byDayAndMonthDay(true);\n        }\n\n        if (this.last.day > daysInMonth || this.last.day == 0) {\n          throw new Error(\"Malformed values in BYDAY part\");\n        }\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        if (this.last.day < 0) {\n          var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n          this.last.day = daysInMonth + this.last.day + 1;\n        }\n      }\n    },\n\n    /**\n     * Retrieve the next occurrence from the iterator.\n     * @return {ICAL.Time}\n     */\n    next: function icalrecur_iterator_next() {\n      var before = this.last ? this.last.clone() : null;\n\n      if (this.rule.count && this.occurrence_number >= this.rule.count || this.rule.until && this.last.compare(this.rule.until) > 0) {\n        //XXX: right now this is just a flag and has no impact\n        //     we can simplify the above case to check for completed later.\n        this.completed = true;\n        return null;\n      }\n\n      if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {\n        // First of all, give the instance that was initialized\n        this.occurrence_number++;\n        return this.last;\n      }\n\n      var valid;\n\n      do {\n        valid = 1;\n\n        switch (this.rule.freq) {\n          case \"SECONDLY\":\n            this.next_second();\n            break;\n\n          case \"MINUTELY\":\n            this.next_minute();\n            break;\n\n          case \"HOURLY\":\n            this.next_hour();\n            break;\n\n          case \"DAILY\":\n            this.next_day();\n            break;\n\n          case \"WEEKLY\":\n            this.next_week();\n            break;\n\n          case \"MONTHLY\":\n            valid = this.next_month();\n            break;\n\n          case \"YEARLY\":\n            this.next_year();\n            break;\n\n          default:\n            return null;\n        }\n      } while (!this.check_contracting_rules() || this.last.compare(this.dtstart) < 0 || !valid); // TODO is this valid?\n\n\n      if (this.last.compare(before) == 0) {\n        throw new Error(\"Same occurrence found twice, protecting \" + \"you from death by recursion\");\n      }\n\n      if (this.rule.until && this.last.compare(this.rule.until) > 0) {\n        this.completed = true;\n        return null;\n      } else {\n        this.occurrence_number++;\n        return this.last;\n      }\n    },\n    next_second: function next_second() {\n      return this.next_generic(\"BYSECOND\", \"SECONDLY\", \"second\", \"minute\");\n    },\n    increment_second: function increment_second(inc) {\n      return this.increment_generic(inc, \"second\", 60, \"minute\");\n    },\n    next_minute: function next_minute() {\n      return this.next_generic(\"BYMINUTE\", \"MINUTELY\", \"minute\", \"hour\", \"next_second\");\n    },\n    increment_minute: function increment_minute(inc) {\n      return this.increment_generic(inc, \"minute\", 60, \"hour\");\n    },\n    next_hour: function next_hour() {\n      return this.next_generic(\"BYHOUR\", \"HOURLY\", \"hour\", \"monthday\", \"next_minute\");\n    },\n    increment_hour: function increment_hour(inc) {\n      this.increment_generic(inc, \"hour\", 24, \"monthday\");\n    },\n    next_day: function next_day() {\n      var has_by_day = (\"BYDAY\" in this.by_data);\n      var this_freq = this.rule.freq == \"DAILY\";\n\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n\n      if (this_freq) {\n        this.increment_monthday(this.rule.interval);\n      } else {\n        this.increment_monthday(1);\n      }\n\n      return 0;\n    },\n    next_week: function next_week() {\n      var end_of_data = 0;\n\n      if (this.next_weekday_by_week() == 0) {\n        return end_of_data;\n      }\n\n      if (this.has_by_data(\"BYWEEKNO\")) {\n        var idx = ++this.by_indices.BYWEEKNO;\n\n        if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {\n          this.by_indices.BYWEEKNO = 0;\n          end_of_data = 1;\n        } // HACK should be first month of the year\n\n\n        this.last.month = 1;\n        this.last.day = 1;\n        var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];\n        this.last.day += 7 * week_no;\n\n        if (end_of_data) {\n          this.increment_year(1);\n        }\n      } else {\n        // Jump to the next week\n        this.increment_monthday(7 * this.rule.interval);\n      }\n\n      return end_of_data;\n    },\n\n    /**\n     * Normalize each by day rule for a given year/month.\n     * Takes into account ordering and negative rules\n     *\n     * @private\n     * @param {Number} year         Current year.\n     * @param {Number} month        Current month.\n     * @param {Array}  rules        Array of rules.\n     *\n     * @return {Array} sorted and normalized rules.\n     *                 Negative rules will be expanded to their\n     *                 correct positive values for easier processing.\n     */\n    normalizeByMonthDayRules: function (year, month, rules) {\n      var daysInMonth = ICAL.Time.daysInMonth(month, year); // XXX: This is probably bad for performance to allocate\n      //      a new array for each month we scan, if possible\n      //      we should try to optimize this...\n\n      var newRules = [];\n      var ruleIdx = 0;\n      var len = rules.length;\n      var rule;\n\n      for (; ruleIdx < len; ruleIdx++) {\n        rule = rules[ruleIdx]; // if this rule falls outside of given\n        // month discard it.\n\n        if (Math.abs(rule) > daysInMonth) {\n          continue;\n        } // negative case\n\n\n        if (rule < 0) {\n          // we add (not subtract it is a negative number)\n          // one from the rule because 1 === last day of month\n          rule = daysInMonth + (rule + 1);\n        } else if (rule === 0) {\n          // skip zero: it is invalid.\n          continue;\n        } // only add unique items...\n\n\n        if (newRules.indexOf(rule) === -1) {\n          newRules.push(rule);\n        }\n      } // unique and sort\n\n\n      return newRules.sort(function (a, b) {\n        return a - b;\n      });\n    },\n\n    /**\n     * NOTES:\n     * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)\n     * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when\n     * both conditions match a given date (this.last.day) iteration stops.\n     *\n     * @private\n     * @param {Boolean=} isInit     When given true will not increment the\n     *                                current day (this.last).\n     */\n    _byDayAndMonthDay: function (isInit) {\n      var byMonthDay; // setup in initMonth\n\n      var byDay = this.by_data.BYDAY;\n      var date;\n      var dateIdx = 0;\n      var dateLen; // setup in initMonth\n\n      var dayLen = byDay.length; // we are not valid by default\n\n      var dataIsValid = 0;\n      var daysInMonth;\n      var self = this; // we need a copy of this, because a DateTime gets normalized\n      // automatically if the day is out of range. At some points we\n      // set the last day to 0 to start counting.\n\n      var lastDay = this.last.day;\n\n      function initMonth() {\n        daysInMonth = ICAL.Time.daysInMonth(self.last.month, self.last.year);\n        byMonthDay = self.normalizeByMonthDayRules(self.last.year, self.last.month, self.by_data.BYMONTHDAY);\n        dateLen = byMonthDay.length; // For the case of more than one occurrence in one month\n        // we have to be sure to start searching after the last\n        // found date or at the last BYMONTHDAY, unless we are\n        // initializing the iterator because in this case we have\n        // to consider the last found date too.\n\n        while (byMonthDay[dateIdx] <= lastDay && !(isInit && byMonthDay[dateIdx] == lastDay) && dateIdx < dateLen - 1) {\n          dateIdx++;\n        }\n      }\n\n      function nextMonth() {\n        // since the day is incremented at the start\n        // of the loop below, we need to start at 0\n        lastDay = 0;\n        self.increment_month();\n        dateIdx = 0;\n        initMonth();\n      }\n\n      initMonth(); // should come after initMonth\n\n      if (isInit) {\n        lastDay -= 1;\n      } // Use a counter to avoid an infinite loop with malformed rules.\n      // Stop checking after 4 years so we consider also a leap year.\n\n\n      var monthsCounter = 48;\n\n      while (!dataIsValid && monthsCounter) {\n        monthsCounter--; // increment the current date. This is really\n        // important otherwise we may fall into the infinite\n        // loop trap. The initial date takes care of the case\n        // where the current date is the date we are looking\n        // for.\n\n        date = lastDay + 1;\n\n        if (date > daysInMonth) {\n          nextMonth();\n          continue;\n        } // find next date\n\n\n        var next = byMonthDay[dateIdx++]; // this logic is dependant on the BYMONTHDAYS\n        // being in order (which is done by #normalizeByMonthDayRules)\n\n        if (next >= date) {\n          // if the next month day is in the future jump to it.\n          lastDay = next;\n        } else {\n          // in this case the 'next' monthday has past\n          // we must move to the month.\n          nextMonth();\n          continue;\n        } // Now we can loop through the day rules to see\n        // if one matches the current month date.\n\n\n        for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {\n          var parts = this.ruleDayOfWeek(byDay[dayIdx]);\n          var pos = parts[0];\n          var dow = parts[1];\n          this.last.day = lastDay;\n\n          if (this.last.isNthWeekDay(dow, pos)) {\n            // when we find the valid one we can mark\n            // the conditions as met and break the loop.\n            // (Because we have this condition above\n            //  it will also break the parent loop).\n            dataIsValid = 1;\n            break;\n          }\n        } // It is completely possible that the combination\n        // cannot be matched in the current month.\n        // When we reach the end of possible combinations\n        // in the current month we iterate to the next one.\n        // since dateIdx is incremented right after getting\n        // \"next\", we don't need dateLen -1 here.\n\n\n        if (!dataIsValid && dateIdx === dateLen) {\n          nextMonth();\n          continue;\n        }\n      }\n\n      if (monthsCounter <= 0) {\n        // Checked 4 years without finding a Byday that matches\n        // a Bymonthday. Maybe the rule is not correct.\n        throw new Error(\"Malformed values in BYDAY combined with BYMONTHDAY parts\");\n      }\n\n      return dataIsValid;\n    },\n    next_month: function next_month() {\n      var this_freq = this.rule.freq == \"MONTHLY\";\n      var data_valid = 1;\n\n      if (this.next_hour() == 0) {\n        return data_valid;\n      }\n\n      if (this.has_by_data(\"BYDAY\") && this.has_by_data(\"BYMONTHDAY\")) {\n        data_valid = this._byDayAndMonthDay();\n      } else if (this.has_by_data(\"BYDAY\")) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var setpos = 0;\n        var setpos_total = 0;\n\n        if (this.has_by_data(\"BYSETPOS\")) {\n          var last_day = this.last.day;\n\n          for (var day = 1; day <= daysInMonth; day++) {\n            this.last.day = day;\n\n            if (this.is_day_in_byday(this.last)) {\n              setpos_total++;\n\n              if (day <= last_day) {\n                setpos++;\n              }\n            }\n          }\n\n          this.last.day = last_day;\n        }\n\n        data_valid = 0;\n\n        for (var day = this.last.day + 1; day <= daysInMonth; day++) {\n          this.last.day = day;\n\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(++setpos) || this.check_set_position(setpos - setpos_total - 1)) {\n              data_valid = 1;\n              break;\n            }\n          }\n        }\n\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          this.increment_month();\n\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(1)) {\n              data_valid = 1;\n            }\n          } else {\n            data_valid = 0;\n          }\n        }\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        this.by_indices.BYMONTHDAY++;\n\n        if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {\n          this.by_indices.BYMONTHDAY = 0;\n          this.increment_month();\n        }\n\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];\n\n        if (day < 0) {\n          day = daysInMonth + day + 1;\n        }\n\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          data_valid = this.is_day_in_byday(this.last);\n        } else {\n          this.last.day = day;\n        }\n      } else {\n        this.increment_month();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n\n        if (this.by_data.BYMONTHDAY[0] > daysInMonth) {\n          data_valid = 0;\n        } else {\n          this.last.day = this.by_data.BYMONTHDAY[0];\n        }\n      }\n\n      return data_valid;\n    },\n    next_weekday_by_week: function next_weekday_by_week() {\n      var end_of_data = 0;\n\n      if (this.next_hour() == 0) {\n        return end_of_data;\n      }\n\n      if (!this.has_by_data(\"BYDAY\")) {\n        return 1;\n      }\n\n      for (;;) {\n        var tt = new ICAL.Time();\n        this.by_indices.BYDAY++;\n\n        if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {\n          this.by_indices.BYDAY = 0;\n          end_of_data = 1;\n        }\n\n        var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];\n        var parts = this.ruleDayOfWeek(coded_day);\n        var dow = parts[1];\n        dow -= this.rule.wkst;\n\n        if (dow < 0) {\n          dow += 7;\n        }\n\n        tt.year = this.last.year;\n        tt.month = this.last.month;\n        tt.day = this.last.day;\n        var startOfWeek = tt.startDoyWeek(this.rule.wkst);\n\n        if (dow + startOfWeek < 1) {\n          // The selected date is in the previous year\n          if (!end_of_data) {\n            continue;\n          }\n        }\n\n        var next = ICAL.Time.fromDayOfYear(startOfWeek + dow, this.last.year);\n        /**\n         * The normalization horrors below are due to\n         * the fact that when the year/month/day changes\n         * it can effect the other operations that come after.\n         */\n\n        this.last.year = next.year;\n        this.last.month = next.month;\n        this.last.day = next.day;\n        return end_of_data;\n      }\n    },\n    next_year: function next_year() {\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n\n      if (++this.days_index == this.days.length) {\n        this.days_index = 0;\n\n        do {\n          this.increment_year(this.rule.interval);\n          this.expand_year_days(this.last.year);\n        } while (this.days.length == 0);\n      }\n\n      this._nextByYearDay();\n\n      return 1;\n    },\n    _nextByYearDay: function _nextByYearDay() {\n      var doy = this.days[this.days_index];\n      var year = this.last.year;\n\n      if (doy < 1) {\n        // Time.fromDayOfYear(doy, year) indexes relative to the\n        // start of the given year. That is different from the\n        // semantics of BYYEARDAY where negative indexes are an\n        // offset from the end of the given year.\n        doy += 1;\n        year += 1;\n      }\n\n      var next = ICAL.Time.fromDayOfYear(doy, year);\n      this.last.day = next.day;\n      this.last.month = next.month;\n    },\n\n    /**\n     * @param dow (eg: '1TU', '-1MO')\n     * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday\n     * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart\n     */\n    ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {\n      var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);\n\n      if (matches) {\n        var pos = parseInt(matches[1] || 0, 10);\n        dow = ICAL.Recur.icalDayToNumericDay(matches[2], aWeekStart);\n        return [pos, dow];\n      } else {\n        return [0, 0];\n      }\n    },\n    next_generic: function next_generic(aRuleType, aInterval, aDateAttr, aFollowingAttr, aPreviousIncr) {\n      var has_by_rule = (aRuleType in this.by_data);\n      var this_freq = this.rule.freq == aInterval;\n      var end_of_data = 0;\n\n      if (aPreviousIncr && this[aPreviousIncr]() == 0) {\n        return end_of_data;\n      }\n\n      if (has_by_rule) {\n        this.by_indices[aRuleType]++;\n        var idx = this.by_indices[aRuleType];\n        var dta = this.by_data[aRuleType];\n\n        if (this.by_indices[aRuleType] == dta.length) {\n          this.by_indices[aRuleType] = 0;\n          end_of_data = 1;\n        }\n\n        this.last[aDateAttr] = dta[this.by_indices[aRuleType]];\n      } else if (this_freq) {\n        this[\"increment_\" + aDateAttr](this.rule.interval);\n      }\n\n      if (has_by_rule && end_of_data && this_freq) {\n        this[\"increment_\" + aFollowingAttr](1);\n      }\n\n      return end_of_data;\n    },\n    increment_monthday: function increment_monthday(inc) {\n      for (var i = 0; i < inc; i++) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        this.last.day++;\n\n        if (this.last.day > daysInMonth) {\n          this.last.day -= daysInMonth;\n          this.increment_month();\n        }\n      }\n    },\n    increment_month: function increment_month() {\n      this.last.day = 1;\n\n      if (this.has_by_data(\"BYMONTH\")) {\n        this.by_indices.BYMONTH++;\n\n        if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {\n          this.by_indices.BYMONTH = 0;\n          this.increment_year(1);\n        }\n\n        this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];\n      } else {\n        if (this.rule.freq == \"MONTHLY\") {\n          this.last.month += this.rule.interval;\n        } else {\n          this.last.month++;\n        }\n\n        this.last.month--;\n        var years = ICAL.helpers.trunc(this.last.month / 12);\n        this.last.month %= 12;\n        this.last.month++;\n\n        if (years != 0) {\n          this.increment_year(years);\n        }\n      }\n    },\n    increment_year: function increment_year(inc) {\n      this.last.year += inc;\n    },\n    increment_generic: function increment_generic(inc, aDateAttr, aFactor, aNextIncrement) {\n      this.last[aDateAttr] += inc;\n      var nextunit = ICAL.helpers.trunc(this.last[aDateAttr] / aFactor);\n      this.last[aDateAttr] %= aFactor;\n\n      if (nextunit != 0) {\n        this[\"increment_\" + aNextIncrement](nextunit);\n      }\n    },\n    has_by_data: function has_by_data(aRuleType) {\n      return aRuleType in this.rule.parts;\n    },\n    expand_year_days: function expand_year_days(aYear) {\n      var t = new ICAL.Time();\n      this.days = []; // We need our own copy with a few keys set\n\n      var parts = {};\n      var rules = [\"BYDAY\", \"BYWEEKNO\", \"BYMONTHDAY\", \"BYMONTH\", \"BYYEARDAY\"];\n\n      for (var p in rules) {\n        /* istanbul ignore else */\n        if (rules.hasOwnProperty(p)) {\n          var part = rules[p];\n\n          if (part in this.rule.parts) {\n            parts[part] = this.rule.parts[part];\n          }\n        }\n      }\n\n      if (\"BYMONTH\" in parts && \"BYWEEKNO\" in parts) {\n        var valid = 1;\n        var validWeeks = {};\n        t.year = aYear;\n        t.isDate = true;\n\n        for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {\n          var month = this.by_data.BYMONTH[monthIdx];\n          t.month = month;\n          t.day = 1;\n          var first_week = t.weekNumber(this.rule.wkst);\n          t.day = ICAL.Time.daysInMonth(month, aYear);\n          var last_week = t.weekNumber(this.rule.wkst);\n\n          for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {\n            validWeeks[monthIdx] = 1;\n          }\n        }\n\n        for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {\n          var weekno = this.by_data.BYWEEKNO[weekIdx];\n\n          if (weekno < 52) {\n            valid &= validWeeks[weekIdx];\n          } else {\n            valid = 0;\n          }\n        }\n\n        if (valid) {\n          delete parts.BYMONTH;\n        } else {\n          delete parts.BYWEEKNO;\n        }\n      }\n\n      var partCount = Object.keys(parts).length;\n\n      if (partCount == 0) {\n        var t1 = this.dtstart.clone();\n        t1.year = this.last.year;\n        this.days.push(t1.dayOfYear());\n      } else if (partCount == 1 && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n\n          var t2 = this.dtstart.clone();\n          t2.year = aYear;\n          t2.month = this.by_data.BYMONTH[monthkey];\n          t2.isDate = true;\n          this.days.push(t2.dayOfYear());\n        }\n      } else if (partCount == 1 && \"BYMONTHDAY\" in parts) {\n        for (var monthdaykey in this.by_data.BYMONTHDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n            continue;\n          }\n\n          var t3 = this.dtstart.clone();\n          var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n\n          if (day_ < 0) {\n            var daysInMonth = ICAL.Time.daysInMonth(t3.month, aYear);\n            day_ = day_ + daysInMonth + 1;\n          }\n\n          t3.day = day_;\n          t3.year = aYear;\n          t3.isDate = true;\n          this.days.push(t3.dayOfYear());\n        }\n      } else if (partCount == 2 && \"BYMONTHDAY\" in parts && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n\n          var month_ = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month_, aYear);\n\n          for (var monthdaykey in this.by_data.BYMONTHDAY) {\n            /* istanbul ignore if */\n            if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n              continue;\n            }\n\n            var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n\n            if (day_ < 0) {\n              day_ = day_ + daysInMonth + 1;\n            }\n\n            t.day = day_;\n            t.month = month_;\n            t.year = aYear;\n            t.isDate = true;\n            this.days.push(t.dayOfYear());\n          }\n        }\n      } else if (partCount == 1 && \"BYWEEKNO\" in parts) {// TODO unimplemented in libical\n      } else if (partCount == 2 && \"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {// TODO unimplemented in libical\n      } else if (partCount == 1 && \"BYDAY\" in parts) {\n        this.days = this.days.concat(this.expand_by_day(aYear));\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n\n          var month = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month, aYear);\n          t.year = aYear;\n          t.month = this.by_data.BYMONTH[monthkey];\n          t.day = 1;\n          t.isDate = true;\n          var first_dow = t.dayOfWeek();\n          var doy_offset = t.dayOfYear() - 1;\n          t.day = daysInMonth;\n          var last_dow = t.dayOfWeek();\n\n          if (this.has_by_data(\"BYSETPOS\")) {\n            var set_pos_counter = 0;\n            var by_month_day = [];\n\n            for (var day = 1; day <= daysInMonth; day++) {\n              t.day = day;\n\n              if (this.is_day_in_byday(t)) {\n                by_month_day.push(day);\n              }\n            }\n\n            for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {\n              if (this.check_set_position(spIndex + 1) || this.check_set_position(spIndex - by_month_day.length)) {\n                this.days.push(doy_offset + by_month_day[spIndex]);\n              }\n            }\n          } else {\n            for (var daycodedkey in this.by_data.BYDAY) {\n              /* istanbul ignore if */\n              if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {\n                continue;\n              }\n\n              var coded_day = this.by_data.BYDAY[daycodedkey];\n              var bydayParts = this.ruleDayOfWeek(coded_day);\n              var pos = bydayParts[0];\n              var dow = bydayParts[1];\n              var month_day;\n              var first_matching_day = (dow + 7 - first_dow) % 7 + 1;\n              var last_matching_day = daysInMonth - (last_dow + 7 - dow) % 7;\n\n              if (pos == 0) {\n                for (var day = first_matching_day; day <= daysInMonth; day += 7) {\n                  this.days.push(doy_offset + day);\n                }\n              } else if (pos > 0) {\n                month_day = first_matching_day + (pos - 1) * 7;\n\n                if (month_day <= daysInMonth) {\n                  this.days.push(doy_offset + month_day);\n                }\n              } else {\n                month_day = last_matching_day + (pos + 1) * 7;\n\n                if (month_day > 0) {\n                  this.days.push(doy_offset + month_day);\n                }\n              }\n            }\n          }\n        } // Return dates in order of occurrence (1,2,3,...) instead\n        // of by groups of weekdays (1,8,15,...,2,9,16,...).\n\n\n        this.days.sort(function (a, b) {\n          return a - b;\n        }); // Comparator function allows to sort numbers.\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n\n          if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts && \"BYMONTH\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n\n          if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 && this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n          var weekno = tt.weekNumber(this.rule.wkst);\n\n          if (this.by_data.BYWEEKNO.indexOf(weekno)) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {// TODO unimplemted in libical\n      } else if (partCount == 1 && \"BYYEARDAY\" in parts) {\n        this.days = this.days.concat(this.by_data.BYYEARDAY);\n      } else {\n        this.days = [];\n      }\n\n      return 0;\n    },\n    expand_by_day: function expand_by_day(aYear) {\n      var days_list = [];\n      var tmp = this.last.clone();\n      tmp.year = aYear;\n      tmp.month = 1;\n      tmp.day = 1;\n      tmp.isDate = true;\n      var start_dow = tmp.dayOfWeek();\n      tmp.month = 12;\n      tmp.day = 31;\n      tmp.isDate = true;\n      var end_dow = tmp.dayOfWeek();\n      var end_year_day = tmp.dayOfYear();\n\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n\n        if (pos == 0) {\n          var tmp_start_doy = (dow + 7 - start_dow) % 7 + 1;\n\n          for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {\n            days_list.push(doy);\n          }\n        } else if (pos > 0) {\n          var first;\n\n          if (dow >= start_dow) {\n            first = dow - start_dow + 1;\n          } else {\n            first = dow - start_dow + 8;\n          }\n\n          days_list.push(first + (pos - 1) * 7);\n        } else {\n          var last;\n          pos = -pos;\n\n          if (dow <= end_dow) {\n            last = end_year_day - end_dow + dow;\n          } else {\n            last = end_year_day - end_dow + dow - 7;\n          }\n\n          days_list.push(last - (pos - 1) * 7);\n        }\n      }\n\n      return days_list;\n    },\n    is_day_in_byday: function is_day_in_byday(tt) {\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n        var this_dow = tt.dayOfWeek();\n\n        if (pos == 0 && dow == this_dow || tt.nthWeekDay(dow, pos) == tt.day) {\n          return 1;\n        }\n      }\n\n      return 0;\n    },\n\n    /**\n     * Checks if given value is in BYSETPOS.\n     *\n     * @private\n     * @param {Numeric} aPos position to check for.\n     * @return {Boolean} false unless BYSETPOS rules exist\n     *                   and the given value is present in rules.\n     */\n    check_set_position: function check_set_position(aPos) {\n      if (this.has_by_data('BYSETPOS')) {\n        var idx = this.by_data.BYSETPOS.indexOf(aPos); // negative numbers are not false-y\n\n        return idx !== -1;\n      }\n\n      return false;\n    },\n    sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {\n      for (var i = 0; i < aRules.length; i++) {\n        for (var j = 0; j < i; j++) {\n          var one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];\n          var two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];\n\n          if (one > two) {\n            var tmp = aRules[i];\n            aRules[i] = aRules[j];\n            aRules[j] = tmp;\n          }\n        }\n      }\n    },\n    check_contract_restriction: function check_contract_restriction(aRuleType, v) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n      var pass = false;\n\n      if (aRuleType in this.by_data && ruleMapValue == icalrecur_iterator.CONTRACT) {\n        var ruleType = this.by_data[aRuleType];\n\n        for (var bydatakey in ruleType) {\n          /* istanbul ignore else */\n          if (ruleType.hasOwnProperty(bydatakey)) {\n            if (ruleType[bydatakey] == v) {\n              pass = true;\n              break;\n            }\n          }\n        }\n      } else {\n        // Not a contracting byrule or has no data, test passes\n        pass = true;\n      }\n\n      return pass;\n    },\n    check_contracting_rules: function check_contracting_rules() {\n      var dow = this.last.dayOfWeek();\n      var weekNo = this.last.weekNumber(this.rule.wkst);\n      var doy = this.last.dayOfYear();\n      return this.check_contract_restriction(\"BYSECOND\", this.last.second) && this.check_contract_restriction(\"BYMINUTE\", this.last.minute) && this.check_contract_restriction(\"BYHOUR\", this.last.hour) && this.check_contract_restriction(\"BYDAY\", ICAL.Recur.numericDayToIcalDay(dow)) && this.check_contract_restriction(\"BYWEEKNO\", weekNo) && this.check_contract_restriction(\"BYMONTHDAY\", this.last.day) && this.check_contract_restriction(\"BYMONTH\", this.last.month) && this.check_contract_restriction(\"BYYEARDAY\", doy);\n    },\n    setup_defaults: function setup_defaults(aRuleType, req, deftime) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n\n      if (ruleMapValue != icalrecur_iterator.CONTRACT) {\n        if (!(aRuleType in this.by_data)) {\n          this.by_data[aRuleType] = [deftime];\n        }\n\n        if (this.rule.freq != req) {\n          return this.by_data[aRuleType][0];\n        }\n      }\n\n      return deftime;\n    },\n\n    /**\n     * Convert iterator into a serialize-able object.  Will preserve current\n     * iteration sequence to ensure the seamless continuation of the recurrence\n     * rule.\n     * @return {Object}\n     */\n    toJSON: function () {\n      var result = Object.create(null);\n      result.initialized = this.initialized;\n      result.rule = this.rule.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.by_data = this.by_data;\n      result.days = this.days;\n      result.last = this.last.toJSON();\n      result.by_indices = this.by_indices;\n      result.occurrence_number = this.occurrence_number;\n      return result;\n    }\n  };\n  icalrecur_iterator._indexMap = {\n    \"BYSECOND\": 0,\n    \"BYMINUTE\": 1,\n    \"BYHOUR\": 2,\n    \"BYDAY\": 3,\n    \"BYMONTHDAY\": 4,\n    \"BYYEARDAY\": 5,\n    \"BYWEEKNO\": 6,\n    \"BYMONTH\": 7,\n    \"BYSETPOS\": 8\n  };\n  icalrecur_iterator._expandMap = {\n    \"SECONDLY\": [1, 1, 1, 1, 1, 1, 1, 1],\n    \"MINUTELY\": [2, 1, 1, 1, 1, 1, 1, 1],\n    \"HOURLY\": [2, 2, 1, 1, 1, 1, 1, 1],\n    \"DAILY\": [2, 2, 2, 1, 1, 1, 1, 1],\n    \"WEEKLY\": [2, 2, 2, 2, 3, 3, 1, 1],\n    \"MONTHLY\": [2, 2, 2, 2, 2, 3, 3, 1],\n    \"YEARLY\": [2, 2, 2, 2, 2, 2, 2, 2]\n  };\n  icalrecur_iterator.UNKNOWN = 0;\n  icalrecur_iterator.CONTRACT = 1;\n  icalrecur_iterator.EXPAND = 2;\n  icalrecur_iterator.ILLEGAL = 3;\n  return icalrecur_iterator;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.RecurExpansion = function () {\n  function formatTime(item) {\n    return ICAL.helpers.formatClassType(item, ICAL.Time);\n  }\n\n  function compareTime(a, b) {\n    return a.compare(b);\n  }\n\n  function isRecurringComponent(comp) {\n    return comp.hasProperty('rdate') || comp.hasProperty('rrule') || comp.hasProperty('recurrence-id');\n  }\n  /**\n   * @classdesc\n   * Primary class for expanding recurring rules.  Can take multiple rrules,\n   * rdates, exdate(s) and iterate (in order) over each next occurrence.\n   *\n   * Once initialized this class can also be serialized saved and continue\n   * iteration from the last point.\n   *\n   * NOTE: it is intended that this class is to be used\n   *       with ICAL.Event which handles recurrence exceptions.\n   *\n   * @example\n   * // assuming event is a parsed ical component\n   * var event;\n   *\n   * var expand = new ICAL.RecurExpansion({\n   *   component: event,\n   *   dtstart: event.getFirstPropertyValue('dtstart')\n   * });\n   *\n   * // remember there are infinite rules\n   * // so it is a good idea to limit the scope\n   * // of the iterations then resume later on.\n   *\n   * // next is always an ICAL.Time or null\n   * var next;\n   *\n   * while (someCondition && (next = expand.next())) {\n   *   // do something with next\n   * }\n   *\n   * // save instance for later\n   * var json = JSON.stringify(expand);\n   *\n   * //...\n   *\n   * // NOTE: if the component's properties have\n   * //       changed you will need to rebuild the\n   * //       class and start over. This only works\n   * //       when the component's recurrence info is the same.\n   * var expand = new ICAL.RecurExpansion(JSON.parse(json));\n   *\n   * @description\n   * The options object can be filled with the specified initial values. It can\n   * also contain additional members, as a result of serializing a previous\n   * expansion state, as shown in the example.\n   *\n   * @class\n   * @alias ICAL.RecurExpansion\n   * @param {Object} options\n   *        Recurrence expansion options\n   * @param {ICAL.Time} options.dtstart\n   *        Start time of the event\n   * @param {ICAL.Component=} options.component\n   *        Component for expansion, required if not resuming.\n   */\n\n\n  function RecurExpansion(options) {\n    this.ruleDates = [];\n    this.exDates = [];\n    this.fromData(options);\n  }\n\n  RecurExpansion.prototype = {\n    /**\n     * True when iteration is fully completed.\n     * @type {Boolean}\n     */\n    complete: false,\n\n    /**\n     * Array of rrule iterators.\n     *\n     * @type {ICAL.RecurIterator[]}\n     * @private\n     */\n    ruleIterators: null,\n\n    /**\n     * Array of rdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */\n    ruleDates: null,\n\n    /**\n     * Array of exdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */\n    exDates: null,\n\n    /**\n     * Current position in ruleDates array.\n     * @type {Number}\n     * @private\n     */\n    ruleDateInc: 0,\n\n    /**\n     * Current position in exDates array\n     * @type {Number}\n     * @private\n     */\n    exDateInc: 0,\n\n    /**\n     * Current negative date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */\n    exDate: null,\n\n    /**\n     * Current additional date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */\n    ruleDate: null,\n\n    /**\n     * Start date of recurring rules.\n     *\n     * @type {ICAL.Time}\n     */\n    dtstart: null,\n\n    /**\n     * Last expanded time\n     *\n     * @type {ICAL.Time}\n     */\n    last: null,\n\n    /**\n     * Initialize the recurrence expansion from the data object. The options\n     * object may also contain additional members, see the\n     * {@link ICAL.RecurExpansion constructor} for more details.\n     *\n     * @param {Object} options\n     *        Recurrence expansion options\n     * @param {ICAL.Time} options.dtstart\n     *        Start time of the event\n     * @param {ICAL.Component=} options.component\n     *        Component for expansion, required if not resuming.\n     */\n    fromData: function (options) {\n      var start = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n\n      if (!start) {\n        throw new Error('.dtstart (ICAL.Time) must be given');\n      } else {\n        this.dtstart = start;\n      }\n\n      if (options.component) {\n        this._init(options.component);\n      } else {\n        this.last = formatTime(options.last) || start.clone();\n\n        if (!options.ruleIterators) {\n          throw new Error('.ruleIterators or .component must be given');\n        }\n\n        this.ruleIterators = options.ruleIterators.map(function (item) {\n          return ICAL.helpers.formatClassType(item, ICAL.RecurIterator);\n        });\n        this.ruleDateInc = options.ruleDateInc;\n        this.exDateInc = options.exDateInc;\n\n        if (options.ruleDates) {\n          this.ruleDates = options.ruleDates.map(formatTime);\n          this.ruleDate = this.ruleDates[this.ruleDateInc];\n        }\n\n        if (options.exDates) {\n          this.exDates = options.exDates.map(formatTime);\n          this.exDate = this.exDates[this.exDateInc];\n        }\n\n        if (typeof options.complete !== 'undefined') {\n          this.complete = options.complete;\n        }\n      }\n    },\n\n    /**\n     * Retrieve the next occurrence in the series.\n     * @return {ICAL.Time}\n     */\n    next: function () {\n      var iter;\n      var ruleOfDay;\n      var next;\n      var compare;\n      var maxTries = 500;\n      var currentTry = 0;\n\n      while (true) {\n        if (currentTry++ > maxTries) {\n          throw new Error('max tries have occured, rule may be impossible to forfill.');\n        }\n\n        next = this.ruleDate;\n        iter = this._nextRecurrenceIter(this.last); // no more matches\n        // because we increment the rule day or rule\n        // _after_ we choose a value this should be\n        // the only spot where we need to worry about the\n        // end of events.\n\n        if (!next && !iter) {\n          // there are no more iterators or rdates\n          this.complete = true;\n          break;\n        } // no next rule day or recurrence rule is first.\n\n\n        if (!next || iter && next.compare(iter.last) > 0) {\n          // must be cloned, recur will reuse the time element.\n          next = iter.last.clone(); // move to next so we can continue\n\n          iter.next();\n        } // if the ruleDate is still next increment it.\n\n\n        if (this.ruleDate === next) {\n          this._nextRuleDay();\n        }\n\n        this.last = next; // check the negative rules\n\n        if (this.exDate) {\n          compare = this.exDate.compare(this.last);\n\n          if (compare < 0) {\n            this._nextExDay();\n          } // if the current rule is excluded skip it.\n\n\n          if (compare === 0) {\n            this._nextExDay();\n\n            continue;\n          }\n        } //XXX: The spec states that after we resolve the final\n        //     list of dates we execute exdate this seems somewhat counter\n        //     intuitive to what I have seen most servers do so for now\n        //     I exclude based on the original date not the one that may\n        //     have been modified by the exception.\n\n\n        return this.last;\n      }\n    },\n\n    /**\n     * Converts object into a serialize-able format. This format can be passed\n     * back into the expansion to resume iteration.\n     * @return {Object}\n     */\n    toJSON: function () {\n      function toJSON(item) {\n        return item.toJSON();\n      }\n\n      var result = Object.create(null);\n      result.ruleIterators = this.ruleIterators.map(toJSON);\n\n      if (this.ruleDates) {\n        result.ruleDates = this.ruleDates.map(toJSON);\n      }\n\n      if (this.exDates) {\n        result.exDates = this.exDates.map(toJSON);\n      }\n\n      result.ruleDateInc = this.ruleDateInc;\n      result.exDateInc = this.exDateInc;\n      result.last = this.last.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.complete = this.complete;\n      return result;\n    },\n\n    /**\n     * Extract all dates from the properties in the given component. The\n     * properties will be filtered by the property name.\n     *\n     * @private\n     * @param {ICAL.Component} component        The component to search in\n     * @param {String} propertyName             The property name to search for\n     * @return {ICAL.Time[]}                    The extracted dates.\n     */\n    _extractDates: function (component, propertyName) {\n      function handleProp(prop) {\n        idx = ICAL.helpers.binsearchInsert(result, prop, compareTime); // ordered insert\n\n        result.splice(idx, 0, prop);\n      }\n\n      var result = [];\n      var props = component.getAllProperties(propertyName);\n      var len = props.length;\n      var i = 0;\n      var prop;\n      var idx;\n\n      for (; i < len; i++) {\n        props[i].getValues().forEach(handleProp);\n      }\n\n      return result;\n    },\n\n    /**\n     * Initialize the recurrence expansion.\n     *\n     * @private\n     * @param {ICAL.Component} component    The component to initialize from.\n     */\n    _init: function (component) {\n      this.ruleIterators = [];\n      this.last = this.dtstart.clone(); // to provide api consistency non-recurring\n      // events can also use the iterator though it will\n      // only return a single time.\n\n      if (!isRecurringComponent(component)) {\n        this.ruleDate = this.last.clone();\n        this.complete = true;\n        return;\n      }\n\n      if (component.hasProperty('rdate')) {\n        this.ruleDates = this._extractDates(component, 'rdate'); // special hack for cases where first rdate is prior\n        // to the start date. We only check for the first rdate.\n        // This is mostly for google's crazy recurring date logic\n        // (contacts birthdays).\n\n        if (this.ruleDates[0] && this.ruleDates[0].compare(this.dtstart) < 0) {\n          this.ruleDateInc = 0;\n          this.last = this.ruleDates[0].clone();\n        } else {\n          this.ruleDateInc = ICAL.helpers.binsearchInsert(this.ruleDates, this.last, compareTime);\n        }\n\n        this.ruleDate = this.ruleDates[this.ruleDateInc];\n      }\n\n      if (component.hasProperty('rrule')) {\n        var rules = component.getAllProperties('rrule');\n        var i = 0;\n        var len = rules.length;\n        var rule;\n        var iter;\n\n        for (; i < len; i++) {\n          rule = rules[i].getFirstValue();\n          iter = rule.iterator(this.dtstart);\n          this.ruleIterators.push(iter); // increment to the next occurrence so future\n          // calls to next return times beyond the initial iteration.\n          // XXX: I find this suspicious might be a bug?\n\n          iter.next();\n        }\n      }\n\n      if (component.hasProperty('exdate')) {\n        this.exDates = this._extractDates(component, 'exdate'); // if we have a .last day we increment the index to beyond it.\n\n        this.exDateInc = ICAL.helpers.binsearchInsert(this.exDates, this.last, compareTime);\n        this.exDate = this.exDates[this.exDateInc];\n      }\n    },\n\n    /**\n     * Advance to the next exdate\n     * @private\n     */\n    _nextExDay: function () {\n      this.exDate = this.exDates[++this.exDateInc];\n    },\n\n    /**\n     * Advance to the next rule date\n     * @private\n     */\n    _nextRuleDay: function () {\n      this.ruleDate = this.ruleDates[++this.ruleDateInc];\n    },\n\n    /**\n     * Find and return the recurrence rule with the most recent event and\n     * return it.\n     *\n     * @private\n     * @return {?ICAL.RecurIterator}    Found iterator.\n     */\n    _nextRecurrenceIter: function () {\n      var iters = this.ruleIterators;\n\n      if (iters.length === 0) {\n        return null;\n      }\n\n      var len = iters.length;\n      var iter;\n      var iterTime;\n      var iterIdx = 0;\n      var chosenIter; // loop through each iterator\n\n      for (; iterIdx < len; iterIdx++) {\n        iter = iters[iterIdx];\n        iterTime = iter.last; // if iteration is complete\n        // then we must exclude it from\n        // the search and remove it.\n\n        if (iter.completed) {\n          len--;\n\n          if (iterIdx !== 0) {\n            iterIdx--;\n          }\n\n          iters.splice(iterIdx, 1);\n          continue;\n        } // find the most recent possible choice\n\n\n        if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {\n          // that iterator is saved\n          chosenIter = iter;\n        }\n      } // the chosen iterator is returned but not mutated\n      // this iterator contains the most recent event.\n\n\n      return chosenIter;\n    }\n  };\n  return RecurExpansion;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.Event = function () {\n  /**\n   * @classdesc\n   * ICAL.js is organized into multiple layers. The bottom layer is a raw jCal\n   * object, followed by the component/property layer. The highest level is the\n   * event representation, which this class is part of. See the\n   * {@tutorial layers} guide for more details.\n   *\n   * @class\n   * @alias ICAL.Event\n   * @param {ICAL.Component=} component         The ICAL.Component to base this event on\n   * @param {Object} options                    Options for this event\n   * @param {Boolean} options.strictExceptions\n   *          When true, will verify exceptions are related by their UUID\n   * @param {Array<ICAL.Component|ICAL.Event>} options.exceptions\n   *          Exceptions to this event, either as components or events. If not\n   *            specified exceptions will automatically be set in relation of\n   *            component's parent\n   */\n  function Event(component, options) {\n    if (!(component instanceof ICAL.Component)) {\n      options = component;\n      component = null;\n    }\n\n    if (component) {\n      this.component = component;\n    } else {\n      this.component = new ICAL.Component('vevent');\n    }\n\n    this._rangeExceptionCache = Object.create(null);\n    this.exceptions = Object.create(null);\n    this.rangeExceptions = [];\n\n    if (options && options.strictExceptions) {\n      this.strictExceptions = options.strictExceptions;\n    }\n\n    if (options && options.exceptions) {\n      options.exceptions.forEach(this.relateException, this);\n    } else if (this.component.parent && !this.isRecurrenceException()) {\n      this.component.parent.getAllSubcomponents('vevent').forEach(function (event) {\n        if (event.hasProperty('recurrence-id')) {\n          this.relateException(event);\n        }\n      }, this);\n    }\n  }\n\n  Event.prototype = {\n    THISANDFUTURE: 'THISANDFUTURE',\n\n    /**\n     * List of related event exceptions.\n     *\n     * @type {ICAL.Event[]}\n     */\n    exceptions: null,\n\n    /**\n     * When true, will verify exceptions are related by their UUID.\n     *\n     * @type {Boolean}\n     */\n    strictExceptions: false,\n\n    /**\n     * Relates a given event exception to this object.  If the given component\n     * does not share the UID of this event it cannot be related and will throw\n     * an exception.\n     *\n     * If this component is an exception it cannot have other exceptions\n     * related to it.\n     *\n     * @param {ICAL.Component|ICAL.Event} obj       Component or event\n     */\n    relateException: function (obj) {\n      if (this.isRecurrenceException()) {\n        throw new Error('cannot relate exception to exceptions');\n      }\n\n      if (obj instanceof ICAL.Component) {\n        obj = new ICAL.Event(obj);\n      }\n\n      if (this.strictExceptions && obj.uid !== this.uid) {\n        throw new Error('attempted to relate unrelated exception');\n      }\n\n      var id = obj.recurrenceId.toString(); // we don't sort or manage exceptions directly\n      // here the recurrence expander handles that.\n\n      this.exceptions[id] = obj; // index RANGE=THISANDFUTURE exceptions so we can\n      // look them up later in getOccurrenceDetails.\n\n      if (obj.modifiesFuture()) {\n        var item = [obj.recurrenceId.toUnixTime(), id]; // we keep them sorted so we can find the nearest\n        // value later on...\n\n        var idx = ICAL.helpers.binsearchInsert(this.rangeExceptions, item, compareRangeException);\n        this.rangeExceptions.splice(idx, 0, item);\n      }\n    },\n\n    /**\n     * Checks if this record is an exception and has the RANGE=THISANDFUTURE\n     * value.\n     *\n     * @return {Boolean}        True, when exception is within range\n     */\n    modifiesFuture: function () {\n      if (!this.component.hasProperty('recurrence-id')) {\n        return false;\n      }\n\n      var range = this.component.getFirstProperty('recurrence-id').getParameter('range');\n      return range === this.THISANDFUTURE;\n    },\n\n    /**\n     * Finds the range exception nearest to the given date.\n     *\n     * @param {ICAL.Time} time usually an occurrence time of an event\n     * @return {?ICAL.Event} the related event/exception or null\n     */\n    findRangeException: function (time) {\n      if (!this.rangeExceptions.length) {\n        return null;\n      }\n\n      var utc = time.toUnixTime();\n      var idx = ICAL.helpers.binsearchInsert(this.rangeExceptions, [utc], compareRangeException);\n      idx -= 1; // occurs before\n\n      if (idx < 0) {\n        return null;\n      }\n\n      var rangeItem = this.rangeExceptions[idx];\n      /* istanbul ignore next: sanity check only */\n\n      if (utc < rangeItem[0]) {\n        return null;\n      }\n\n      return rangeItem[1];\n    },\n\n    /**\n     * This object is returned by {@link ICAL.Event#getOccurrenceDetails getOccurrenceDetails}\n     *\n     * @typedef {Object} occurrenceDetails\n     * @memberof ICAL.Event\n     * @property {ICAL.Time} recurrenceId       The passed in recurrence id\n     * @property {ICAL.Event} item              The occurrence\n     * @property {ICAL.Time} startDate          The start of the occurrence\n     * @property {ICAL.Time} endDate            The end of the occurrence\n     */\n\n    /**\n     * Returns the occurrence details based on its start time.  If the\n     * occurrence has an exception will return the details for that exception.\n     *\n     * NOTE: this method is intend to be used in conjunction\n     *       with the {@link ICAL.Event#iterator iterator} method.\n     *\n     * @param {ICAL.Time} occurrence time occurrence\n     * @return {ICAL.Event.occurrenceDetails} Information about the occurrence\n     */\n    getOccurrenceDetails: function (occurrence) {\n      var id = occurrence.toString();\n      var utcId = occurrence.convertToZone(ICAL.Timezone.utcTimezone).toString();\n      var item;\n      var result = {\n        //XXX: Clone?\n        recurrenceId: occurrence\n      };\n\n      if (id in this.exceptions) {\n        item = result.item = this.exceptions[id];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else if (utcId in this.exceptions) {\n        item = this.exceptions[utcId];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else {\n        // range exceptions (RANGE=THISANDFUTURE) have a\n        // lower priority then direct exceptions but\n        // must be accounted for first. Their item is\n        // always the first exception with the range prop.\n        var rangeExceptionId = this.findRangeException(occurrence);\n        var end;\n\n        if (rangeExceptionId) {\n          var exception = this.exceptions[rangeExceptionId]; // range exception must modify standard time\n          // by the difference (if any) in start/end times.\n\n          result.item = exception;\n          var startDiff = this._rangeExceptionCache[rangeExceptionId];\n\n          if (!startDiff) {\n            var original = exception.recurrenceId.clone();\n            var newStart = exception.startDate.clone(); // zones must be same otherwise subtract may be incorrect.\n\n            original.zone = newStart.zone;\n            startDiff = newStart.subtractDate(original);\n            this._rangeExceptionCache[rangeExceptionId] = startDiff;\n          }\n\n          var start = occurrence.clone();\n          start.zone = exception.startDate.zone;\n          start.addDuration(startDiff);\n          end = start.clone();\n          end.addDuration(exception.duration);\n          result.startDate = start;\n          result.endDate = end;\n        } else {\n          // no range exception standard expansion\n          end = occurrence.clone();\n          end.addDuration(this.duration);\n          result.endDate = end;\n          result.startDate = occurrence;\n          result.item = this;\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * Builds a recur expansion instance for a specific point in time (defaults\n     * to startDate).\n     *\n     * @param {ICAL.Time} startTime     Starting point for expansion\n     * @return {ICAL.RecurExpansion}    Expansion object\n     */\n    iterator: function (startTime) {\n      return new ICAL.RecurExpansion({\n        component: this.component,\n        dtstart: startTime || this.startDate\n      });\n    },\n\n    /**\n     * Checks if the event is recurring\n     *\n     * @return {Boolean}        True, if event is recurring\n     */\n    isRecurring: function () {\n      var comp = this.component;\n      return comp.hasProperty('rrule') || comp.hasProperty('rdate');\n    },\n\n    /**\n     * Checks if the event describes a recurrence exception. See\n     * {@tutorial terminology} for details.\n     *\n     * @return {Boolean}    True, if the event describes a recurrence exception\n     */\n    isRecurrenceException: function () {\n      return this.component.hasProperty('recurrence-id');\n    },\n\n    /**\n     * Returns the types of recurrences this event may have.\n     *\n     * Returned as an object with the following possible keys:\n     *\n     *    - YEARLY\n     *    - MONTHLY\n     *    - WEEKLY\n     *    - DAILY\n     *    - MINUTELY\n     *    - SECONDLY\n     *\n     * @return {Object.<ICAL.Recur.frequencyValues, Boolean>}\n     *          Object of recurrence flags\n     */\n    getRecurrenceTypes: function () {\n      var rules = this.component.getAllProperties('rrule');\n      var i = 0;\n      var len = rules.length;\n      var result = Object.create(null);\n\n      for (; i < len; i++) {\n        var value = rules[i].getFirstValue();\n        result[value.freq] = true;\n      }\n\n      return result;\n    },\n\n    /**\n     * The uid of this event\n     * @type {String}\n     */\n    get uid() {\n      return this._firstProp('uid');\n    },\n\n    set uid(value) {\n      this._setProp('uid', value);\n    },\n\n    /**\n     * The start date\n     * @type {ICAL.Time}\n     */\n    get startDate() {\n      return this._firstProp('dtstart');\n    },\n\n    set startDate(value) {\n      this._setTime('dtstart', value);\n    },\n\n    /**\n     * The end date. This can be the result directly from the property, or the\n     * end date calculated from start date and duration. Setting the property\n     * will remove any duration properties.\n     * @type {ICAL.Time}\n     */\n    get endDate() {\n      var endDate = this._firstProp('dtend');\n\n      if (!endDate) {\n        var duration = this._firstProp('duration');\n\n        endDate = this.startDate.clone();\n\n        if (duration) {\n          endDate.addDuration(duration);\n        } else if (endDate.isDate) {\n          endDate.day += 1;\n        }\n      }\n\n      return endDate;\n    },\n\n    set endDate(value) {\n      if (this.component.hasProperty('duration')) {\n        this.component.removeProperty('duration');\n      }\n\n      this._setTime('dtend', value);\n    },\n\n    /**\n     * The duration. This can be the result directly from the property, or the\n     * duration calculated from start date and end date. Setting the property\n     * will remove any `dtend` properties.\n     * @type {ICAL.Duration}\n     */\n    get duration() {\n      var duration = this._firstProp('duration');\n\n      if (!duration) {\n        return this.endDate.subtractDateTz(this.startDate);\n      }\n\n      return duration;\n    },\n\n    set duration(value) {\n      if (this.component.hasProperty('dtend')) {\n        this.component.removeProperty('dtend');\n      }\n\n      this._setProp('duration', value);\n    },\n\n    /**\n     * The location of the event.\n     * @type {String}\n     */\n    get location() {\n      return this._firstProp('location');\n    },\n\n    set location(value) {\n      return this._setProp('location', value);\n    },\n\n    /**\n     * The attendees in the event\n     * @type {ICAL.Property[]}\n     * @readonly\n     */\n    get attendees() {\n      //XXX: This is way lame we should have a better\n      //     data structure for this later.\n      return this.component.getAllProperties('attendee');\n    },\n\n    /**\n     * The event summary\n     * @type {String}\n     */\n    get summary() {\n      return this._firstProp('summary');\n    },\n\n    set summary(value) {\n      this._setProp('summary', value);\n    },\n\n    /**\n     * The event description.\n     * @type {String}\n     */\n    get description() {\n      return this._firstProp('description');\n    },\n\n    set description(value) {\n      this._setProp('description', value);\n    },\n\n    /**\n     * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)\n     * @type {String}\n     */\n    get color() {\n      return this._firstProp('color');\n    },\n\n    set color(value) {\n      this._setProp('color', value);\n    },\n\n    /**\n     * The organizer value as an uri. In most cases this is a mailto: uri, but\n     * it can also be something else, like urn:uuid:...\n     * @type {String}\n     */\n    get organizer() {\n      return this._firstProp('organizer');\n    },\n\n    set organizer(value) {\n      this._setProp('organizer', value);\n    },\n\n    /**\n     * The sequence value for this event. Used for scheduling\n     * see {@tutorial terminology}.\n     * @type {Number}\n     */\n    get sequence() {\n      return this._firstProp('sequence');\n    },\n\n    set sequence(value) {\n      this._setProp('sequence', value);\n    },\n\n    /**\n     * The recurrence id for this event. See {@tutorial terminology} for details.\n     * @type {ICAL.Time}\n     */\n    get recurrenceId() {\n      return this._firstProp('recurrence-id');\n    },\n\n    set recurrenceId(value) {\n      this._setTime('recurrence-id', value);\n    },\n\n    /**\n     * Set/update a time property's value.\n     * This will also update the TZID of the property.\n     *\n     * TODO: this method handles the case where we are switching\n     * from a known timezone to an implied timezone (one without TZID).\n     * This does _not_ handle the case of moving between a known\n     *  (by TimezoneService) timezone to an unknown timezone...\n     *\n     * We will not add/remove/update the VTIMEZONE subcomponents\n     *  leading to invalid ICAL data...\n     * @private\n     * @param {String} propName     The property name\n     * @param {ICAL.Time} time      The time to set\n     */\n    _setTime: function (propName, time) {\n      var prop = this.component.getFirstProperty(propName);\n\n      if (!prop) {\n        prop = new ICAL.Property(propName);\n        this.component.addProperty(prop);\n      } // utc and local don't get a tzid\n\n\n      if (time.zone === ICAL.Timezone.localTimezone || time.zone === ICAL.Timezone.utcTimezone) {\n        // remove the tzid\n        prop.removeParameter('tzid');\n      } else {\n        prop.setParameter('tzid', time.zone.tzid);\n      }\n\n      prop.setValue(time);\n    },\n    _setProp: function (name, value) {\n      this.component.updatePropertyWithValue(name, value);\n    },\n    _firstProp: function (name) {\n      return this.component.getFirstPropertyValue(name);\n    },\n\n    /**\n     * The string representation of this event.\n     * @return {String}\n     */\n    toString: function () {\n      return this.component.toString();\n    }\n  };\n\n  function compareRangeException(a, b) {\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    return 0;\n  }\n\n  return Event;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * This symbol is further described later on\n * @ignore\n */\n\n\nICAL.ComponentParser = function () {\n  /**\n   * @classdesc\n   * The ComponentParser is used to process a String or jCal Object,\n   * firing callbacks for various found components, as well as completion.\n   *\n   * @example\n   * var options = {\n   *   // when false no events will be emitted for type\n   *   parseEvent: true,\n   *   parseTimezone: true\n   * };\n   *\n   * var parser = new ICAL.ComponentParser(options);\n   *\n   * parser.onevent(eventComponent) {\n   *   //...\n   * }\n   *\n   * // ontimezone, etc...\n   *\n   * parser.oncomplete = function() {\n   *\n   * };\n   *\n   * parser.process(stringOrComponent);\n   *\n   * @class\n   * @alias ICAL.ComponentParser\n   * @param {Object=} options        Component parser options\n   * @param {Boolean} options.parseEvent        Whether events should be parsed\n   * @param {Boolean} options.parseTimezeone    Whether timezones should be parsed\n   */\n  function ComponentParser(options) {\n    if (typeof options === 'undefined') {\n      options = {};\n    }\n\n    var key;\n\n    for (key in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(key)) {\n        this[key] = options[key];\n      }\n    }\n  }\n\n  ComponentParser.prototype = {\n    /**\n     * When true, parse events\n     *\n     * @type {Boolean}\n     */\n    parseEvent: true,\n\n    /**\n     * When true, parse timezones\n     *\n     * @type {Boolean}\n     */\n    parseTimezone: true,\n\n    /* SAX like events here for reference */\n\n    /**\n     * Fired when parsing is complete\n     * @callback\n     */\n    oncomplete:\n    /* istanbul ignore next */\n    function () {},\n\n    /**\n     * Fired if an error occurs during parsing.\n     *\n     * @callback\n     * @param {Error} err details of error\n     */\n    onerror:\n    /* istanbul ignore next */\n    function (err) {},\n\n    /**\n     * Fired when a top level component (VTIMEZONE) is found\n     *\n     * @callback\n     * @param {ICAL.Timezone} component     Timezone object\n     */\n    ontimezone:\n    /* istanbul ignore next */\n    function (component) {},\n\n    /**\n     * Fired when a top level component (VEVENT) is found.\n     *\n     * @callback\n     * @param {ICAL.Event} component    Top level component\n     */\n    onevent:\n    /* istanbul ignore next */\n    function (component) {},\n\n    /**\n     * Process a string or parse ical object.  This function itself will return\n     * nothing but will start the parsing process.\n     *\n     * Events must be registered prior to calling this method.\n     *\n     * @param {ICAL.Component|String|Object} ical      The component to process,\n     *        either in its final form, as a jCal Object, or string representation\n     */\n    process: function (ical) {\n      //TODO: this is sync now in the future we will have a incremental parser.\n      if (typeof ical === 'string') {\n        ical = ICAL.parse(ical);\n      }\n\n      if (!(ical instanceof ICAL.Component)) {\n        ical = new ICAL.Component(ical);\n      }\n\n      var components = ical.getAllSubcomponents();\n      var i = 0;\n      var len = components.length;\n      var component;\n\n      for (; i < len; i++) {\n        component = components[i];\n\n        switch (component.name) {\n          case 'vtimezone':\n            if (this.parseTimezone) {\n              var tzid = component.getFirstPropertyValue('tzid');\n\n              if (tzid) {\n                this.ontimezone(new ICAL.Timezone({\n                  tzid: tzid,\n                  component: component\n                }));\n              }\n            }\n\n            break;\n\n          case 'vevent':\n            if (this.parseEvent) {\n              this.onevent(new ICAL.Event(component));\n            }\n\n            break;\n\n          default:\n            continue;\n        }\n      } //XXX: ideally we should do a \"nextTick\" here\n      //     so in all cases this is actually async.\n\n\n      this.oncomplete();\n    }\n  };\n  return ComponentParser;\n}();","map":{"version":3,"names":["ICAL","module","exports","HTMLScriptElement","prototype","window","foldLength","newLineChar","helpers","updateTimezones","vcal","allsubs","properties","vtimezones","reqTzid","i","tzid","name","getAllSubcomponents","length","getFirstProperty","getFirstValue","concat","getAllProperties","getParameter","hasOwnProperty","removeSubcomponent","TimezoneService","has","addSubcomponent","get","component","isStrictlyNaN","number","isNaN","strictParseInt","string","result","parseInt","Error","formatClassType","data","type","undefined","unescapedIndexOf","buffer","search","pos","indexOf","binsearchInsert","list","seekVal","cmpfunc","low","high","mid","cmpval","Math","floor","dumpn","debug","console","consoleDumpn","input","log","geckoDumpn","dump","arguments","clone","aSrc","aDeep","Date","getTime","Array","isArray","arr","push","obj","Object","call","foldline","aLine","line","line_length","cp","codePointAt","substring","substr","pad2","pad","String","len","trunc","ceil","inherits","base","child","extra","F","extend","source","target","key","descr","getOwnPropertyDescriptor","defineProperty","design","FROM_ICAL_NEWLINE","TO_ICAL_NEWLINE","FROM_VCARD_NEWLINE","TO_VCARD_NEWLINE","createTextType","fromNewline","toNewline","matches","fromICAL","aValue","structuredEscape","replaceNewline","toICAL","regEx","RegExp","replace","str","DEFAULT_TYPE_TEXT","defaultType","DEFAULT_TYPE_TEXT_MULTI","multiValue","DEFAULT_TYPE_TEXT_STRUCTURED","structuredValue","DEFAULT_TYPE_INTEGER","DEFAULT_TYPE_DATETIME_DATE","allowedTypes","DEFAULT_TYPE_DATETIME","DEFAULT_TYPE_URI","DEFAULT_TYPE_UTCOFFSET","DEFAULT_TYPE_RECUR","DEFAULT_TYPE_DATE_ANDOR_TIME","replaceNewlineReplace","value","newline","commonProperties","commonValues","values","float","parsed","parseFloat","integer","decorate","UtcOffset","fromString","undecorate","toString","icalParams","allowXName","allowIanaToken","valueType","multiValueSeparateDQuote","icalValues","text","uri","aString","Binary","aBinary","aProp","strict","Time","fromDateString","date","fromDateTimeString","duration","Duration","period","parts","split","isValueString","join","Period","fromJSON","toJSON","recur","Recur","_stringToData","k","val","numericDayToIcalDay","toUpperCase","fromData","aRecur","time","icalProperties","detectType","vcardValues","VCardTime","fromDateAndOrTimeString","splitzone","_splitZone","zone","isFromIcal","lastChar","signChar","sign","timestamp","vcardParams","vcardProperties","vcard3Values","binary","vcard","vcard3Params","vcard3Properties","fn","n","nickname","photo","bday","adr","label","tel","email","mailer","tz","geo","title","role","logo","agent","org","note","prodid","rev","sound","class","icalSet","param","property","vcardSet","vcard3Set","defaultSet","components","vcard3","vevent","vtodo","vjournal","valarm","vtimezone","daylight","standard","icalendar","getDesignSet","componentName","isInDesign","stringify","LINE_ENDING","DEFAULT_VALUE_TYPE","jCal","designSet","props","propIdx","propLen","designSetName","comps","compIdx","compLen","noFold","jsName","params","paramName","map","_rfc6868Unescape","propertyValue","propDetails","isDefault","slice","delim","innerMulti","x","RFC6868_REPLACE_MAP","parse","CHAR","MULTIVALUE_DELIMITER","VALUE_DELIMITER","PARAM_DELIMITER","PARAM_NAME_DELIMITER","DEFAULT_PARAM_TYPE","ParserError","message","e","stack","shift","parser","state","root","_eachLine","err","_handleContentLine","valuePos","paramPos","lastParamIndex","lastValuePos","parsedParams","toLowerCase","_parseParameters","newComponent","pop","propertyDetails","_parseMultiValue","_parseValue","start","lastParam","lcname","mvdelim","_rfc6868Escape","nextChar","extendedValue","nextPos","propValuePos","delimiter","lastPos","callback","firstChar","newlineOffset","trim","Component","PROPERTY_INDEX","COMPONENT_INDEX","NAME_INDEX","parent","_hydratedPropertyCount","_hydratedComponentCount","_designSet","parentDesign","_hydrateComponent","index","_components","comp","_hydrateProperty","_properties","prop","Property","getFirstSubcomponent","jCalLen","hasProperty","getFirstPropertyValue","_removeObjectByIndex","jCalIndex","cache","splice","_removeObject","nameOrObject","objects","cached","_removeAllObjects","idx","nameOrComp","removed","removeAllSubcomponents","addProperty","TypeError","removeProperty","addPropertyWithValue","setValue","updatePropertyWithValue","nameOrProp","removeAllProperties","PROP_INDEX","TYPE_INDEX","VALUE_INDEX","_parent","getDefaultType","_updateType","p","designSetChanged","designType","isDecorated","isMultiValue","isStructuredValue","_hydrateValue","_values","_decorate","_undecorate","_setDecoratedValue","getFirstParameter","parameters","setParameter","removeParameter","details","resetType","removeAllValues","getValues","setValues","icaltype","toICALString","aData","hours","minutes","factor","fromSeconds","toSeconds","_normalize","aSeconds","secs","abs","compare","icaltime_compare","other","a","b","options","instance","decodeValue","_b64_decode","setEncodedValue","_b64_encode","base64_encode","b64","o1","o2","o3","h1","h2","h3","h4","bits","ac","enc","tmp_arr","charCodeAt","charAt","r","base64_decode","dec","fromCharCode","icalperiod","wrappedJSObject","end","icalclass","getDuration","subtractDate","getEnd","addDuration","aLenient","fromDateOrDateTimeString","DURATION_LETTERS","icalduration","weeks","days","seconds","isNegative","propsToCopy","reset","aOther","thisSeconds","otherSeconds","normalize","icalduration_from_seconds","parseDurationChunk","letter","object","num","icalduration_from_string","aStr","dict","create","chunks","numeric","icalduration_from_data","OPTIONS","Timezone","icaltimezone","location","tznames","latitude","longitude","expandedUntilYear","changes","utcOffset","tt","utcTimezone","localTimezone","_ensureCoverage","year","tt_change","month","day","hour","minute","second","change_num","_findNearbyChange","change_num_to_use","step","change","prevUtcOffset","adjust_change","cmp","_compare_change_fn","zone_change","utcOffset_change","tmp_change","prev_zone_change","want_daylight","is_daylight","icaltimezone_find_nearby_change","aYear","_minimumExpansionYear","today","now","changesEndYear","EXTRA_COVERAGE","MAX_YEAR","subcomps","_expandComponent","sort","aComponent","dtstart","convert_tzoffset","offset","init_changes","changebase","rdatekey","rdate","isDate","rrule","until","adjust","iterator","occ","next","icaltimezone_compare_change_fn","convert_time","icaltimezone_convert_time","from_zone","to_zone","icaltimezone_fromData","icaltimezone_adjust_change","zones","count","keys","utc","Z","UTC","GMT","register","timezone","remove","icaltime","_time","_dowCache","_wnCache","_cachedUnixTime","_pendingNormalization","icaltime_reset","epochTime","resetTo","icaltime_resetTo","fromJSDate","icaltime_fromJSDate","aDate","useUTC","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","aZone","dayOfWeek","icaltime_dayOfWeek","aWeekStart","firstDow","SUNDAY","dowCacheKey","q","m","Y","h","dayOfYear","is_leap","isLeapYear","diypm","daysInYearPassedMonth","startOfWeek","endOfWeek","startOfMonth","endOfMonth","daysInMonth","startOfYear","endOfYear","startDoyWeek","aFirstDayOfWeek","delta","getDominicalLetter","nthWeekDay","icaltime_nthWeekDay","aDayOfWeek","aPos","weekday","otherDay","startDow","endDow","isNthWeekDay","dow","weekNumber","wnCacheKey","week1","dt","isoyear","weekOneStarts","daysBetween","answer","icaltime_add","aDuration","mult","icaltime_subtract","unixTime","toUnixTime","subtractDateTz","icaltime_subtract_abs","compareDateOnlyTz","icaltime_compareDateOnlyTz","attr","_cmp_attr","convertToZone","rc","copy","zone_equals","utc_offset","toJSDate","icaltime_normalize","icaltime_adjust","aExtraDays","aExtraHours","aExtraMinutes","aExtraSeconds","aTime","minutesOverflow","hoursOverflow","daysOverflow","yearsOverflow","fromUnixTime","epoch","ms","setupNormalizeAttributes","defineAttr","getTimeAttr","set","setTimeAttr","icaltime_daysInMonth","_daysInMonth","fromDayOfYear","icaltime_fromDayOfYear","aDayOfYear","doy","auto_normalize","fromStringv2","aProperty","t","icaltime_now","wkst","DEFAULT_WEEK_START","THURSDAY","yr","LTRS","dom","isLeap","MONDAY","TUESDAY","WEDNESDAY","FRIDAY","SATURDAY","apply","p2","y","d","mm","s","hasYear","hasMonth","hasDay","hasHour","hasMinute","hasSecond","datepart","timepart","aIcalType","part","v","tmz","tm","stoi","dtlen","tmlen","hasDashDate","hasDashTime","o","DOW_MAP","SU","MO","TU","WE","TH","FR","SA","REVERSE_DOW_MAP","COPY_PARTS","icalrecur","interval","freq","aStart","RecurIterator","rule","isFinite","isfinite","isByCount","isbycount","addComponent","addPart","aType","ucname","setComponent","aValues","getComponent","getNextOccurrence","aStartTime","aRecurrenceId","iter","cdt","uckey","partDesign","optionDesign","INTERVAL","icalDayToNumericDay","res","kparts","icalrecur_toString","parseNumericValue","min","max","toNumericDay","toIcalDay","VALID_DAY_NAMES","VALID_BYDAY_PART","ALLOWED_FREQ","FREQ","fmtIcal","COUNT","UNTIL","WKST","test","BYSECOND","bind","BYMINUTE","BYHOUR","BYDAY","BYMONTHDAY","BYYEARDAY","BYWEEKNO","BYMONTH","BYSETPOS","partArr","partArrIdx","partArrLen","icalrecur_iterator","completed","last","occurrence_number","by_indices","initialized","by_data","days_index","init","icalrecur_iterator_init","sort_byday_rules","setup_defaults","bydayParts","ruleDayOfWeek","wkdy","dayName","expand_year_days","increment_year","_nextByYearDay","has_by_data","tempLast","initLast","dayOfMonth","increment_month","_byDayAndMonthDay","icalrecur_iterator_next","before","valid","next_second","next_minute","next_hour","next_day","next_week","next_month","next_year","check_contracting_rules","next_generic","increment_second","inc","increment_generic","increment_minute","increment_hour","has_by_day","this_freq","increment_monthday","end_of_data","next_weekday_by_week","week_no","normalizeByMonthDayRules","rules","newRules","ruleIdx","isInit","byMonthDay","byDay","dateIdx","dateLen","dayLen","dataIsValid","self","lastDay","initMonth","nextMonth","monthsCounter","dayIdx","data_valid","setpos","setpos_total","last_day","is_day_in_byday","check_set_position","coded_day","match","aRuleType","aInterval","aDateAttr","aFollowingAttr","aPreviousIncr","has_by_rule","dta","years","aFactor","aNextIncrement","nextunit","validWeeks","monthIdx","first_week","last_week","weekIdx","weekno","partCount","t1","monthkey","t2","monthdaykey","t3","day_","month_","expand_by_day","first_dow","doy_offset","last_dow","set_pos_counter","by_month_day","spIndex","daycodedkey","month_day","first_matching_day","last_matching_day","expandedDays","daykey","days_list","tmp","start_dow","end_dow","end_year_day","tmp_start_doy","first","this_dow","icalrecur_sort_byday_rules","aRules","j","one","two","check_contract_restriction","indexMapValue","_indexMap","ruleMapValue","_expandMap","pass","CONTRACT","ruleType","bydatakey","weekNo","req","deftime","UNKNOWN","EXPAND","ILLEGAL","RecurExpansion","formatTime","item","compareTime","isRecurringComponent","ruleDates","exDates","complete","ruleIterators","ruleDateInc","exDateInc","exDate","ruleDate","_init","ruleOfDay","maxTries","currentTry","_nextRecurrenceIter","_nextRuleDay","_nextExDay","_extractDates","propertyName","handleProp","forEach","iters","iterTime","iterIdx","chosenIter","Event","_rangeExceptionCache","exceptions","rangeExceptions","strictExceptions","relateException","isRecurrenceException","event","THISANDFUTURE","uid","id","recurrenceId","modifiesFuture","compareRangeException","range","findRangeException","rangeItem","getOccurrenceDetails","occurrence","utcId","startDate","endDate","rangeExceptionId","exception","startDiff","original","newStart","startTime","isRecurring","getRecurrenceTypes","_firstProp","_setProp","_setTime","attendees","summary","description","color","organizer","sequence","propName","ComponentParser","parseEvent","parseTimezone","oncomplete","onerror","ontimezone","onevent","process","ical"],"sources":["/Users/cherrie/Desktop/messenger_ver_2/client/node_modules/ical.js/build/ical.js"],"sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2021 */\n\n/* jshint ignore:start */\nvar ICAL;\n(function() {\n  /* istanbul ignore next */\n  if (typeof module === 'object') {\n    // CommonJS, where exports may be different each time.\n    ICAL = module.exports;\n  } else if (typeof HTMLScriptElement !== 'undefined' && 'noModule' in HTMLScriptElement.prototype) {\n    // Until we use ES6 exports, using <script type=\"module\"> we define ICAL on the window global.\n    window.ICAL = ICAL = {};\n  } else if (typeof ICAL !== 'object') {\n    ICAL = {};\n  }\n})();\n/* jshint ignore:end */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\n * The number of characters before iCalendar line folding should occur\n * @type {Number}\n * @default 75\n */\nICAL.foldLength = 75;\n\n\n/**\n * The character(s) to be used for a newline. The default value is provided by\n * rfc5545.\n * @type {String}\n * @default \"\\r\\n\"\n */\nICAL.newLineChar = '\\r\\n';\n\n\n/**\n * Helper functions used in various places within ical.js\n * @namespace\n */\nICAL.helpers = {\n  /**\n   * Compiles a list of all referenced TZIDs in all subcomponents and\n   * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs\n   * are referenced by a component, but a VTIMEZONE does not exist,\n   * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.\n   *\n   * @param {ICAL.Component} vcal     The top-level VCALENDAR component.\n   * @return {ICAL.Component}         The ICAL.Component that was passed in.\n   */\n  updateTimezones: function(vcal) {\n    var allsubs, properties, vtimezones, reqTzid, i, tzid;\n\n    if (!vcal || vcal.name !== \"vcalendar\") {\n      //not a top-level vcalendar component\n      return vcal;\n    }\n\n    //Store vtimezone subcomponents in an object reference by tzid.\n    //Store properties from everything else in another array\n    allsubs = vcal.getAllSubcomponents();\n    properties = [];\n    vtimezones = {};\n    for (i = 0; i < allsubs.length; i++) {\n      if (allsubs[i].name === \"vtimezone\") {\n        tzid = allsubs[i].getFirstProperty(\"tzid\").getFirstValue();\n        vtimezones[tzid] = allsubs[i];\n      } else {\n        properties = properties.concat(allsubs[i].getAllProperties());\n      }\n    }\n\n    //create an object with one entry for each required tz\n    reqTzid = {};\n    for (i = 0; i < properties.length; i++) {\n      if ((tzid = properties[i].getParameter(\"tzid\"))) {\n        reqTzid[tzid] = true;\n      }\n    }\n\n    //delete any vtimezones that are not on the reqTzid list.\n    for (i in vtimezones) {\n      if (vtimezones.hasOwnProperty(i) && !reqTzid[i]) {\n        vcal.removeSubcomponent(vtimezones[i]);\n      }\n    }\n\n    //create any missing, but registered timezones\n    for (i in reqTzid) {\n      if (\n        reqTzid.hasOwnProperty(i) &&\n        !vtimezones[i] &&\n        ICAL.TimezoneService.has(i)\n      ) {\n        vcal.addSubcomponent(ICAL.TimezoneService.get(i).component);\n      }\n    }\n\n    return vcal;\n  },\n\n  /**\n   * Checks if the given type is of the number type and also NaN.\n   *\n   * @param {Number} number     The number to check\n   * @return {Boolean}          True, if the number is strictly NaN\n   */\n  isStrictlyNaN: function(number) {\n    return typeof(number) === 'number' && isNaN(number);\n  },\n\n  /**\n   * Parses a string value that is expected to be an integer, when the valid is\n   * not an integer throws a decoration error.\n   *\n   * @param {String} string     Raw string input\n   * @return {Number}           Parsed integer\n   */\n  strictParseInt: function(string) {\n    var result = parseInt(string, 10);\n\n    if (ICAL.helpers.isStrictlyNaN(result)) {\n      throw new Error(\n        'Could not extract integer from \"' + string + '\"'\n      );\n    }\n\n    return result;\n  },\n\n  /**\n   * Creates or returns a class instance of a given type with the initialization\n   * data if the data is not already an instance of the given type.\n   *\n   * @example\n   * var time = new ICAL.Time(...);\n   * var result = ICAL.helpers.formatClassType(time, ICAL.Time);\n   *\n   * (result instanceof ICAL.Time)\n   * // => true\n   *\n   * result = ICAL.helpers.formatClassType({}, ICAL.Time);\n   * (result isntanceof ICAL.Time)\n   * // => true\n   *\n   *\n   * @param {Object} data       object initialization data\n   * @param {Object} type       object type (like ICAL.Time)\n   * @return {?}                An instance of the found type.\n   */\n  formatClassType: function formatClassType(data, type) {\n    if (typeof(data) === 'undefined') {\n      return undefined;\n    }\n\n    if (data instanceof type) {\n      return data;\n    }\n    return new type(data);\n  },\n\n  /**\n   * Identical to indexOf but will only match values when they are not preceded\n   * by a backslash character.\n   *\n   * @param {String} buffer         String to search\n   * @param {String} search         Value to look for\n   * @param {Number} pos            Start position\n   * @return {Number}               The position, or -1 if not found\n   */\n  unescapedIndexOf: function(buffer, search, pos) {\n    while ((pos = buffer.indexOf(search, pos)) !== -1) {\n      if (pos > 0 && buffer[pos - 1] === '\\\\') {\n        pos += 1;\n      } else {\n        return pos;\n      }\n    }\n    return -1;\n  },\n\n  /**\n   * Find the index for insertion using binary search.\n   *\n   * @param {Array} list            The list to search\n   * @param {?} seekVal             The value to insert\n   * @param {function(?,?)} cmpfunc The comparison func, that can\n   *                                  compare two seekVals\n   * @return {Number}               The insert position\n   */\n  binsearchInsert: function(list, seekVal, cmpfunc) {\n    if (!list.length)\n      return 0;\n\n    var low = 0, high = list.length - 1,\n        mid, cmpval;\n\n    while (low <= high) {\n      mid = low + Math.floor((high - low) / 2);\n      cmpval = cmpfunc(seekVal, list[mid]);\n\n      if (cmpval < 0)\n        high = mid - 1;\n      else if (cmpval > 0)\n        low = mid + 1;\n      else\n        break;\n    }\n\n    if (cmpval < 0)\n      return mid; // insertion is displacing, so use mid outright.\n    else if (cmpval > 0)\n      return mid + 1;\n    else\n      return mid;\n  },\n\n  /**\n   * Convenience function for debug output\n   * @private\n   */\n  dumpn: /* istanbul ignore next */ function() {\n    if (!ICAL.debug) {\n      return;\n    }\n\n    if (typeof (console) !== 'undefined' && 'log' in console) {\n      ICAL.helpers.dumpn = function consoleDumpn(input) {\n        console.log(input);\n      };\n    } else {\n      ICAL.helpers.dumpn = function geckoDumpn(input) {\n        dump(input + '\\n');\n      };\n    }\n\n    ICAL.helpers.dumpn(arguments[0]);\n  },\n\n  /**\n   * Clone the passed object or primitive. By default a shallow clone will be\n   * executed.\n   *\n   * @param {*} aSrc            The thing to clone\n   * @param {Boolean=} aDeep    If true, a deep clone will be performed\n   * @return {*}                The copy of the thing\n   */\n  clone: function(aSrc, aDeep) {\n    if (!aSrc || typeof aSrc != \"object\") {\n      return aSrc;\n    } else if (aSrc instanceof Date) {\n      return new Date(aSrc.getTime());\n    } else if (\"clone\" in aSrc) {\n      return aSrc.clone();\n    } else if (Array.isArray(aSrc)) {\n      var arr = [];\n      for (var i = 0; i < aSrc.length; i++) {\n        arr.push(aDeep ? ICAL.helpers.clone(aSrc[i], true) : aSrc[i]);\n      }\n      return arr;\n    } else {\n      var obj = {};\n      for (var name in aSrc) {\n        // uses prototype method to allow use of Object.create(null);\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(aSrc, name)) {\n          if (aDeep) {\n            obj[name] = ICAL.helpers.clone(aSrc[name], true);\n          } else {\n            obj[name] = aSrc[name];\n          }\n        }\n      }\n      return obj;\n    }\n  },\n\n  /**\n   * Performs iCalendar line folding. A line ending character is inserted and\n   * the next line begins with a whitespace.\n   *\n   * @example\n   * SUMMARY:This line will be fold\n   *  ed right in the middle of a word.\n   *\n   * @param {String} aLine      The line to fold\n   * @return {String}           The folded line\n   */\n  foldline: function foldline(aLine) {\n    var result = \"\";\n    var line = aLine || \"\", pos = 0, line_length = 0;\n    //pos counts position in line for the UTF-16 presentation\n    //line_length counts the bytes for the UTF-8 presentation\n    while (line.length) {\n      var cp = line.codePointAt(pos);\n      if (cp < 128) ++line_length;\n      else if (cp < 2048) line_length += 2;//needs 2 UTF-8 bytes\n      else if (cp < 65536) line_length += 3;\n      else line_length += 4; //cp is less than 1114112\n      if (line_length < ICAL.foldLength + 1)\n        pos += cp > 65535 ? 2 : 1;\n      else {\n        result += ICAL.newLineChar + \" \" + line.substring(0, pos);\n        line = line.substring(pos);\n        pos = line_length = 0;\n      }\n    }\n    return result.substr(ICAL.newLineChar.length + 1);\n  },\n\n  /**\n   * Pads the given string or number with zeros so it will have at least two\n   * characters.\n   *\n   * @param {String|Number} data    The string or number to pad\n   * @return {String}               The number padded as a string\n   */\n  pad2: function pad(data) {\n    if (typeof(data) !== 'string') {\n      // handle fractions.\n      if (typeof(data) === 'number') {\n        data = parseInt(data);\n      }\n      data = String(data);\n    }\n\n    var len = data.length;\n\n    switch (len) {\n      case 0:\n        return '00';\n      case 1:\n        return '0' + data;\n      default:\n        return data;\n    }\n  },\n\n  /**\n   * Truncates the given number, correctly handling negative numbers.\n   *\n   * @param {Number} number     The number to truncate\n   * @return {Number}           The truncated number\n   */\n  trunc: function trunc(number) {\n    return (number < 0 ? Math.ceil(number) : Math.floor(number));\n  },\n\n  /**\n   * Poor-man's cross-browser inheritance for JavaScript. Doesn't support all\n   * the features, but enough for our usage.\n   *\n   * @param {Function} base     The base class constructor function.\n   * @param {Function} child    The child class constructor function.\n   * @param {Object} extra      Extends the prototype with extra properties\n   *                              and methods\n   */\n  inherits: function(base, child, extra) {\n    function F() {}\n    F.prototype = base.prototype;\n    child.prototype = new F();\n\n    if (extra) {\n      ICAL.helpers.extend(extra, child.prototype);\n    }\n  },\n\n  /**\n   * Poor-man's cross-browser object extension. Doesn't support all the\n   * features, but enough for our usage. Note that the target's properties are\n   * not overwritten with the source properties.\n   *\n   * @example\n   * var child = ICAL.helpers.extend(parent, {\n   *   \"bar\": 123\n   * });\n   *\n   * @param {Object} source     The object to extend\n   * @param {Object} target     The object to extend with\n   * @return {Object}           Returns the target.\n   */\n  extend: function(source, target) {\n    for (var key in source) {\n      var descr = Object.getOwnPropertyDescriptor(source, key);\n      if (descr && !Object.getOwnPropertyDescriptor(target, key)) {\n        Object.defineProperty(target, key, descr);\n      }\n    }\n    return target;\n  }\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/** @namespace ICAL */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.design = (function() {\n  'use strict';\n\n  var FROM_ICAL_NEWLINE = /\\\\\\\\|\\\\;|\\\\,|\\\\[Nn]/g;\n  var TO_ICAL_NEWLINE = /\\\\|;|,|\\n/g;\n  var FROM_VCARD_NEWLINE = /\\\\\\\\|\\\\,|\\\\[Nn]/g;\n  var TO_VCARD_NEWLINE = /\\\\|,|\\n/g;\n\n  function createTextType(fromNewline, toNewline) {\n    var result = {\n      matches: /.*/,\n\n      fromICAL: function(aValue, structuredEscape) {\n        return replaceNewline(aValue, fromNewline, structuredEscape);\n      },\n\n      toICAL: function(aValue, structuredEscape) {\n        var regEx = toNewline;\n        if (structuredEscape)\n          regEx = new RegExp(regEx.source + '|' + structuredEscape);\n        return aValue.replace(regEx, function(str) {\n          switch (str) {\n          case \"\\\\\":\n            return \"\\\\\\\\\";\n          case \";\":\n            return \"\\\\;\";\n          case \",\":\n            return \"\\\\,\";\n          case \"\\n\":\n            return \"\\\\n\";\n          /* istanbul ignore next */\n          default:\n            return str;\n          }\n        });\n      }\n    };\n    return result;\n  }\n\n  // default types used multiple times\n  var DEFAULT_TYPE_TEXT = { defaultType: \"text\" };\n  var DEFAULT_TYPE_TEXT_MULTI = { defaultType: \"text\", multiValue: \",\" };\n  var DEFAULT_TYPE_TEXT_STRUCTURED = { defaultType: \"text\", structuredValue: \";\" };\n  var DEFAULT_TYPE_INTEGER = { defaultType: \"integer\" };\n  var DEFAULT_TYPE_DATETIME_DATE = { defaultType: \"date-time\", allowedTypes: [\"date-time\", \"date\"] };\n  var DEFAULT_TYPE_DATETIME = { defaultType: \"date-time\" };\n  var DEFAULT_TYPE_URI = { defaultType: \"uri\" };\n  var DEFAULT_TYPE_UTCOFFSET = { defaultType: \"utc-offset\" };\n  var DEFAULT_TYPE_RECUR = { defaultType: \"recur\" };\n  var DEFAULT_TYPE_DATE_ANDOR_TIME = { defaultType: \"date-and-or-time\", allowedTypes: [\"date-time\", \"date\", \"text\"] };\n\n  function replaceNewlineReplace(string) {\n    switch (string) {\n      case \"\\\\\\\\\":\n        return \"\\\\\";\n      case \"\\\\;\":\n        return \";\";\n      case \"\\\\,\":\n        return \",\";\n      case \"\\\\n\":\n      case \"\\\\N\":\n        return \"\\n\";\n      /* istanbul ignore next */\n      default:\n        return string;\n    }\n  }\n\n  function replaceNewline(value, newline, structuredEscape) {\n    // avoid regex when possible.\n    if (value.indexOf('\\\\') === -1) {\n      return value;\n    }\n    if (structuredEscape)\n      newline = new RegExp(newline.source + '|\\\\\\\\' + structuredEscape);\n    return value.replace(newline, replaceNewlineReplace);\n  }\n\n  var commonProperties = {\n    \"categories\": DEFAULT_TYPE_TEXT_MULTI,\n    \"url\": DEFAULT_TYPE_URI,\n    \"version\": DEFAULT_TYPE_TEXT,\n    \"uid\": DEFAULT_TYPE_TEXT\n  };\n\n  var commonValues = {\n    \"boolean\": {\n      values: [\"TRUE\", \"FALSE\"],\n\n      fromICAL: function(aValue) {\n        switch (aValue) {\n          case 'TRUE':\n            return true;\n          case 'FALSE':\n            return false;\n          default:\n            //TODO: parser warning\n            return false;\n        }\n      },\n\n      toICAL: function(aValue) {\n        if (aValue) {\n          return 'TRUE';\n        }\n        return 'FALSE';\n      }\n\n    },\n    float: {\n      matches: /^[+-]?\\d+\\.\\d+$/,\n\n      fromICAL: function(aValue) {\n        var parsed = parseFloat(aValue);\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          // TODO: parser warning\n          return 0.0;\n        }\n        return parsed;\n      },\n\n      toICAL: function(aValue) {\n        return String(aValue);\n      }\n    },\n    integer: {\n      fromICAL: function(aValue) {\n        var parsed = parseInt(aValue);\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          return 0;\n        }\n        return parsed;\n      },\n\n      toICAL: function(aValue) {\n        return String(aValue);\n      }\n    },\n    \"utc-offset\": {\n      toICAL: function(aValue) {\n        if (aValue.length < 7) {\n          // no seconds\n          // -0500\n          return aValue.substr(0, 3) +\n                 aValue.substr(4, 2);\n        } else {\n          // seconds\n          // -050000\n          return aValue.substr(0, 3) +\n                 aValue.substr(4, 2) +\n                 aValue.substr(7, 2);\n        }\n      },\n\n      fromICAL: function(aValue) {\n        if (aValue.length < 6) {\n          // no seconds\n          // -05:00\n          return aValue.substr(0, 3) + ':' +\n                 aValue.substr(3, 2);\n        } else {\n          // seconds\n          // -05:00:00\n          return aValue.substr(0, 3) + ':' +\n                 aValue.substr(3, 2) + ':' +\n                 aValue.substr(5, 2);\n        }\n      },\n\n      decorate: function(aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    }\n  };\n\n  var icalParams = {\n    // Although the syntax is DQUOTE uri DQUOTE, I don't think we should\n    // enfoce anything aside from it being a valid content line.\n    //\n    // At least some params require - if multi values are used - DQUOTEs\n    // for each of its values - e.g. delegated-from=\"uri1\",\"uri2\"\n    // To indicate this, I introduced the new k/v pair\n    // multiValueSeparateDQuote: true\n    //\n    // \"ALTREP\": { ... },\n\n    // CN just wants a param-value\n    // \"CN\": { ... }\n\n    \"cutype\": {\n      values: [\"INDIVIDUAL\", \"GROUP\", \"RESOURCE\", \"ROOM\", \"UNKNOWN\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n\n    \"delegated-from\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"delegated-to\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    // \"DIR\": { ... }, // See ALTREP\n    \"encoding\": {\n      values: [\"8BIT\", \"BASE64\"]\n    },\n    // \"FMTTYPE\": { ... }, // See ALTREP\n    \"fbtype\": {\n      values: [\"FREE\", \"BUSY\", \"BUSY-UNAVAILABLE\", \"BUSY-TENTATIVE\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    // \"LANGUAGE\": { ... }, // See ALTREP\n    \"member\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"partstat\": {\n      // TODO These values are actually different per-component\n      values: [\"NEEDS-ACTION\", \"ACCEPTED\", \"DECLINED\", \"TENTATIVE\",\n               \"DELEGATED\", \"COMPLETED\", \"IN-PROCESS\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"range\": {\n      values: [\"THISANDFUTURE\"]\n    },\n    \"related\": {\n      values: [\"START\", \"END\"]\n    },\n    \"reltype\": {\n      values: [\"PARENT\", \"CHILD\", \"SIBLING\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"role\": {\n      values: [\"REQ-PARTICIPANT\", \"CHAIR\",\n               \"OPT-PARTICIPANT\", \"NON-PARTICIPANT\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"rsvp\": {\n      values: [\"TRUE\", \"FALSE\"]\n    },\n    \"sent-by\": {\n      valueType: \"cal-address\"\n    },\n    \"tzid\": {\n      matches: /^\\//\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"binary\", \"boolean\", \"cal-address\", \"date\", \"date-time\",\n               \"duration\", \"float\", \"integer\", \"period\", \"recur\", \"text\",\n               \"time\", \"uri\", \"utc-offset\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n\n  // When adding a value here, be sure to add it to the parameter types!\n  var icalValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),\n\n    uri: {\n      // TODO\n      /* ... */\n    },\n\n    \"binary\": {\n      decorate: function(aString) {\n        return ICAL.Binary.fromString(aString);\n      },\n\n      undecorate: function(aBinary) {\n        return aBinary.toString();\n      }\n    },\n    \"cal-address\": {\n      // needs to be an uri\n    },\n    \"date\": {\n      decorate: function(aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n\n      /**\n       * undecorates a time object.\n       */\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n\n      fromICAL: function(aValue) {\n        // from: 20120901\n        // to: 2012-09-01\n        if (!design.strict && aValue.length >= 15) {\n          // This is probably a date-time, e.g. 20120901T130000Z\n          return icalValues[\"date-time\"].fromICAL(aValue);\n        } else {\n          return aValue.substr(0, 4) + '-' +\n                 aValue.substr(4, 2) + '-' +\n                 aValue.substr(6, 2);\n        }\n      },\n\n      toICAL: function(aValue) {\n        // from: 2012-09-01\n        // to: 20120901\n        var len = aValue.length;\n\n        if (len == 10) {\n          return aValue.substr(0, 4) +\n                 aValue.substr(5, 2) +\n                 aValue.substr(8, 2);\n        } else if (len >= 19) {\n          return icalValues[\"date-time\"].toICAL(aValue);\n        } else {\n          //TODO: serialize warning?\n          return aValue;\n        }\n\n      }\n    },\n    \"date-time\": {\n      fromICAL: function(aValue) {\n        // from: 20120901T130000\n        // to: 2012-09-01T13:00:00\n        if (!design.strict && aValue.length == 8) {\n          // This is probably a date, e.g. 20120901\n          return icalValues.date.fromICAL(aValue);\n        } else {\n          var result = aValue.substr(0, 4) + '-' +\n                       aValue.substr(4, 2) + '-' +\n                       aValue.substr(6, 2) + 'T' +\n                       aValue.substr(9, 2) + ':' +\n                       aValue.substr(11, 2) + ':' +\n                       aValue.substr(13, 2);\n\n          if (aValue[15] && aValue[15] === 'Z') {\n            result += 'Z';\n          }\n\n          return result;\n        }\n      },\n\n      toICAL: function(aValue) {\n        // from: 2012-09-01T13:00:00\n        // to: 20120901T130000\n        var len = aValue.length;\n\n        if (len == 10 && !design.strict) {\n          return icalValues.date.toICAL(aValue);\n        } else if (len >= 19) {\n          var result = aValue.substr(0, 4) +\n                       aValue.substr(5, 2) +\n                       // grab the (DDTHH) segment\n                       aValue.substr(8, 5) +\n                       // MM\n                       aValue.substr(14, 2) +\n                       // SS\n                       aValue.substr(17, 2);\n\n          if (aValue[19] && aValue[19] === 'Z') {\n            result += 'Z';\n          }\n          return result;\n        } else {\n          // TODO: error\n          return aValue;\n        }\n      },\n\n      decorate: function(aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateTimeString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    },\n    duration: {\n      decorate: function(aValue) {\n        return ICAL.Duration.fromString(aValue);\n      },\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    },\n    period: {\n\n      fromICAL: function(string) {\n        var parts = string.split('/');\n        parts[0] = icalValues['date-time'].fromICAL(parts[0]);\n\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          parts[1] = icalValues['date-time'].fromICAL(parts[1]);\n        }\n\n        return parts;\n      },\n\n      toICAL: function(parts) {\n        if (!design.strict && parts[0].length == 10) {\n          parts[0] = icalValues.date.toICAL(parts[0]);\n        } else {\n          parts[0] = icalValues['date-time'].toICAL(parts[0]);\n        }\n\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          if (!design.strict && parts[1].length == 10) {\n            parts[1] = icalValues.date.toICAL(parts[1]);\n          } else {\n            parts[1] = icalValues['date-time'].toICAL(parts[1]);\n          }\n        }\n\n        return parts.join(\"/\");\n      },\n\n      decorate: function(aValue, aProp) {\n        return ICAL.Period.fromJSON(aValue, aProp, !design.strict);\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toJSON();\n      }\n    },\n    recur: {\n      fromICAL: function(string) {\n        return ICAL.Recur._stringToData(string, true);\n      },\n\n      toICAL: function(data) {\n        var str = \"\";\n        for (var k in data) {\n          /* istanbul ignore if */\n          if (!Object.prototype.hasOwnProperty.call(data, k)) {\n            continue;\n          }\n          var val = data[k];\n          if (k == \"until\") {\n            if (val.length > 10) {\n              val = icalValues['date-time'].toICAL(val);\n            } else {\n              val = icalValues.date.toICAL(val);\n            }\n          } else if (k == \"wkst\") {\n            if (typeof val === 'number') {\n              val = ICAL.Recur.numericDayToIcalDay(val);\n            }\n          } else if (Array.isArray(val)) {\n            val = val.join(\",\");\n          }\n          str += k.toUpperCase() + \"=\" + val + \";\";\n        }\n        return str.substr(0, str.length - 1);\n      },\n\n      decorate: function decorate(aValue) {\n        return ICAL.Recur.fromData(aValue);\n      },\n\n      undecorate: function(aRecur) {\n        return aRecur.toJSON();\n      }\n    },\n\n    time: {\n      fromICAL: function(aValue) {\n        // from: MMHHSS(Z)?\n        // to: HH:MM:SS(Z)?\n        if (aValue.length < 6) {\n          // TODO: parser exception?\n          return aValue;\n        }\n\n        // HH::MM::SSZ?\n        var result = aValue.substr(0, 2) + ':' +\n                     aValue.substr(2, 2) + ':' +\n                     aValue.substr(4, 2);\n\n        if (aValue[6] === 'Z') {\n          result += 'Z';\n        }\n\n        return result;\n      },\n\n      toICAL: function(aValue) {\n        // from: HH:MM:SS(Z)?\n        // to: MMHHSS(Z)?\n        if (aValue.length < 8) {\n          //TODO: error\n          return aValue;\n        }\n\n        var result = aValue.substr(0, 2) +\n                     aValue.substr(3, 2) +\n                     aValue.substr(6, 2);\n\n        if (aValue[8] === 'Z') {\n          result += 'Z';\n        }\n\n        return result;\n      }\n    }\n  });\n\n  var icalProperties = ICAL.helpers.extend(commonProperties, {\n\n    \"action\": DEFAULT_TYPE_TEXT,\n    \"attach\": { defaultType: \"uri\" },\n    \"attendee\": { defaultType: \"cal-address\" },\n    \"calscale\": DEFAULT_TYPE_TEXT,\n    \"class\": DEFAULT_TYPE_TEXT,\n    \"comment\": DEFAULT_TYPE_TEXT,\n    \"completed\": DEFAULT_TYPE_DATETIME,\n    \"contact\": DEFAULT_TYPE_TEXT,\n    \"created\": DEFAULT_TYPE_DATETIME,\n    \"description\": DEFAULT_TYPE_TEXT,\n    \"dtend\": DEFAULT_TYPE_DATETIME_DATE,\n    \"dtstamp\": DEFAULT_TYPE_DATETIME,\n    \"dtstart\": DEFAULT_TYPE_DATETIME_DATE,\n    \"due\": DEFAULT_TYPE_DATETIME_DATE,\n    \"duration\": { defaultType: \"duration\" },\n    \"exdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      multiValue: ','\n    },\n    \"exrule\": DEFAULT_TYPE_RECUR,\n    \"freebusy\": { defaultType: \"period\", multiValue: \",\" },\n    \"geo\": { defaultType: \"float\", structuredValue: \";\" },\n    \"last-modified\": DEFAULT_TYPE_DATETIME,\n    \"location\": DEFAULT_TYPE_TEXT,\n    \"method\": DEFAULT_TYPE_TEXT,\n    \"organizer\": { defaultType: \"cal-address\" },\n    \"percent-complete\": DEFAULT_TYPE_INTEGER,\n    \"priority\": DEFAULT_TYPE_INTEGER,\n    \"prodid\": DEFAULT_TYPE_TEXT,\n    \"related-to\": DEFAULT_TYPE_TEXT,\n    \"repeat\": DEFAULT_TYPE_INTEGER,\n    \"rdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\", \"period\"],\n      multiValue: ',',\n      detectType: function(string) {\n        if (string.indexOf('/') !== -1) {\n          return 'period';\n        }\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\n      }\n    },\n    \"recurrence-id\": DEFAULT_TYPE_DATETIME_DATE,\n    \"resources\": DEFAULT_TYPE_TEXT_MULTI,\n    \"request-status\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"rrule\": DEFAULT_TYPE_RECUR,\n    \"sequence\": DEFAULT_TYPE_INTEGER,\n    \"status\": DEFAULT_TYPE_TEXT,\n    \"summary\": DEFAULT_TYPE_TEXT,\n    \"transp\": DEFAULT_TYPE_TEXT,\n    \"trigger\": { defaultType: \"duration\", allowedTypes: [\"duration\", \"date-time\"] },\n    \"tzoffsetfrom\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzoffsetto\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzurl\": DEFAULT_TYPE_URI,\n    \"tzid\": DEFAULT_TYPE_TEXT,\n    \"tzname\": DEFAULT_TYPE_TEXT\n  });\n\n  // When adding a value here, be sure to add it to the parameter types!\n  var vcardValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n    uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n\n    date: {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date\");\n      },\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function(aValue) {\n        if (aValue.length == 8) {\n          return icalValues.date.fromICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 6) {\n          return aValue.substr(0, 4) + '-' + aValue.substr(4);\n        } else {\n          return aValue;\n        }\n      },\n      toICAL: function(aValue) {\n        if (aValue.length == 10) {\n          return icalValues.date.toICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 7) {\n          return aValue.substr(0, 4) + aValue.substr(5);\n        } else {\n          return aValue;\n        }\n      }\n    },\n\n    time: {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(\"T\" + aValue, \"time\");\n      },\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function(aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue, true);\n        var zone = splitzone[0], value = splitzone[1];\n\n        //console.log(\"SPLIT: \",splitzone);\n\n        if (value.length == 6) {\n          value = value.substr(0, 2) + ':' +\n                  value.substr(2, 2) + ':' +\n                  value.substr(4, 2);\n        } else if (value.length == 4 && value[0] != '-') {\n          value = value.substr(0, 2) + ':' + value.substr(2, 2);\n        } else if (value.length == 5) {\n          value = value.substr(0, 3) + ':' + value.substr(3, 2);\n        }\n\n        if (zone.length == 5 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + ':' + zone.substr(3);\n        }\n\n        return value + zone;\n      },\n\n      toICAL: function(aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue);\n        var zone = splitzone[0], value = splitzone[1];\n\n        if (value.length == 8) {\n          value = value.substr(0, 2) +\n                  value.substr(3, 2) +\n                  value.substr(6, 2);\n        } else if (value.length == 5 && value[0] != '-') {\n          value = value.substr(0, 2) + value.substr(3, 2);\n        } else if (value.length == 6) {\n          value = value.substr(0, 3) + value.substr(4, 2);\n        }\n\n        if (zone.length == 6 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + zone.substr(4);\n        }\n\n        return value + zone;\n      },\n\n      _splitZone: function(aValue, isFromIcal) {\n        var lastChar = aValue.length - 1;\n        var signChar = aValue.length - (isFromIcal ? 5 : 6);\n        var sign = aValue[signChar];\n        var zone, value;\n\n        if (aValue[lastChar] == 'Z') {\n          zone = aValue[lastChar];\n          value = aValue.substr(0, lastChar);\n        } else if (aValue.length > 6 && (sign == '-' || sign == '+')) {\n          zone = aValue.substr(signChar);\n          value = aValue.substr(0, signChar);\n        } else {\n          zone = \"\";\n          value = aValue;\n        }\n\n        return [zone, value];\n      }\n    },\n\n    \"date-time\": {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-time\");\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n\n      fromICAL: function(aValue) {\n        return vcardValues['date-and-or-time'].fromICAL(aValue);\n      },\n\n      toICAL: function(aValue) {\n        return vcardValues['date-and-or-time'].toICAL(aValue);\n      }\n    },\n\n    \"date-and-or-time\": {\n      decorate: function(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-and-or-time\");\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      },\n\n      fromICAL: function(aValue) {\n        var parts = aValue.split('T');\n        return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : '') +\n               (parts[1] ? 'T' + vcardValues.time.fromICAL(parts[1]) : '');\n      },\n\n      toICAL: function(aValue) {\n        var parts = aValue.split('T');\n        return vcardValues.date.toICAL(parts[0]) +\n               (parts[1] ? 'T' + vcardValues.time.toICAL(parts[1]) : '');\n\n      }\n    },\n    timestamp: icalValues['date-time'],\n    \"language-tag\": {\n      matches: /^[a-zA-Z0-9-]+$/ // Could go with a more strict regex here\n    }\n  });\n\n  var vcardParams = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"time\", \"date-time\", \"date-and-or-time\",\n               \"timestamp\", \"boolean\", \"integer\", \"float\", \"utc-offset\",\n               \"language-tag\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n\n  var vcardProperties = ICAL.helpers.extend(commonProperties, {\n    \"adr\": { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    \"anniversary\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"bday\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"caladruri\": DEFAULT_TYPE_URI,\n    \"caluri\": DEFAULT_TYPE_URI,\n    \"clientpidmap\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"email\": DEFAULT_TYPE_TEXT,\n    \"fburl\": DEFAULT_TYPE_URI,\n    \"fn\": DEFAULT_TYPE_TEXT,\n    \"gender\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"geo\": DEFAULT_TYPE_URI,\n    \"impp\": DEFAULT_TYPE_URI,\n    \"key\": DEFAULT_TYPE_URI,\n    \"kind\": DEFAULT_TYPE_TEXT,\n    \"lang\": { defaultType: \"language-tag\" },\n    \"logo\": DEFAULT_TYPE_URI,\n    \"member\": DEFAULT_TYPE_URI,\n    \"n\": { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    \"nickname\": DEFAULT_TYPE_TEXT_MULTI,\n    \"note\": DEFAULT_TYPE_TEXT,\n    \"org\": { defaultType: \"text\", structuredValue: \";\" },\n    \"photo\": DEFAULT_TYPE_URI,\n    \"related\": DEFAULT_TYPE_URI,\n    \"rev\": { defaultType: \"timestamp\" },\n    \"role\": DEFAULT_TYPE_TEXT,\n    \"sound\": DEFAULT_TYPE_URI,\n    \"source\": DEFAULT_TYPE_URI,\n    \"tel\": { defaultType: \"uri\", allowedTypes: [\"uri\", \"text\"] },\n    \"title\": DEFAULT_TYPE_TEXT,\n    \"tz\": { defaultType: \"text\", allowedTypes: [\"text\", \"utc-offset\", \"uri\"] },\n    \"xml\": DEFAULT_TYPE_TEXT\n  });\n\n  var vcard3Values = ICAL.helpers.extend(commonValues, {\n    binary: icalValues.binary,\n    date: vcardValues.date,\n    \"date-time\": vcardValues[\"date-time\"],\n    \"phone-number\": {\n      // TODO\n      /* ... */\n    },\n    uri: icalValues.uri,\n    text: icalValues.text,\n    time: icalValues.time,\n    vcard: icalValues.text,\n    \"utc-offset\": {\n      toICAL: function(aValue) {\n        return aValue.substr(0, 7);\n      },\n\n      fromICAL: function(aValue) {\n        return aValue.substr(0, 7);\n      },\n\n      decorate: function(aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n\n      undecorate: function(aValue) {\n        return aValue.toString();\n      }\n    }\n  });\n\n  var vcard3Params = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"date-time\", \"phone-number\", \"time\",\n               \"boolean\", \"integer\", \"float\", \"utc-offset\", \"vcard\", \"binary\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n\n  var vcard3Properties = ICAL.helpers.extend(commonProperties, {\n    fn: DEFAULT_TYPE_TEXT,\n    n: { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    nickname: DEFAULT_TYPE_TEXT_MULTI,\n    photo: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\n    bday: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function(string) {\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\n      }\n    },\n\n    adr: { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\n    label: DEFAULT_TYPE_TEXT,\n\n    tel: { defaultType: \"phone-number\" },\n    email: DEFAULT_TYPE_TEXT,\n    mailer: DEFAULT_TYPE_TEXT,\n\n    tz: { defaultType: \"utc-offset\", allowedTypes: [\"utc-offset\", \"text\"] },\n    geo: { defaultType: \"float\", structuredValue: \";\" },\n\n    title: DEFAULT_TYPE_TEXT,\n    role: DEFAULT_TYPE_TEXT,\n    logo: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\n    agent: { defaultType: \"vcard\", allowedTypes: [\"vcard\", \"text\", \"uri\"] },\n    org: DEFAULT_TYPE_TEXT_STRUCTURED,\n\n    note: DEFAULT_TYPE_TEXT_MULTI,\n    prodid: DEFAULT_TYPE_TEXT,\n    rev: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function(string) {\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\n      }\n    },\n    \"sort-string\": DEFAULT_TYPE_TEXT,\n    sound: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\n\n    class: DEFAULT_TYPE_TEXT,\n    key: { defaultType: \"binary\", allowedTypes: [\"binary\", \"text\"] }\n  });\n\n  /**\n   * iCalendar design set\n   * @type {ICAL.design.designSet}\n   */\n  var icalSet = {\n    value: icalValues,\n    param: icalParams,\n    property: icalProperties\n  };\n\n  /**\n   * vCard 4.0 design set\n   * @type {ICAL.design.designSet}\n   */\n  var vcardSet = {\n    value: vcardValues,\n    param: vcardParams,\n    property: vcardProperties\n  };\n\n  /**\n   * vCard 3.0 design set\n   * @type {ICAL.design.designSet}\n   */\n  var vcard3Set = {\n    value: vcard3Values,\n    param: vcard3Params,\n    property: vcard3Properties\n  };\n\n  /**\n   * The design data, used by the parser to determine types for properties and\n   * other metadata needed to produce correct jCard/jCal data.\n   *\n   * @alias ICAL.design\n   * @namespace\n   */\n  var design = {\n    /**\n     * A designSet describes value, parameter and property data. It is used by\n     * ther parser and stringifier in components and properties to determine they\n     * should be represented.\n     *\n     * @typedef {Object} designSet\n     * @memberOf ICAL.design\n     * @property {Object} value       Definitions for value types, keys are type names\n     * @property {Object} param       Definitions for params, keys are param names\n     * @property {Object} property    Defintions for properties, keys are property names\n     */\n\n    /**\n     * Can be set to false to make the parser more lenient.\n     */\n    strict: true,\n\n    /**\n     * The default set for new properties and components if none is specified.\n     * @type {ICAL.design.designSet}\n     */\n    defaultSet: icalSet,\n\n    /**\n     * The default type for unknown properties\n     * @type {String}\n     */\n    defaultType: 'unknown',\n\n    /**\n     * Holds the design set for known top-level components\n     *\n     * @type {Object}\n     * @property {ICAL.design.designSet} vcard       vCard VCARD\n     * @property {ICAL.design.designSet} vevent      iCalendar VEVENT\n     * @property {ICAL.design.designSet} vtodo       iCalendar VTODO\n     * @property {ICAL.design.designSet} vjournal    iCalendar VJOURNAL\n     * @property {ICAL.design.designSet} valarm      iCalendar VALARM\n     * @property {ICAL.design.designSet} vtimezone   iCalendar VTIMEZONE\n     * @property {ICAL.design.designSet} daylight    iCalendar DAYLIGHT\n     * @property {ICAL.design.designSet} standard    iCalendar STANDARD\n     *\n     * @example\n     * var propertyName = 'fn';\n     * var componentDesign = ICAL.design.components.vcard;\n     * var propertyDetails = componentDesign.property[propertyName];\n     * if (propertyDetails.defaultType == 'text') {\n     *   // Yep, sure is...\n     * }\n     */\n    components: {\n      vcard: vcardSet,\n      vcard3: vcard3Set,\n      vevent: icalSet,\n      vtodo: icalSet,\n      vjournal: icalSet,\n      valarm: icalSet,\n      vtimezone: icalSet,\n      daylight: icalSet,\n      standard: icalSet\n    },\n\n\n    /**\n     * The design set for iCalendar (rfc5545/rfc7265) components.\n     * @type {ICAL.design.designSet}\n     */\n    icalendar: icalSet,\n\n    /**\n     * The design set for vCard (rfc6350/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */\n    vcard: vcardSet,\n\n    /**\n     * The design set for vCard (rfc2425/rfc2426/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */\n    vcard3: vcard3Set,\n\n    /**\n     * Gets the design set for the given component name.\n     *\n     * @param {String} componentName        The name of the component\n     * @return {ICAL.design.designSet}      The design set for the component\n     */\n    getDesignSet: function(componentName) {\n      var isInDesign = componentName && componentName in design.components;\n      return isInDesign ? design.components[componentName] : design.defaultSet;\n    }\n  };\n\n  return design;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * Contains various functions to convert jCal and jCard data back into\n * iCalendar and vCard.\n * @namespace\n */\nICAL.stringify = (function() {\n  'use strict';\n\n  var LINE_ENDING = '\\r\\n';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n\n  /**\n   * Convert a full jCal/jCard array into a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify\n   * @variation function\n   * @param {Array} jCal    The jCal/jCard document\n   * @return {String}       The stringified iCalendar/vCard document\n   */\n  function stringify(jCal) {\n    if (typeof jCal[0] == \"string\") {\n      // This is a single component\n      jCal = [jCal];\n    }\n\n    var i = 0;\n    var len = jCal.length;\n    var result = '';\n\n    for (; i < len; i++) {\n      result += stringify.component(jCal[i]) + LINE_ENDING;\n    }\n\n    return result;\n  }\n\n  /**\n   * Converts an jCal component array into a ICAL string.\n   * Recursive will resolve sub-components.\n   *\n   * Exact component/property order is not saved all\n   * properties will come before subcomponents.\n   *\n   * @function ICAL.stringify.component\n   * @param {Array} component\n   *        jCal/jCard fragment of a component\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this component\n   * @return {String}       The iCalendar/vCard string\n   */\n  stringify.component = function(component, designSet) {\n    var name = component[0].toUpperCase();\n    var result = 'BEGIN:' + name + LINE_ENDING;\n\n    var props = component[1];\n    var propIdx = 0;\n    var propLen = props.length;\n\n    var designSetName = component[0];\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n    if (designSetName === 'vcard' && component[1].length > 0 &&\n            !(component[1][0][0] === \"version\" && component[1][0][3] === \"4.0\")) {\n      designSetName = \"vcard3\";\n    }\n    designSet = designSet || design.getDesignSet(designSetName);\n\n    for (; propIdx < propLen; propIdx++) {\n      result += stringify.property(props[propIdx], designSet) + LINE_ENDING;\n    }\n\n    // Ignore subcomponents if none exist, e.g. in vCard.\n    var comps = component[2] || [];\n    var compIdx = 0;\n    var compLen = comps.length;\n\n    for (; compIdx < compLen; compIdx++) {\n      result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;\n    }\n\n    result += 'END:' + name;\n    return result;\n  };\n\n  /**\n   * Converts a single jCal/jCard property to a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify.property\n   * @param {Array} property\n   *        jCal/jCard property array\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   * @param {Boolean} noFold\n   *        If true, the line is not folded\n   * @return {String}       The iCalendar/vCard string\n   */\n  stringify.property = function(property, designSet, noFold) {\n    var name = property[0].toUpperCase();\n    var jsName = property[0];\n    var params = property[1];\n\n    var line = name;\n\n    var paramName;\n    for (paramName in params) {\n      var value = params[paramName];\n\n      /* istanbul ignore else */\n      if (params.hasOwnProperty(paramName)) {\n        var multiValue = (paramName in designSet.param) && designSet.param[paramName].multiValue;\n        if (multiValue && Array.isArray(value)) {\n          if (designSet.param[paramName].multiValueSeparateDQuote) {\n            multiValue = '\"' + multiValue + '\"';\n          }\n          value = value.map(stringify._rfc6868Unescape);\n          value = stringify.multiValue(value, multiValue, \"unknown\", null, designSet);\n        } else {\n          value = stringify._rfc6868Unescape(value);\n        }\n\n\n        line += ';' + paramName.toUpperCase();\n        line += '=' + stringify.propertyValue(value);\n      }\n    }\n\n    if (property.length === 3) {\n      // If there are no values, we must assume a blank value\n      return line + ':';\n    }\n\n    var valueType = property[2];\n\n    if (!designSet) {\n      designSet = design.defaultSet;\n    }\n\n    var propDetails;\n    var multiValue = false;\n    var structuredValue = false;\n    var isDefault = false;\n\n    if (jsName in designSet.property) {\n      propDetails = designSet.property[jsName];\n\n      if ('multiValue' in propDetails) {\n        multiValue = propDetails.multiValue;\n      }\n\n      if (('structuredValue' in propDetails) && Array.isArray(property[3])) {\n        structuredValue = propDetails.structuredValue;\n      }\n\n      if ('defaultType' in propDetails) {\n        if (valueType === propDetails.defaultType) {\n          isDefault = true;\n        }\n      } else {\n        if (valueType === DEFAULT_VALUE_TYPE) {\n          isDefault = true;\n        }\n      }\n    } else {\n      if (valueType === DEFAULT_VALUE_TYPE) {\n        isDefault = true;\n      }\n    }\n\n    // push the VALUE property if type is not the default\n    // for the current property.\n    if (!isDefault) {\n      // value will never contain ;/:/, so we don't escape it here.\n      line += ';VALUE=' + valueType.toUpperCase();\n    }\n\n    line += ':';\n\n    if (multiValue && structuredValue) {\n      line += stringify.multiValue(\n        property[3], structuredValue, valueType, multiValue, designSet, structuredValue\n      );\n    } else if (multiValue) {\n      line += stringify.multiValue(\n        property.slice(3), multiValue, valueType, null, designSet, false\n      );\n    } else if (structuredValue) {\n      line += stringify.multiValue(\n        property[3], structuredValue, valueType, null, designSet, structuredValue\n      );\n    } else {\n      line += stringify.value(property[3], valueType, designSet, false);\n    }\n\n    return noFold ? line : ICAL.helpers.foldline(line);\n  };\n\n  /**\n   * Handles escaping of property values that may contain:\n   *\n   *    COLON (:), SEMICOLON (;), or COMMA (,)\n   *\n   * If any of the above are present the result is wrapped\n   * in double quotes.\n   *\n   * @function ICAL.stringify.propertyValue\n   * @param {String} value      Raw property value\n   * @return {String}           Given or escaped value when needed\n   */\n  stringify.propertyValue = function(value) {\n\n    if ((helpers.unescapedIndexOf(value, ',') === -1) &&\n        (helpers.unescapedIndexOf(value, ':') === -1) &&\n        (helpers.unescapedIndexOf(value, ';') === -1)) {\n\n      return value;\n    }\n\n    return '\"' + value + '\"';\n  };\n\n  /**\n   * Converts an array of ical values into a single\n   * string based on a type and a delimiter value (like \",\").\n   *\n   * @function ICAL.stringify.multiValue\n   * @param {Array} values      List of values to convert\n   * @param {String} delim      Used to join the values (\",\", \";\", \":\")\n   * @param {String} type       Lowecase ical value type\n   *        (like boolean, date-time, etc..)\n   * @param {?String} innerMulti If set, each value will again be processed\n   *        Used for structured values\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   *\n   * @return {String}           iCalendar/vCard string for value\n   */\n  stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {\n    var result = '';\n    var len = values.length;\n    var i = 0;\n\n    for (; i < len; i++) {\n      if (innerMulti && Array.isArray(values[i])) {\n        result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);\n      } else {\n        result += stringify.value(values[i], type, designSet, structuredValue);\n      }\n\n      if (i !== (len - 1)) {\n        result += delim;\n      }\n    }\n\n    return result;\n  };\n\n  /**\n   * Processes a single ical value runs the associated \"toICAL\" method from the\n   * design value type if available to convert the value.\n   *\n   * @function ICAL.stringify.value\n   * @param {String|Number} value       A formatted value\n   * @param {String} type               Lowercase iCalendar/vCard value type\n   *  (like boolean, date-time, etc..)\n   * @return {String}                   iCalendar/vCard value for single value\n   */\n  stringify.value = function(value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'toICAL' in designSet.value[type]) {\n      return designSet.value[type].toICAL(value, structuredValue);\n    }\n    return value;\n  };\n\n  /**\n   * Internal helper for rfc6868. Exposing this on ICAL.stringify so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @param {String} val        The value to unescape\n   * @return {String}           The escaped value\n   */\n  stringify._rfc6868Unescape = function(val) {\n    return val.replace(/[\\n^\"]/g, function(x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n  var RFC6868_REPLACE_MAP = { '\"': \"^'\", \"\\n\": \"^n\", \"^\": \"^^\" };\n\n  return stringify;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * Contains various functions to parse iCalendar and vCard data.\n * @namespace\n */\nICAL.parse = (function() {\n  'use strict';\n\n  var CHAR = /[^ \\t]/;\n  var MULTIVALUE_DELIMITER = ',';\n  var VALUE_DELIMITER = ':';\n  var PARAM_DELIMITER = ';';\n  var PARAM_NAME_DELIMITER = '=';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n  var DEFAULT_PARAM_TYPE = 'text';\n\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n\n  /**\n   * An error that occurred during parsing.\n   *\n   * @param {String} message        The error message\n   * @memberof ICAL.parse\n   * @extends {Error}\n   * @class\n   */\n  function ParserError(message) {\n    this.message = message;\n    this.name = 'ParserError';\n\n    try {\n      throw new Error();\n    } catch (e) {\n      if (e.stack) {\n        var split = e.stack.split('\\n');\n        split.shift();\n        this.stack = split.join('\\n');\n      }\n    }\n  }\n\n  ParserError.prototype = Error.prototype;\n\n  /**\n   * Parses iCalendar or vCard data into a raw jCal object. Consult\n   * documentation on the {@tutorial layers|layers of parsing} for more\n   * details.\n   *\n   * @function ICAL.parse\n   * @variation function\n   * @todo Fix the API to be more clear on the return type\n   * @param {String} input      The string data to parse\n   * @return {Object|Object[]}  A single jCal object, or an array thereof\n   */\n  function parser(input) {\n    var state = {};\n    var root = state.component = [];\n\n    state.stack = [root];\n\n    parser._eachLine(input, function(err, line) {\n      parser._handleContentLine(line, state);\n    });\n\n\n    // when there are still items on the stack\n    // throw a fatal error, a component was not closed\n    // correctly in that case.\n    if (state.stack.length > 1) {\n      throw new ParserError(\n        'invalid ical body. component began but did not end'\n      );\n    }\n\n    state = null;\n\n    return (root.length == 1 ? root[0] : root);\n  }\n\n  /**\n   * Parse an iCalendar property value into the jCal for a single property\n   *\n   * @function ICAL.parse.property\n   * @param {String} str\n   *   The iCalendar property string to parse\n   * @param {ICAL.design.designSet=} designSet\n   *   The design data to use for this property\n   * @return {Object}\n   *   The jCal Object containing the property\n   */\n  parser.property = function(str, designSet) {\n    var state = {\n      component: [[], []],\n      designSet: designSet || design.defaultSet\n    };\n    parser._handleContentLine(str, state);\n    return state.component[1][0];\n  };\n\n  /**\n   * Convenience method to parse a component. You can use ICAL.parse() directly\n   * instead.\n   *\n   * @function ICAL.parse.component\n   * @see ICAL.parse(function)\n   * @param {String} str    The iCalendar component string to parse\n   * @return {Object}       The jCal Object containing the component\n   */\n  parser.component = function(str) {\n    return parser(str);\n  };\n\n  // classes & constants\n  parser.ParserError = ParserError;\n\n  /**\n   * The state for parsing content lines from an iCalendar/vCard string.\n   *\n   * @private\n   * @memberof ICAL.parse\n   * @typedef {Object} parserState\n   * @property {ICAL.design.designSet} designSet    The design set to use for parsing\n   * @property {ICAL.Component[]} stack             The stack of components being processed\n   * @property {ICAL.Component} component           The currently active component\n   */\n\n\n  /**\n   * Handles a single line of iCalendar/vCard, updating the state.\n   *\n   * @private\n   * @function ICAL.parse._handleContentLine\n   * @param {String} line               The content line to process\n   * @param {ICAL.parse.parserState}    The current state of the line parsing\n   */\n  parser._handleContentLine = function(line, state) {\n    // break up the parts of the line\n    var valuePos = line.indexOf(VALUE_DELIMITER);\n    var paramPos = line.indexOf(PARAM_DELIMITER);\n\n    var lastParamIndex;\n    var lastValuePos;\n\n    // name of property or begin/end\n    var name;\n    var value;\n    // params is only overridden if paramPos !== -1.\n    // we can't do params = params || {} later on\n    // because it sacrifices ops.\n    var params = {};\n\n    /**\n     * Different property cases\n     *\n     *\n     * 1. RRULE:FREQ=foo\n     *    // FREQ= is not a param but the value\n     *\n     * 2. ATTENDEE;ROLE=REQ-PARTICIPANT;\n     *    // ROLE= is a param because : has not happened yet\n     */\n      // when the parameter delimiter is after the\n      // value delimiter then it is not a parameter.\n\n    if ((paramPos !== -1 && valuePos !== -1)) {\n      // when the parameter delimiter is after the\n      // value delimiter then it is not a parameter.\n      if (paramPos > valuePos) {\n        paramPos = -1;\n      }\n    }\n\n    var parsedParams;\n    if (paramPos !== -1) {\n      name = line.substring(0, paramPos).toLowerCase();\n      parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);\n      if (parsedParams[2] == -1) {\n        throw new ParserError(\"Invalid parameters in '\" + line + \"'\");\n      }\n      params = parsedParams[0];\n      lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;\n      if ((lastValuePos =\n        line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {\n        value = line.substring(lastParamIndex + lastValuePos + 1);\n      } else {\n        throw new ParserError(\"Missing parameter value in '\" + line + \"'\");\n      }\n    } else if (valuePos !== -1) {\n      // without parmeters (BEGIN:VCAENDAR, CLASS:PUBLIC)\n      name = line.substring(0, valuePos).toLowerCase();\n      value = line.substring(valuePos + 1);\n\n      if (name === 'begin') {\n        var newComponent = [value.toLowerCase(), [], []];\n        if (state.stack.length === 1) {\n          state.component.push(newComponent);\n        } else {\n          state.component[2].push(newComponent);\n        }\n        state.stack.push(state.component);\n        state.component = newComponent;\n        if (!state.designSet) {\n          state.designSet = design.getDesignSet(state.component[0]);\n        }\n        return;\n      } else if (name === 'end') {\n        state.component = state.stack.pop();\n        return;\n      }\n      // If it is not begin/end, then this is a property with an empty value,\n      // which should be considered valid.\n    } else {\n      /**\n       * Invalid line.\n       * The rational to throw an error is we will\n       * never be certain that the rest of the file\n       * is sane and it is unlikely that we can serialize\n       * the result correctly either.\n       */\n      throw new ParserError(\n        'invalid line (no token \";\" or \":\") \"' + line + '\"'\n      );\n    }\n\n    var valueType;\n    var multiValue = false;\n    var structuredValue = false;\n    var propertyDetails;\n\n    if (name in state.designSet.property) {\n      propertyDetails = state.designSet.property[name];\n\n      if ('multiValue' in propertyDetails) {\n        multiValue = propertyDetails.multiValue;\n      }\n\n      if ('structuredValue' in propertyDetails) {\n        structuredValue = propertyDetails.structuredValue;\n      }\n\n      if (value && 'detectType' in propertyDetails) {\n        valueType = propertyDetails.detectType(value);\n      }\n    }\n\n    // attempt to determine value\n    if (!valueType) {\n      if (!('value' in params)) {\n        if (propertyDetails) {\n          valueType = propertyDetails.defaultType;\n        } else {\n          valueType = DEFAULT_VALUE_TYPE;\n        }\n      } else {\n        // possible to avoid this?\n        valueType = params.value.toLowerCase();\n      }\n    }\n\n    delete params.value;\n\n    /**\n     * Note on `var result` juggling:\n     *\n     * I observed that building the array in pieces has adverse\n     * effects on performance, so where possible we inline the creation.\n     * It is a little ugly but resulted in ~2000 additional ops/sec.\n     */\n\n    var result;\n    if (multiValue && structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else if (multiValue) {\n      result = [name, params, valueType];\n      parser._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);\n    } else if (structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else {\n      value = parser._parseValue(value, valueType, state.designSet, false);\n      result = [name, params, valueType, value];\n    }\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n    if (state.component[0] === 'vcard' && state.component[1].length === 0 &&\n            !(name === 'version' && value === '4.0')) {\n      state.designSet = design.getDesignSet(\"vcard3\");\n    }\n    state.component[1].push(result);\n  };\n\n  /**\n   * Parse a value from the raw value into the jCard/jCal value.\n   *\n   * @private\n   * @function ICAL.parse._parseValue\n   * @param {String} value          Original value\n   * @param {String} type           Type of value\n   * @param {Object} designSet      The design data to use for this value\n   * @return {Object} varies on type\n   */\n  parser._parseValue = function(value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'fromICAL' in designSet.value[type]) {\n      return designSet.value[type].fromICAL(value, structuredValue);\n    }\n    return value;\n  };\n\n  /**\n   * Parse parameters from a string to object.\n   *\n   * @function ICAL.parse._parseParameters\n   * @private\n   * @param {String} line           A single unfolded line\n   * @param {Numeric} start         Position to start looking for properties\n   * @param {Object} designSet      The design data to use for this property\n   * @return {Object} key/value pairs\n   */\n  parser._parseParameters = function(line, start, designSet) {\n    var lastParam = start;\n    var pos = 0;\n    var delim = PARAM_NAME_DELIMITER;\n    var result = {};\n    var name, lcname;\n    var value, valuePos = -1;\n    var type, multiValue, mvdelim;\n\n    // find the next '=' sign\n    // use lastParam and pos to find name\n    // check if \" is used if so get value from \"->\"\n    // then increment pos to find next ;\n\n    while ((pos !== false) &&\n           (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {\n\n      name = line.substr(lastParam + 1, pos - lastParam - 1);\n      if (name.length == 0) {\n        throw new ParserError(\"Empty parameter name in '\" + line + \"'\");\n      }\n      lcname = name.toLowerCase();\n      mvdelim = false;\n      multiValue = false;\n\n      if (lcname in designSet.param && designSet.param[lcname].valueType) {\n        type = designSet.param[lcname].valueType;\n      } else {\n        type = DEFAULT_PARAM_TYPE;\n      }\n\n      if (lcname in designSet.param) {\n        multiValue = designSet.param[lcname].multiValue;\n        if (designSet.param[lcname].multiValueSeparateDQuote) {\n          mvdelim = parser._rfc6868Escape('\"' + multiValue + '\"');\n        }\n      }\n\n      var nextChar = line[pos + 1];\n      if (nextChar === '\"') {\n        valuePos = pos + 2;\n        pos = helpers.unescapedIndexOf(line, '\"', valuePos);\n        if (multiValue && pos != -1) {\n            var extendedValue = true;\n            while (extendedValue) {\n              if (line[pos + 1] == multiValue && line[pos + 2] == '\"') {\n                pos = helpers.unescapedIndexOf(line, '\"', pos + 3);\n              } else {\n                extendedValue = false;\n              }\n            }\n          }\n        if (pos === -1) {\n          throw new ParserError(\n            'invalid line (no matching double quote) \"' + line + '\"'\n          );\n        }\n        value = line.substr(valuePos, pos - valuePos);\n        lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);\n        if (lastParam === -1) {\n          pos = false;\n        }\n      } else {\n        valuePos = pos + 1;\n\n        // move to next \";\"\n        var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);\n        var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);\n        if (propValuePos !== -1 && nextPos > propValuePos) {\n          // this is a delimiter in the property value, let's stop here\n          nextPos = propValuePos;\n          pos = false;\n        } else if (nextPos === -1) {\n          // no \";\"\n          if (propValuePos === -1) {\n            nextPos = line.length;\n          } else {\n            nextPos = propValuePos;\n          }\n          pos = false;\n        } else {\n          lastParam = nextPos;\n          pos = nextPos;\n        }\n\n        value = line.substr(valuePos, nextPos - valuePos);\n      }\n\n      value = parser._rfc6868Escape(value);\n      if (multiValue) {\n        var delimiter = mvdelim || multiValue;\n        value = parser._parseMultiValue(value, delimiter, type, [], null, designSet);\n      } else {\n        value = parser._parseValue(value, type, designSet);\n      }\n\n      if (multiValue && (lcname in result)) {\n        if (Array.isArray(result[lcname])) {\n          result[lcname].push(value);\n        } else {\n          result[lcname] = [\n            result[lcname],\n            value\n          ];\n        }\n      } else {\n        result[lcname] = value;\n      }\n    }\n    return [result, value, valuePos];\n  };\n\n  /**\n   * Internal helper for rfc6868. Exposing this on ICAL.parse so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @function ICAL.parse._rfc6868Escape\n   * @param {String} val        The value to escape\n   * @return {String}           The escaped value\n   */\n  parser._rfc6868Escape = function(val) {\n    return val.replace(/\\^['n^]/g, function(x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n  var RFC6868_REPLACE_MAP = { \"^'\": '\"', \"^n\": \"\\n\", \"^^\": \"^\" };\n\n  /**\n   * Parse a multi value string. This function is used either for parsing\n   * actual multi-value property's values, or for handling parameter values. It\n   * can be used for both multi-value properties and structured value properties.\n   *\n   * @private\n   * @function ICAL.parse._parseMultiValue\n   * @param {String} buffer     The buffer containing the full value\n   * @param {String} delim      The multi-value delimiter\n   * @param {String} type       The value type to be parsed\n   * @param {Array.<?>} result        The array to append results to, varies on value type\n   * @param {String} innerMulti The inner delimiter to split each value with\n   * @param {ICAL.design.designSet} designSet   The design data for this value\n   * @return {?|Array.<?>}            Either an array of results, or the first result\n   */\n  parser._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {\n    var pos = 0;\n    var lastPos = 0;\n    var value;\n    if (delim.length === 0) {\n      return buffer;\n    }\n\n    // split each piece\n    while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {\n      value = buffer.substr(lastPos, pos - lastPos);\n      if (innerMulti) {\n        value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n      } else {\n        value = parser._parseValue(value, type, designSet, structuredValue);\n      }\n      result.push(value);\n      lastPos = pos + delim.length;\n    }\n\n    // on the last piece take the rest of string\n    value = buffer.substr(lastPos);\n    if (innerMulti) {\n      value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n    } else {\n      value = parser._parseValue(value, type, designSet, structuredValue);\n    }\n    result.push(value);\n\n    return result.length == 1 ? result[0] : result;\n  };\n\n  /**\n   * Process a complete buffer of iCalendar/vCard data line by line, correctly\n   * unfolding content. Each line will be processed with the given callback\n   *\n   * @private\n   * @function ICAL.parse._eachLine\n   * @param {String} buffer                         The buffer to process\n   * @param {function(?String, String)} callback    The callback for each line\n   */\n  parser._eachLine = function(buffer, callback) {\n    var len = buffer.length;\n    var lastPos = buffer.search(CHAR);\n    var pos = lastPos;\n    var line;\n    var firstChar;\n\n    var newlineOffset;\n\n    do {\n      pos = buffer.indexOf('\\n', lastPos) + 1;\n\n      if (pos > 1 && buffer[pos - 2] === '\\r') {\n        newlineOffset = 2;\n      } else {\n        newlineOffset = 1;\n      }\n\n      if (pos === 0) {\n        pos = len;\n        newlineOffset = 0;\n      }\n\n      firstChar = buffer[lastPos];\n\n      if (firstChar === ' ' || firstChar === '\\t') {\n        // add to line\n        line += buffer.substr(\n          lastPos + 1,\n          pos - lastPos - (newlineOffset + 1)\n        );\n      } else {\n        if (line)\n          callback(null, line);\n        // push line\n        line = buffer.substr(\n          lastPos,\n          pos - lastPos - newlineOffset\n        );\n      }\n\n      lastPos = pos;\n    } while (pos !== len);\n\n    // extra ending line\n    line = line.trim();\n\n    if (line.length)\n      callback(null, line);\n  };\n\n  return parser;\n\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Component = (function() {\n  'use strict';\n\n  var PROPERTY_INDEX = 1;\n  var COMPONENT_INDEX = 2;\n  var NAME_INDEX = 0;\n\n  /**\n   * @classdesc\n   * Wraps a jCal component, adding convenience methods to add, remove and\n   * update subcomponents and properties.\n   *\n   * @class\n   * @alias ICAL.Component\n   * @param {Array|String} jCal         Raw jCal component data OR name of new\n   *                                      component\n   * @param {ICAL.Component} parent     Parent component to associate\n   */\n  function Component(jCal, parent) {\n    if (typeof(jCal) === 'string') {\n      // jCal spec (name, properties, components)\n      jCal = [jCal, [], []];\n    }\n\n    // mostly for legacy reasons.\n    this.jCal = jCal;\n\n    this.parent = parent || null;\n  }\n\n  Component.prototype = {\n    /**\n     * Hydrated properties are inserted into the _properties array at the same\n     * position as in the jCal array, so it is possible that the array contains\n     * undefined values for unhydrdated properties. To avoid iterating the\n     * array when checking if all properties have been hydrated, we save the\n     * count here.\n     *\n     * @type {Number}\n     * @private\n     */\n    _hydratedPropertyCount: 0,\n\n    /**\n     * The same count as for _hydratedPropertyCount, but for subcomponents\n     *\n     * @type {Number}\n     * @private\n     */\n    _hydratedComponentCount: 0,\n\n    /**\n     * The name of this component\n     * @readonly\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n\n    /**\n     * The design set for this component, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */\n    get _designSet() {\n      var parentDesign = this.parent && this.parent._designSet;\n      return parentDesign || ICAL.design.getDesignSet(this.name);\n    },\n\n    _hydrateComponent: function(index) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n\n      if (this._components[index]) {\n        return this._components[index];\n      }\n\n      var comp = new Component(\n        this.jCal[COMPONENT_INDEX][index],\n        this\n      );\n\n      this._hydratedComponentCount++;\n      return (this._components[index] = comp);\n    },\n\n    _hydrateProperty: function(index) {\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n\n      if (this._properties[index]) {\n        return this._properties[index];\n      }\n\n      var prop = new ICAL.Property(\n        this.jCal[PROPERTY_INDEX][index],\n        this\n      );\n\n      this._hydratedPropertyCount++;\n      return (this._properties[index] = prop);\n    },\n\n    /**\n     * Finds first sub component, optionally filtered by name.\n     *\n     * @param {String=} name        Optional name to filter by\n     * @return {?ICAL.Component}     The found subcomponent\n     */\n    getFirstSubcomponent: function(name) {\n      if (name) {\n        var i = 0;\n        var comps = this.jCal[COMPONENT_INDEX];\n        var len = comps.length;\n\n        for (; i < len; i++) {\n          if (comps[i][NAME_INDEX] === name) {\n            var result = this._hydrateComponent(i);\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[COMPONENT_INDEX].length) {\n          return this._hydrateComponent(0);\n        }\n      }\n\n      // ensure we return a value (strict mode)\n      return null;\n    },\n\n    /**\n     * Finds all sub components, optionally filtering by name.\n     *\n     * @param {String=} name            Optional name to filter by\n     * @return {ICAL.Component[]}       The found sub components\n     */\n    getAllSubcomponents: function(name) {\n      var jCalLen = this.jCal[COMPONENT_INDEX].length;\n      var i = 0;\n\n      if (name) {\n        var comps = this.jCal[COMPONENT_INDEX];\n        var result = [];\n\n        for (; i < jCalLen; i++) {\n          if (name === comps[i][NAME_INDEX]) {\n            result.push(\n              this._hydrateComponent(i)\n            );\n          }\n        }\n        return result;\n      } else {\n        if (!this._components ||\n            (this._hydratedComponentCount !== jCalLen)) {\n          for (; i < jCalLen; i++) {\n            this._hydrateComponent(i);\n          }\n        }\n\n        return this._components || [];\n      }\n    },\n\n    /**\n     * Returns true when a named property exists.\n     *\n     * @param {String} name     The property name\n     * @return {Boolean}        True, when property is found\n     */\n    hasProperty: function(name) {\n      var props = this.jCal[PROPERTY_INDEX];\n      var len = props.length;\n\n      var i = 0;\n      for (; i < len; i++) {\n        // 0 is property name\n        if (props[i][NAME_INDEX] === name) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Finds the first property, optionally with the given name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {?ICAL.Property}     The found property\n     */\n    getFirstProperty: function(name) {\n      if (name) {\n        var i = 0;\n        var props = this.jCal[PROPERTY_INDEX];\n        var len = props.length;\n\n        for (; i < len; i++) {\n          if (props[i][NAME_INDEX] === name) {\n            var result = this._hydrateProperty(i);\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[PROPERTY_INDEX].length) {\n          return this._hydrateProperty(0);\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Returns first property's value, if available.\n     *\n     * @param {String=} name    Lowercase property name\n     * @return {?String}        The found property value.\n     */\n    getFirstPropertyValue: function(name) {\n      var prop = this.getFirstProperty(name);\n      if (prop) {\n        return prop.getFirstValue();\n      }\n\n      return null;\n    },\n\n    /**\n     * Get all properties in the component, optionally filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {ICAL.Property[]}    List of properties\n     */\n    getAllProperties: function(name) {\n      var jCalLen = this.jCal[PROPERTY_INDEX].length;\n      var i = 0;\n\n      if (name) {\n        var props = this.jCal[PROPERTY_INDEX];\n        var result = [];\n\n        for (; i < jCalLen; i++) {\n          if (name === props[i][NAME_INDEX]) {\n            result.push(\n              this._hydrateProperty(i)\n            );\n          }\n        }\n        return result;\n      } else {\n        if (!this._properties ||\n            (this._hydratedPropertyCount !== jCalLen)) {\n          for (; i < jCalLen; i++) {\n            this._hydrateProperty(i);\n          }\n        }\n\n        return this._properties || [];\n      }\n    },\n\n    _removeObjectByIndex: function(jCalIndex, cache, index) {\n      cache = cache || [];\n      // remove cached version\n      if (cache[index]) {\n        var obj = cache[index];\n        if (\"parent\" in obj) {\n            obj.parent = null;\n        }\n      }\n\n      cache.splice(index, 1);\n\n      // remove it from the jCal\n      this.jCal[jCalIndex].splice(index, 1);\n    },\n\n    _removeObject: function(jCalIndex, cache, nameOrObject) {\n      var i = 0;\n      var objects = this.jCal[jCalIndex];\n      var len = objects.length;\n      var cached = this[cache];\n\n      if (typeof(nameOrObject) === 'string') {\n        for (; i < len; i++) {\n          if (objects[i][NAME_INDEX] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n            return true;\n          }\n        }\n      } else if (cached) {\n        for (; i < len; i++) {\n          if (cached[i] && cached[i] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n\n    _removeAllObjects: function(jCalIndex, cache, name) {\n      var cached = this[cache];\n\n      // Unfortunately we have to run through all children to reset their\n      // parent property.\n      var objects = this.jCal[jCalIndex];\n      var i = objects.length - 1;\n\n      // descending search required because splice\n      // is used and will effect the indices.\n      for (; i >= 0; i--) {\n        if (!name || objects[i][NAME_INDEX] === name) {\n          this._removeObjectByIndex(jCalIndex, cached, i);\n        }\n      }\n    },\n\n    /**\n     * Adds a single sub component.\n     *\n     * @param {ICAL.Component} component        The component to add\n     * @return {ICAL.Component}                 The passed in component\n     */\n    addSubcomponent: function(component) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n\n      if (component.parent) {\n        component.parent.removeSubcomponent(component);\n      }\n\n      var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);\n      this._components[idx - 1] = component;\n      this._hydratedComponentCount++;\n      component.parent = this;\n      return component;\n    },\n\n    /**\n     * Removes a single component by name or the instance of a specific\n     * component.\n     *\n     * @param {ICAL.Component|String} nameOrComp    Name of component, or component\n     * @return {Boolean}                            True when comp is removed\n     */\n    removeSubcomponent: function(nameOrComp) {\n      var removed = this._removeObject(COMPONENT_INDEX, '_components', nameOrComp);\n      if (removed) {\n        this._hydratedComponentCount--;\n      }\n      return removed;\n    },\n\n    /**\n     * Removes all components or (if given) all components by a particular\n     * name.\n     *\n     * @param {String=} name            Lowercase component name\n     */\n    removeAllSubcomponents: function(name) {\n      var removed = this._removeAllObjects(COMPONENT_INDEX, '_components', name);\n      this._hydratedComponentCount = 0;\n      return removed;\n    },\n\n    /**\n     * Adds an {@link ICAL.Property} to the component.\n     *\n     * @param {ICAL.Property} property      The property to add\n     * @return {ICAL.Property}              The passed in property\n     */\n    addProperty: function(property) {\n      if (!(property instanceof ICAL.Property)) {\n        throw new TypeError('must instance of ICAL.Property');\n      }\n\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n\n      if (property.parent) {\n        property.parent.removeProperty(property);\n      }\n\n      var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);\n      this._properties[idx - 1] = property;\n      this._hydratedPropertyCount++;\n      property.parent = this;\n      return property;\n    },\n\n    /**\n     * Helper method to add a property with a value to the component.\n     *\n     * @param {String}               name         Property name to add\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */\n    addPropertyWithValue: function(name, value) {\n      var prop = new ICAL.Property(name);\n      prop.setValue(value);\n\n      this.addProperty(prop);\n\n      return prop;\n    },\n\n    /**\n     * Helper method that will update or create a property of the given name\n     * and sets its value. If multiple properties with the given name exist,\n     * only the first is updated.\n     *\n     * @param {String}               name         Property name to update\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */\n    updatePropertyWithValue: function(name, value) {\n      var prop = this.getFirstProperty(name);\n\n      if (prop) {\n        prop.setValue(value);\n      } else {\n        prop = this.addPropertyWithValue(name, value);\n      }\n\n      return prop;\n    },\n\n    /**\n     * Removes a single property by name or the instance of the specific\n     * property.\n     *\n     * @param {String|ICAL.Property} nameOrProp     Property name or instance to remove\n     * @return {Boolean}                            True, when deleted\n     */\n    removeProperty: function(nameOrProp) {\n      var removed = this._removeObject(PROPERTY_INDEX, '_properties', nameOrProp);\n      if (removed) {\n        this._hydratedPropertyCount--;\n      }\n      return removed;\n    },\n\n    /**\n     * Removes all properties associated with this component, optionally\n     * filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {Boolean}            True, when deleted\n     */\n    removeAllProperties: function(name) {\n      var removed = this._removeAllObjects(PROPERTY_INDEX, '_properties', name);\n      this._hydratedPropertyCount = 0;\n      return removed;\n    },\n\n    /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return this.jCal;\n    },\n\n    /**\n     * The string representation of this component.\n     * @return {String}\n     */\n    toString: function() {\n      return ICAL.stringify.component(\n        this.jCal, this._designSet\n      );\n    }\n  };\n\n  /**\n   * Create an {@link ICAL.Component} by parsing the passed iCalendar string.\n   *\n   * @param {String} str        The iCalendar string to parse\n   */\n  Component.fromString = function(str) {\n    return new Component(ICAL.parse.component(str));\n  };\n\n  return Component;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Property = (function() {\n  'use strict';\n\n  var NAME_INDEX = 0;\n  var PROP_INDEX = 1;\n  var TYPE_INDEX = 2;\n  var VALUE_INDEX = 3;\n\n  var design = ICAL.design;\n\n  /**\n   * @classdesc\n   * Provides a layer on top of the raw jCal object for manipulating a single\n   * property, with its parameters and value.\n   *\n   * @description\n   * It is important to note that mutations done in the wrapper\n   * directly mutate the jCal object used to initialize.\n   *\n   * Can also be used to create new properties by passing\n   * the name of the property (as a String).\n   *\n   * @class\n   * @alias ICAL.Property\n   * @param {Array|String} jCal         Raw jCal representation OR\n   *  the new name of the property\n   *\n   * @param {ICAL.Component=} parent    Parent component\n   */\n  function Property(jCal, parent) {\n    this._parent = parent || null;\n\n    if (typeof(jCal) === 'string') {\n      // We are creating the property by name and need to detect the type\n      this.jCal = [jCal, {}, design.defaultType];\n      this.jCal[TYPE_INDEX] = this.getDefaultType();\n    } else {\n      this.jCal = jCal;\n    }\n    this._updateType();\n  }\n\n  Property.prototype = {\n\n    /**\n     * The value type for this property\n     * @readonly\n     * @type {String}\n     */\n    get type() {\n      return this.jCal[TYPE_INDEX];\n    },\n\n    /**\n     * The name of this property, in lowercase.\n     * @readonly\n     * @type {String}\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n\n    /**\n     * The parent component for this property.\n     * @type {ICAL.Component}\n     */\n    get parent() {\n      return this._parent;\n    },\n\n    set parent(p) {\n      // Before setting the parent, check if the design set has changed. If it\n      // has, we later need to update the type if it was unknown before.\n      var designSetChanged = !this._parent || (p && p._designSet != this._parent._designSet);\n\n      this._parent = p;\n\n      if (this.type == design.defaultType && designSetChanged) {\n        this.jCal[TYPE_INDEX] = this.getDefaultType();\n        this._updateType();\n      }\n\n      return p;\n    },\n\n    /**\n     * The design set for this property, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */\n    get _designSet() {\n      return this.parent ? this.parent._designSet : design.defaultSet;\n    },\n\n    /**\n     * Updates the type metadata from the current jCal type and design set.\n     *\n     * @private\n     */\n    _updateType: function() {\n      var designSet = this._designSet;\n\n      if (this.type in designSet.value) {\n        var designType = designSet.value[this.type];\n\n        if ('decorate' in designSet.value[this.type]) {\n          this.isDecorated = true;\n        } else {\n          this.isDecorated = false;\n        }\n\n        if (this.name in designSet.property) {\n          this.isMultiValue = ('multiValue' in designSet.property[this.name]);\n          this.isStructuredValue = ('structuredValue' in designSet.property[this.name]);\n        }\n      }\n    },\n\n    /**\n     * Hydrate a single value. The act of hydrating means turning the raw jCal\n     * value into a potentially wrapped object, for example {@link ICAL.Time}.\n     *\n     * @private\n     * @param {Number} index        The index of the value to hydrate\n     * @return {Object}             The decorated value.\n     */\n    _hydrateValue: function(index) {\n      if (this._values && this._values[index]) {\n        return this._values[index];\n      }\n\n      // for the case where there is no value.\n      if (this.jCal.length <= (VALUE_INDEX + index)) {\n        return null;\n      }\n\n      if (this.isDecorated) {\n        if (!this._values) {\n          this._values = [];\n        }\n        return (this._values[index] = this._decorate(\n          this.jCal[VALUE_INDEX + index]\n        ));\n      } else {\n        return this.jCal[VALUE_INDEX + index];\n      }\n    },\n\n    /**\n     * Decorate a single value, returning its wrapped object. This is used by\n     * the hydrate function to actually wrap the value.\n     *\n     * @private\n     * @param {?} value         The value to decorate\n     * @return {Object}         The decorated value\n     */\n    _decorate: function(value) {\n      return this._designSet.value[this.type].decorate(value, this);\n    },\n\n    /**\n     * Undecorate a single value, returning its raw jCal data.\n     *\n     * @private\n     * @param {Object} value         The value to undecorate\n     * @return {?}                   The undecorated value\n     */\n    _undecorate: function(value) {\n      return this._designSet.value[this.type].undecorate(value, this);\n    },\n\n    /**\n     * Sets the value at the given index while also hydrating it. The passed\n     * value can either be a decorated or undecorated value.\n     *\n     * @private\n     * @param {?} value             The value to set\n     * @param {Number} index        The index to set it at\n     */\n    _setDecoratedValue: function(value, index) {\n      if (!this._values) {\n        this._values = [];\n      }\n\n      if (typeof(value) === 'object' && 'icaltype' in value) {\n        // decorated value\n        this.jCal[VALUE_INDEX + index] = this._undecorate(value);\n        this._values[index] = value;\n      } else {\n        // undecorated value\n        this.jCal[VALUE_INDEX + index] = value;\n        this._values[index] = this._decorate(value);\n      }\n    },\n\n    /**\n     * Gets a parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {Array|String}        Parameter value\n     */\n    getParameter: function(name) {\n      if (name in this.jCal[PROP_INDEX]) {\n        return this.jCal[PROP_INDEX][name];\n      } else {\n        return undefined;\n      }\n    },\n\n    /**\n     * Gets first parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {String}        Parameter value\n     */\n    getFirstParameter: function(name) {\n      var parameters = this.getParameter(name);\n\n      if (Array.isArray(parameters)) {\n        return parameters[0];\n      }\n\n      return parameters;\n    },\n\n    /**\n     * Sets a parameter on the property.\n     *\n     * @param {String}       name     The parameter name\n     * @param {Array|String} value    The parameter value\n     */\n    setParameter: function(name, value) {\n      var lcname = name.toLowerCase();\n      if (typeof value === \"string\" &&\n          lcname in this._designSet.param &&\n          'multiValue' in this._designSet.param[lcname]) {\n          value = [value];\n      }\n      this.jCal[PROP_INDEX][name] = value;\n    },\n\n    /**\n     * Removes a parameter\n     *\n     * @param {String} name     The parameter name\n     */\n    removeParameter: function(name) {\n      delete this.jCal[PROP_INDEX][name];\n    },\n\n    /**\n     * Get the default type based on this property's name.\n     *\n     * @return {String}     The default type for this property\n     */\n    getDefaultType: function() {\n      var name = this.jCal[NAME_INDEX];\n      var designSet = this._designSet;\n\n      if (name in designSet.property) {\n        var details = designSet.property[name];\n        if ('defaultType' in details) {\n          return details.defaultType;\n        }\n      }\n      return design.defaultType;\n    },\n\n    /**\n     * Sets type of property and clears out any existing values of the current\n     * type.\n     *\n     * @param {String} type     New iCAL type (see design.*.values)\n     */\n    resetType: function(type) {\n      this.removeAllValues();\n      this.jCal[TYPE_INDEX] = type;\n      this._updateType();\n    },\n\n    /**\n     * Finds the first property value.\n     *\n     * @return {String}         First property value\n     */\n    getFirstValue: function() {\n      return this._hydrateValue(0);\n    },\n\n    /**\n     * Gets all values on the property.\n     *\n     * NOTE: this creates an array during each call.\n     *\n     * @return {Array}          List of values\n     */\n    getValues: function() {\n      var len = this.jCal.length - VALUE_INDEX;\n\n      if (len < 1) {\n        // it is possible for a property to have no value.\n        return [];\n      }\n\n      var i = 0;\n      var result = [];\n\n      for (; i < len; i++) {\n        result[i] = this._hydrateValue(i);\n      }\n\n      return result;\n    },\n\n    /**\n     * Removes all values from this property\n     */\n    removeAllValues: function() {\n      if (this._values) {\n        this._values.length = 0;\n      }\n      this.jCal.length = 3;\n    },\n\n    /**\n     * Sets the values of the property.  Will overwrite the existing values.\n     * This can only be used for multi-value properties.\n     *\n     * @param {Array} values    An array of values\n     */\n    setValues: function(values) {\n      if (!this.isMultiValue) {\n        throw new Error(\n          this.name + ': does not not support mulitValue.\\n' +\n          'override isMultiValue'\n        );\n      }\n\n      var len = values.length;\n      var i = 0;\n      this.removeAllValues();\n\n      if (len > 0 &&\n          typeof(values[0]) === 'object' &&\n          'icaltype' in values[0]) {\n        this.resetType(values[0].icaltype);\n      }\n\n      if (this.isDecorated) {\n        for (; i < len; i++) {\n          this._setDecoratedValue(values[i], i);\n        }\n      } else {\n        for (; i < len; i++) {\n          this.jCal[VALUE_INDEX + i] = values[i];\n        }\n      }\n    },\n\n    /**\n     * Sets the current value of the property. If this is a multi-value\n     * property, all other values will be removed.\n     *\n     * @param {String|Object} value     New property value.\n     */\n    setValue: function(value) {\n      this.removeAllValues();\n      if (typeof(value) === 'object' && 'icaltype' in value) {\n        this.resetType(value.icaltype);\n      }\n\n      if (this.isDecorated) {\n        this._setDecoratedValue(value, 0);\n      } else {\n        this.jCal[VALUE_INDEX] = value;\n      }\n    },\n\n    /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return this.jCal;\n    },\n\n    /**\n     * The string representation of this component.\n     * @return {String}\n     */\n    toICALString: function() {\n      return ICAL.stringify.property(\n        this.jCal, this._designSet, true\n      );\n    }\n  };\n\n  /**\n   * Create an {@link ICAL.Property} by parsing the passed iCalendar string.\n   *\n   * @param {String} str                        The iCalendar string to parse\n   * @param {ICAL.design.designSet=} designSet  The design data to use for this property\n   * @return {ICAL.Property}                    The created iCalendar property\n   */\n  Property.fromString = function(str, designSet) {\n    return new Property(ICAL.parse.property(str, designSet));\n  };\n\n  return Property;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.UtcOffset = (function() {\n\n  /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.UtcOffset\n   * @param {Object} aData          An object with members of the utc offset\n   * @param {Number=} aData.hours   The hours for the utc offset\n   * @param {Number=} aData.minutes The minutes in the utc offset\n   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n   */\n  function UtcOffset(aData) {\n    this.fromData(aData);\n  }\n\n  UtcOffset.prototype = {\n\n    /**\n     * The hours in the utc-offset\n     * @type {Number}\n     */\n    hours: 0,\n\n    /**\n     * The minutes in the utc-offset\n     * @type {Number}\n     */\n    minutes: 0,\n\n    /**\n     * The sign of the utc offset, 1 for positive offset, -1 for negative\n     * offsets.\n     * @type {Number}\n     */\n    factor: 1,\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"utc-offset\"\n     */\n    icaltype: \"utc-offset\",\n\n    /**\n     * Returns a clone of the utc offset object.\n     *\n     * @return {ICAL.UtcOffset}     The cloned object\n     */\n    clone: function() {\n      return ICAL.UtcOffset.fromSeconds(this.toSeconds());\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData          An object with members of the utc offset\n     * @param {Number=} aData.hours   The hours for the utc offset\n     * @param {Number=} aData.minutes The minutes in the utc offset\n     * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n     */\n    fromData: function(aData) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (aData.hasOwnProperty(key)) {\n            this[key] = aData[key];\n          }\n        }\n      }\n      this._normalize();\n    },\n\n    /**\n     * Sets up the current instance from the given seconds value. The seconds\n     * value is truncated to the minute. Offsets are wrapped when the world\n     * ends, the hour after UTC+14:00 is UTC-12:00.\n     *\n     * @param {Number} aSeconds         The seconds to convert into an offset\n     */\n    fromSeconds: function(aSeconds) {\n      var secs = Math.abs(aSeconds);\n\n      this.factor = aSeconds < 0 ? -1 : 1;\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n\n      secs -= (this.hours * 3600);\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      return this;\n    },\n\n    /**\n     * Convert the current offset to a value in seconds\n     *\n     * @return {Number}                 The offset in seconds\n     */\n    toSeconds: function() {\n      return this.factor * (60 * this.minutes + 3600 * this.hours);\n    },\n\n    /**\n     * Compare this utc offset with another one.\n     *\n     * @param {ICAL.UtcOffset} other        The other offset to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toSeconds();\n      var b = other.toSeconds();\n      return (a > b) - (b > a);\n    },\n\n    _normalize: function() {\n      // Range: 97200 seconds (with 1 hour inbetween)\n      var secs = this.toSeconds();\n      var factor = this.factor;\n      while (secs < -43200) { // = UTC-12:00\n        secs += 97200;\n      }\n      while (secs > 50400) { // = UTC+14:00\n        secs -= 97200;\n      }\n\n      this.fromSeconds(secs);\n\n      // Avoid changing the factor when on zero seconds\n      if (secs == 0) {\n        this.factor = factor;\n      }\n    },\n\n    /**\n     * The iCalendar string representation of this utc-offset.\n     * @return {String}\n     */\n    toICALString: function() {\n      return ICAL.design.icalendar.value['utc-offset'].toICAL(this.toString());\n    },\n\n    /**\n     * The string representation of this utc-offset.\n     * @return {String}\n     */\n    toString: function toString() {\n      return (this.factor == 1 ? \"+\" : \"-\") +\n              ICAL.helpers.pad2(this.hours) + ':' +\n              ICAL.helpers.pad2(this.minutes);\n    }\n  };\n\n  /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed string.\n   *\n   * @param {String} aString    The string to parse\n   * @return {ICAL.Duration}    The created utc-offset instance\n   */\n  UtcOffset.fromString = function(aString) {\n    // -05:00\n    var options = {};\n    //TODO: support seconds per rfc5545 ?\n    options.factor = (aString[0] === '+') ? 1 : -1;\n    options.hours = ICAL.helpers.strictParseInt(aString.substr(1, 2));\n    options.minutes = ICAL.helpers.strictParseInt(aString.substr(4, 2));\n\n    return new ICAL.UtcOffset(options);\n  };\n\n  /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed seconds\n   * value.\n   *\n   * @param {Number} aSeconds       The number of seconds to convert\n   */\n  UtcOffset.fromSeconds = function(aSeconds) {\n    var instance = new UtcOffset();\n    instance.fromSeconds(aSeconds);\n    return instance;\n  };\n\n  return UtcOffset;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Binary = (function() {\n\n  /**\n   * @classdesc\n   * Represents the BINARY value type, which contains extra methods for\n   * encoding and decoding.\n   *\n   * @class\n   * @alias ICAL.Binary\n   * @param {String} aValue     The binary data for this value\n   */\n  function Binary(aValue) {\n    this.value = aValue;\n  }\n\n  Binary.prototype = {\n    /**\n     * The type name, to be used in the jCal object.\n     * @default \"binary\"\n     * @constant\n     */\n    icaltype: \"binary\",\n\n    /**\n     * Base64 decode the current value\n     *\n     * @return {String}         The base64-decoded value\n     */\n    decodeValue: function decodeValue() {\n      return this._b64_decode(this.value);\n    },\n\n    /**\n     * Encodes the passed parameter with base64 and sets the internal\n     * value to the result.\n     *\n     * @param {String} aValue      The raw binary value to encode\n     */\n    setEncodedValue: function setEncodedValue(aValue) {\n      this.value = this._b64_encode(aValue);\n    },\n\n    _b64_encode: function base64_encode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Bayron Guevara\n      // +   improved by: Thunder.m\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   improved by: Rafa Kukawski (http://kukawski.pl)\n      // *     example 1: base64_encode('Kevin van Zonneveld');\n      // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['atob'] == 'function') {\n      //    return atob(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n                \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n        ac = 0,\n        enc = \"\",\n        tmp_arr = [];\n\n      if (!data) {\n        return data;\n      }\n\n      do { // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1 << 16 | o2 << 8 | o3;\n\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n      } while (i < data.length);\n\n      enc = tmp_arr.join('');\n\n      var r = data.length % 3;\n\n      return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);\n\n    },\n\n    _b64_decode: function base64_decode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Thunder.m\n      // +      input by: Aman Gupta\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Onno Marsman\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +      input by: Brett Zamir (http://brett-zamir.me)\n      // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');\n      // *     returns 1: 'Kevin van Zonneveld'\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['btoa'] == 'function') {\n      //    return btoa(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n                \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n        ac = 0,\n        dec = \"\",\n        tmp_arr = [];\n\n      if (!data) {\n        return data;\n      }\n\n      data += '';\n\n      do { // unpack four hexets into three octets using index points in b64\n        h1 = b64.indexOf(data.charAt(i++));\n        h2 = b64.indexOf(data.charAt(i++));\n        h3 = b64.indexOf(data.charAt(i++));\n        h4 = b64.indexOf(data.charAt(i++));\n\n        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n\n        o1 = bits >> 16 & 0xff;\n        o2 = bits >> 8 & 0xff;\n        o3 = bits & 0xff;\n\n        if (h3 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1);\n        } else if (h4 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2);\n        } else {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);\n        }\n      } while (i < data.length);\n\n      dec = tmp_arr.join('');\n\n      return dec;\n    },\n\n    /**\n     * The string representation of this value\n     * @return {String}\n     */\n    toString: function() {\n      return this.value;\n    }\n  };\n\n  /**\n   * Creates a binary value from the given string.\n   *\n   * @param {String} aString        The binary value string\n   * @return {ICAL.Binary}          The binary value instance\n   */\n  Binary.fromString = function(aString) {\n    return new Binary(aString);\n  };\n\n  return Binary;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n  /**\n   * @classdesc\n   * This class represents the \"period\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @description\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @class\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   */\n  ICAL.Period = function icalperiod(aData) {\n    this.wrappedJSObject = this;\n\n    if (aData && 'start' in aData) {\n      if (aData.start && !(aData.start instanceof ICAL.Time)) {\n        throw new TypeError('.start must be an instance of ICAL.Time');\n      }\n      this.start = aData.start;\n    }\n\n    if (aData && aData.end && aData.duration) {\n      throw new Error('cannot accept both end and duration');\n    }\n\n    if (aData && 'end' in aData) {\n      if (aData.end && !(aData.end instanceof ICAL.Time)) {\n        throw new TypeError('.end must be an instance of ICAL.Time');\n      }\n      this.end = aData.end;\n    }\n\n    if (aData && 'duration' in aData) {\n      if (aData.duration && !(aData.duration instanceof ICAL.Duration)) {\n        throw new TypeError('.duration must be an instance of ICAL.Duration');\n      }\n      this.duration = aData.duration;\n    }\n  };\n\n  ICAL.Period.prototype = {\n\n    /**\n     * The start of the period\n     * @type {ICAL.Time}\n     */\n    start: null,\n\n    /**\n     * The end of the period\n     * @type {ICAL.Time}\n     */\n    end: null,\n\n    /**\n     * The duration of the period\n     * @type {ICAL.Duration}\n     */\n    duration: null,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalperiod\"\n     */\n    icalclass: \"icalperiod\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"period\"\n     */\n    icaltype: \"period\",\n\n    /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Period}      The cloned object\n     */\n    clone: function() {\n      return ICAL.Period.fromData({\n        start: this.start ? this.start.clone() : null,\n        end: this.end ? this.end.clone() : null,\n        duration: this.duration ? this.duration.clone() : null\n      });\n    },\n\n    /**\n     * Calculates the duration of the period, either directly or by subtracting\n     * start from end date.\n     *\n     * @return {ICAL.Duration}      The calculated duration\n     */\n    getDuration: function duration() {\n      if (this.duration) {\n        return this.duration;\n      } else {\n        return this.end.subtractDate(this.start);\n      }\n    },\n\n    /**\n     * Calculates the end date of the period, either directly or by adding\n     * duration to start date.\n     *\n     * @return {ICAL.Time}          The calculated end date\n     */\n    getEnd: function() {\n      if (this.end) {\n        return this.end;\n      } else {\n        var end = this.start.clone();\n        end.addDuration(this.duration);\n        return end;\n      }\n    },\n\n    /**\n     * The string representation of this period.\n     * @return {String}\n     */\n    toString: function toString() {\n      return this.start + \"/\" + (this.end || this.duration);\n    },\n\n    /**\n     * The jCal representation of this period type.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return [this.start.toString(), (this.end || this.duration).toString()];\n    },\n\n    /**\n     * The iCalendar string representation of this period.\n     * @return {String}\n     */\n    toICALString: function() {\n      return this.start.toICALString() + \"/\" +\n             (this.end || this.duration).toICALString();\n    }\n  };\n\n  /**\n   * Creates a new {@link ICAL.Period} instance from the passed string.\n   *\n   * @param {String} str            The string to parse\n   * @param {ICAL.Property} prop    The property this period will be on\n   * @return {ICAL.Period}          The created period instance\n   */\n  ICAL.Period.fromString = function fromString(str, prop) {\n    var parts = str.split('/');\n\n    if (parts.length !== 2) {\n      throw new Error(\n        'Invalid string value: \"' + str + '\" must contain a \"/\" char.'\n      );\n    }\n\n    var options = {\n      start: ICAL.Time.fromDateTimeString(parts[0], prop)\n    };\n\n    var end = parts[1];\n\n    if (ICAL.Duration.isValueString(end)) {\n      options.duration = ICAL.Duration.fromString(end);\n    } else {\n      options.end = ICAL.Time.fromDateTimeString(end, prop);\n    }\n\n    return new ICAL.Period(options);\n  };\n\n  /**\n   * Creates a new {@link ICAL.Period} instance from the given data object.\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   * @return {ICAL.Period}                  The period instance\n   */\n  ICAL.Period.fromData = function fromData(aData) {\n    return new ICAL.Period(aData);\n  };\n\n  /**\n   * Returns a new period instance from the given jCal data array. The first\n   * member is always the start date string, the second member is either a\n   * duration or end date string.\n   *\n   * @param {Array<String,String>} aData    The jCal data array\n   * @param {ICAL.Property} aProp           The property this jCal data is on\n   * @param {Boolean} aLenient              If true, data value can be both date and date-time\n   * @return {ICAL.Period}                  The period instance\n   */\n  ICAL.Period.fromJSON = function(aData, aProp, aLenient) {\n    function fromDateOrDateTimeString(aValue, aProp) {\n      if (aLenient) {\n        return ICAL.Time.fromString(aValue, aProp);\n      } else {\n        return ICAL.Time.fromDateTimeString(aValue, aProp);\n      }\n    }\n\n    if (ICAL.Duration.isValueString(aData[1])) {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        duration: ICAL.Duration.fromString(aData[1])\n      });\n    } else {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        end: fromDateOrDateTimeString(aData[1], aProp)\n      });\n    }\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n  var DURATION_LETTERS = /([PDWHMTS]{1,1})/;\n\n  /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Duration\n   * @param {Object} data               An object with members of the duration\n   * @param {Number} data.weeks         Duration in weeks\n   * @param {Number} data.days          Duration in days\n   * @param {Number} data.hours         Duration in hours\n   * @param {Number} data.minutes       Duration in minutes\n   * @param {Number} data.seconds       Duration in seconds\n   * @param {Boolean} data.isNegative   If true, the duration is negative\n   */\n  ICAL.Duration = function icalduration(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n\n  ICAL.Duration.prototype = {\n    /**\n     * The weeks in this duration\n     * @type {Number}\n     * @default 0\n     */\n    weeks: 0,\n\n    /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */\n    days: 0,\n\n    /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */\n    hours: 0,\n\n    /**\n     * The minutes in this duration\n     * @type {Number}\n     * @default 0\n     */\n    minutes: 0,\n\n    /**\n     * The seconds in this duration\n     * @type {Number}\n     * @default 0\n     */\n    seconds: 0,\n\n    /**\n     * The seconds in this duration\n     * @type {Boolean}\n     * @default false\n     */\n    isNegative: false,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalduration\"\n     */\n    icalclass: \"icalduration\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"duration\"\n     */\n    icaltype: \"duration\",\n\n    /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Duration}      The cloned object\n     */\n    clone: function clone() {\n      return ICAL.Duration.fromData(this);\n    },\n\n    /**\n     * The duration value expressed as a number of seconds.\n     *\n     * @return {Number}             The duration value in seconds\n     */\n    toSeconds: function toSeconds() {\n      var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours +\n                    86400 * this.days + 7 * 86400 * this.weeks;\n      return (this.isNegative ? -seconds : seconds);\n    },\n\n    /**\n     * Reads the passed seconds value into this duration object. Afterwards,\n     * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up\n     * accordingly.\n     *\n     * @param {Number} aSeconds     The duration value in seconds\n     * @return {ICAL.Duration}      Returns this instance\n     */\n    fromSeconds: function fromSeconds(aSeconds) {\n      var secs = Math.abs(aSeconds);\n\n      this.isNegative = (aSeconds < 0);\n      this.days = ICAL.helpers.trunc(secs / 86400);\n\n      // If we have a flat number of weeks, use them.\n      if (this.days % 7 == 0) {\n        this.weeks = this.days / 7;\n        this.days = 0;\n      } else {\n        this.weeks = 0;\n      }\n\n      secs -= (this.days + 7 * this.weeks) * 86400;\n\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n      secs -= this.hours * 3600;\n\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      secs -= this.minutes * 60;\n\n      this.seconds = secs;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData               An object with members of the duration\n     * @param {Number} aData.weeks         Duration in weeks\n     * @param {Number} aData.days          Duration in days\n     * @param {Number} aData.hours         Duration in hours\n     * @param {Number} aData.minutes       Duration in minutes\n     * @param {Number} aData.seconds       Duration in seconds\n     * @param {Boolean} aData.isNegative   If true, the duration is negative\n     */\n    fromData: function fromData(aData) {\n      var propsToCopy = [\"weeks\", \"days\", \"hours\",\n                         \"minutes\", \"seconds\", \"isNegative\"];\n      for (var key in propsToCopy) {\n        /* istanbul ignore if */\n        if (!propsToCopy.hasOwnProperty(key)) {\n          continue;\n        }\n        var prop = propsToCopy[key];\n        if (aData && prop in aData) {\n          this[prop] = aData[prop];\n        } else {\n          this[prop] = 0;\n        }\n      }\n    },\n\n    /**\n     * Resets the duration instance to the default values, i.e. PT0S\n     */\n    reset: function reset() {\n      this.isNegative = false;\n      this.weeks = 0;\n      this.days = 0;\n      this.hours = 0;\n      this.minutes = 0;\n      this.seconds = 0;\n    },\n\n    /**\n     * Compares the duration instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function compare(aOther) {\n      var thisSeconds = this.toSeconds();\n      var otherSeconds = aOther.toSeconds();\n      return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);\n    },\n\n    /**\n     * Normalizes the duration instance. For example, a duration with a value\n     * of 61 seconds will be normalized to 1 minute and 1 second.\n     */\n    normalize: function normalize() {\n      this.fromSeconds(this.toSeconds());\n    },\n\n    /**\n     * The string representation of this duration.\n     * @return {String}\n     */\n    toString: function toString() {\n      if (this.toSeconds() == 0) {\n        return \"PT0S\";\n      } else {\n        var str = \"\";\n        if (this.isNegative) str += \"-\";\n        str += \"P\";\n        if (this.weeks) str += this.weeks + \"W\";\n        if (this.days) str += this.days + \"D\";\n\n        if (this.hours || this.minutes || this.seconds) {\n          str += \"T\";\n          if (this.hours) str += this.hours + \"H\";\n          if (this.minutes) str += this.minutes + \"M\";\n          if (this.seconds) str += this.seconds + \"S\";\n        }\n        return str;\n      }\n    },\n\n    /**\n     * The iCalendar string representation of this duration.\n     * @return {String}\n     */\n    toICALString: function() {\n      return this.toString();\n    }\n  };\n\n  /**\n   * Returns a new ICAL.Duration instance from the passed seconds value.\n   *\n   * @param {Number} aSeconds       The seconds to create the instance from\n   * @return {ICAL.Duration}        The newly created duration instance\n   */\n  ICAL.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {\n    return (new ICAL.Duration()).fromSeconds(aSeconds);\n  };\n\n  /**\n   * Internal helper function to handle a chunk of a duration.\n   *\n   * @param {String} letter type of duration chunk\n   * @param {String} number numeric value or -/+\n   * @param {Object} dict target to assign values to\n   */\n  function parseDurationChunk(letter, number, object) {\n    var type;\n    switch (letter) {\n      case 'P':\n        if (number && number === '-') {\n          object.isNegative = true;\n        } else {\n          object.isNegative = false;\n        }\n        // period\n        break;\n      case 'D':\n        type = 'days';\n        break;\n      case 'W':\n        type = 'weeks';\n        break;\n      case 'H':\n        type = 'hours';\n        break;\n      case 'M':\n        type = 'minutes';\n        break;\n      case 'S':\n        type = 'seconds';\n        break;\n      default:\n        // Not a valid chunk\n        return 0;\n    }\n\n    if (type) {\n      if (!number && number !== 0) {\n        throw new Error(\n          'invalid duration value: Missing number before \"' + letter + '\"'\n        );\n      }\n      var num = parseInt(number, 10);\n      if (ICAL.helpers.isStrictlyNaN(num)) {\n        throw new Error(\n          'invalid duration value: Invalid number \"' + number + '\" before \"' + letter + '\"'\n        );\n      }\n      object[type] = num;\n    }\n\n    return 1;\n  }\n\n  /**\n   * Checks if the given string is an iCalendar duration value.\n   *\n   * @param {String} value      The raw ical value\n   * @return {Boolean}          True, if the given value is of the\n   *                              duration ical type\n   */\n  ICAL.Duration.isValueString = function(string) {\n    return (string[0] === 'P' || string[1] === 'P');\n  };\n\n  /**\n   * Creates a new {@link ICAL.Duration} instance from the passed string.\n   *\n   * @param {String} aStr       The string to parse\n   * @return {ICAL.Duration}    The created duration instance\n   */\n  ICAL.Duration.fromString = function icalduration_from_string(aStr) {\n    var pos = 0;\n    var dict = Object.create(null);\n    var chunks = 0;\n\n    while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {\n      var type = aStr[pos];\n      var numeric = aStr.substr(0, pos);\n      aStr = aStr.substr(pos + 1);\n\n      chunks += parseDurationChunk(type, numeric, dict);\n    }\n\n    if (chunks < 2) {\n      // There must be at least a chunk with \"P\" and some unit chunk\n      throw new Error(\n        'invalid duration value: Not enough duration components in \"' + aStr + '\"'\n      );\n    }\n\n    return new ICAL.Duration(dict);\n  };\n\n  /**\n   * Creates a new ICAL.Duration instance from the given data object.\n   *\n   * @param {Object} aData               An object with members of the duration\n   * @param {Number} aData.weeks         Duration in weeks\n   * @param {Number} aData.days          Duration in days\n   * @param {Number} aData.hours         Duration in hours\n   * @param {Number} aData.minutes       Duration in minutes\n   * @param {Number} aData.seconds       Duration in seconds\n   * @param {Boolean} aData.isNegative   If true, the duration is negative\n   * @return {ICAL.Duration}             The createad duration instance\n   */\n  ICAL.Duration.fromData = function icalduration_from_data(aData) {\n    return new ICAL.Duration(aData);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2012 */\n\n\n\n(function() {\n  var OPTIONS = [\"tzid\", \"location\", \"tznames\",\n                 \"latitude\", \"longitude\"];\n\n  /**\n   * @classdesc\n   * Timezone representation, created by passing in a tzid and component.\n   *\n   * @example\n   * var vcalendar;\n   * var timezoneComp = vcalendar.getFirstSubcomponent('vtimezone');\n   * var tzid = timezoneComp.getFirstPropertyValue('tzid');\n   *\n   * var timezone = new ICAL.Timezone({\n   *   component: timezoneComp,\n   *   tzid\n   * });\n   *\n   * @class\n   * @param {ICAL.Component|Object} data options for class\n   * @param {String|ICAL.Component} data.component\n   *        If data is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} data.tzid      The timezone identifier\n   * @param {String} data.location  The timezone locationw\n   * @param {String} data.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} data.latitude  The latitude of the timezone\n   * @param {Number} data.longitude The longitude of the timezone\n   */\n  ICAL.Timezone = function icaltimezone(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n\n  ICAL.Timezone.prototype = {\n\n    /**\n     * Timezone identifier\n     * @type {String}\n     */\n    tzid: \"\",\n\n    /**\n     * Timezone location\n     * @type {String}\n     */\n    location: \"\",\n\n    /**\n     * Alternative timezone name, for the string representation\n     * @type {String}\n     */\n    tznames: \"\",\n\n    /**\n     * The primary latitude for the timezone.\n     * @type {Number}\n     */\n    latitude: 0.0,\n\n    /**\n     * The primary longitude for the timezone.\n     * @type {Number}\n     */\n    longitude: 0.0,\n\n    /**\n     * The vtimezone component for this timezone.\n     * @type {ICAL.Component}\n     */\n    component: null,\n\n    /**\n     * The year this timezone has been expanded to. All timezone transition\n     * dates until this year are known and can be used for calculation\n     *\n     * @private\n     * @type {Number}\n     */\n    expandedUntilYear: 0,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltimezone\"\n     */\n    icalclass: \"icaltimezone\",\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {ICAL.Component|Object} aData options for class\n     * @param {String|ICAL.Component} aData.component\n     *        If aData is a simple object, then this member can be set to either a\n     *        string containing the component data, or an already parsed\n     *        ICAL.Component\n     * @param {String} aData.tzid      The timezone identifier\n     * @param {String} aData.location  The timezone locationw\n     * @param {String} aData.tznames   An alternative string representation of the\n     *                                  timezone\n     * @param {Number} aData.latitude  The latitude of the timezone\n     * @param {Number} aData.longitude The longitude of the timezone\n     */\n    fromData: function fromData(aData) {\n      this.expandedUntilYear = 0;\n      this.changes = [];\n\n      if (aData instanceof ICAL.Component) {\n        // Either a component is passed directly\n        this.component = aData;\n      } else {\n        // Otherwise the component may be in the data object\n        if (aData && \"component\" in aData) {\n          if (typeof aData.component == \"string\") {\n            // If a string was passed, parse it as a component\n            var jCal = ICAL.parse(aData.component);\n            this.component = new ICAL.Component(jCal);\n          } else if (aData.component instanceof ICAL.Component) {\n            // If it was a component already, then just set it\n            this.component = aData.component;\n          } else {\n            // Otherwise just null out the component\n            this.component = null;\n          }\n        }\n\n        // Copy remaining passed properties\n        for (var key in OPTIONS) {\n          /* istanbul ignore else */\n          if (OPTIONS.hasOwnProperty(key)) {\n            var prop = OPTIONS[key];\n            if (aData && prop in aData) {\n              this[prop] = aData[prop];\n            }\n          }\n        }\n      }\n\n      // If we have a component but no TZID, attempt to get it from the\n      // component's properties.\n      if (this.component instanceof ICAL.Component && !this.tzid) {\n        this.tzid = this.component.getFirstPropertyValue('tzid');\n      }\n\n      return this;\n    },\n\n    /**\n     * Finds the utcOffset the given time would occur in this timezone.\n     *\n     * @param {ICAL.Time} tt        The time to check for\n     * @return {Number} utc offset in seconds\n     */\n    utcOffset: function utcOffset(tt) {\n      if (this == ICAL.Timezone.utcTimezone || this == ICAL.Timezone.localTimezone) {\n        return 0;\n      }\n\n      this._ensureCoverage(tt.year);\n\n      if (!this.changes.length) {\n        return 0;\n      }\n\n      var tt_change = {\n        year: tt.year,\n        month: tt.month,\n        day: tt.day,\n        hour: tt.hour,\n        minute: tt.minute,\n        second: tt.second\n      };\n\n      var change_num = this._findNearbyChange(tt_change);\n      var change_num_to_use = -1;\n      var step = 1;\n\n      // TODO: replace with bin search?\n      for (;;) {\n        var change = ICAL.helpers.clone(this.changes[change_num], true);\n        if (change.utcOffset < change.prevUtcOffset) {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);\n        } else {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                          change.prevUtcOffset);\n        }\n\n        var cmp = ICAL.Timezone._compare_change_fn(tt_change, change);\n\n        if (cmp >= 0) {\n          change_num_to_use = change_num;\n        } else {\n          step = -1;\n        }\n\n        if (step == -1 && change_num_to_use != -1) {\n          break;\n        }\n\n        change_num += step;\n\n        if (change_num < 0) {\n          return 0;\n        }\n\n        if (change_num >= this.changes.length) {\n          break;\n        }\n      }\n\n      var zone_change = this.changes[change_num_to_use];\n      var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;\n\n      if (utcOffset_change < 0 && change_num_to_use > 0) {\n        var tmp_change = ICAL.helpers.clone(zone_change, true);\n        ICAL.Timezone.adjust_change(tmp_change, 0, 0, 0,\n                                        tmp_change.prevUtcOffset);\n\n        if (ICAL.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {\n          var prev_zone_change = this.changes[change_num_to_use - 1];\n\n          var want_daylight = false; // TODO\n\n          if (zone_change.is_daylight != want_daylight &&\n              prev_zone_change.is_daylight == want_daylight) {\n            zone_change = prev_zone_change;\n          }\n        }\n      }\n\n      // TODO return is_daylight?\n      return zone_change.utcOffset;\n    },\n\n    _findNearbyChange: function icaltimezone_find_nearby_change(change) {\n      // find the closest match\n      var idx = ICAL.helpers.binsearchInsert(\n        this.changes,\n        change,\n        ICAL.Timezone._compare_change_fn\n      );\n\n      if (idx >= this.changes.length) {\n        return this.changes.length - 1;\n      }\n\n      return idx;\n    },\n\n    _ensureCoverage: function(aYear) {\n      if (ICAL.Timezone._minimumExpansionYear == -1) {\n        var today = ICAL.Time.now();\n        ICAL.Timezone._minimumExpansionYear = today.year;\n      }\n\n      var changesEndYear = aYear;\n      if (changesEndYear < ICAL.Timezone._minimumExpansionYear) {\n        changesEndYear = ICAL.Timezone._minimumExpansionYear;\n      }\n\n      changesEndYear += ICAL.Timezone.EXTRA_COVERAGE;\n\n      if (changesEndYear > ICAL.Timezone.MAX_YEAR) {\n        changesEndYear = ICAL.Timezone.MAX_YEAR;\n      }\n\n      if (!this.changes.length || this.expandedUntilYear < aYear) {\n        var subcomps = this.component.getAllSubcomponents();\n        var compLen = subcomps.length;\n        var compIdx = 0;\n\n        for (; compIdx < compLen; compIdx++) {\n          this._expandComponent(\n            subcomps[compIdx], changesEndYear, this.changes\n          );\n        }\n\n        this.changes.sort(ICAL.Timezone._compare_change_fn);\n        this.expandedUntilYear = changesEndYear;\n      }\n    },\n\n    _expandComponent: function(aComponent, aYear, changes) {\n      if (!aComponent.hasProperty(\"dtstart\") ||\n          !aComponent.hasProperty(\"tzoffsetto\") ||\n          !aComponent.hasProperty(\"tzoffsetfrom\")) {\n        return null;\n      }\n\n      var dtstart = aComponent.getFirstProperty(\"dtstart\").getFirstValue();\n      var change;\n\n      function convert_tzoffset(offset) {\n        return offset.factor * (offset.hours * 3600 + offset.minutes * 60);\n      }\n\n      function init_changes() {\n        var changebase = {};\n        changebase.is_daylight = (aComponent.name == \"daylight\");\n        changebase.utcOffset = convert_tzoffset(\n          aComponent.getFirstProperty(\"tzoffsetto\").getFirstValue()\n        );\n\n        changebase.prevUtcOffset = convert_tzoffset(\n          aComponent.getFirstProperty(\"tzoffsetfrom\").getFirstValue()\n        );\n\n        return changebase;\n      }\n\n      if (!aComponent.hasProperty(\"rrule\") && !aComponent.hasProperty(\"rdate\")) {\n        change = init_changes();\n        change.year = dtstart.year;\n        change.month = dtstart.month;\n        change.day = dtstart.day;\n        change.hour = dtstart.hour;\n        change.minute = dtstart.minute;\n        change.second = dtstart.second;\n\n        ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                        -change.prevUtcOffset);\n        changes.push(change);\n      } else {\n        var props = aComponent.getAllProperties(\"rdate\");\n        for (var rdatekey in props) {\n          /* istanbul ignore if */\n          if (!props.hasOwnProperty(rdatekey)) {\n            continue;\n          }\n          var rdate = props[rdatekey];\n          var time = rdate.getFirstValue();\n          change = init_changes();\n\n          change.year = time.year;\n          change.month = time.month;\n          change.day = time.day;\n\n          if (time.isDate) {\n            change.hour = dtstart.hour;\n            change.minute = dtstart.minute;\n            change.second = dtstart.second;\n\n            if (dtstart.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                              -change.prevUtcOffset);\n            }\n          } else {\n            change.hour = time.hour;\n            change.minute = time.minute;\n            change.second = time.second;\n\n            if (time.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                              -change.prevUtcOffset);\n            }\n          }\n\n          changes.push(change);\n        }\n\n        var rrule = aComponent.getFirstProperty(\"rrule\");\n\n        if (rrule) {\n          rrule = rrule.getFirstValue();\n          change = init_changes();\n\n          if (rrule.until && rrule.until.zone == ICAL.Timezone.utcTimezone) {\n            rrule.until.adjust(0, 0, 0, change.prevUtcOffset);\n            rrule.until.zone = ICAL.Timezone.localTimezone;\n          }\n\n          var iterator = rrule.iterator(dtstart);\n\n          var occ;\n          while ((occ = iterator.next())) {\n            change = init_changes();\n            if (occ.year > aYear || !occ) {\n              break;\n            }\n\n            change.year = occ.year;\n            change.month = occ.month;\n            change.day = occ.day;\n            change.hour = occ.hour;\n            change.minute = occ.minute;\n            change.second = occ.second;\n            change.isDate = occ.isDate;\n\n            ICAL.Timezone.adjust_change(change, 0, 0, 0,\n                                            -change.prevUtcOffset);\n            changes.push(change);\n          }\n        }\n      }\n\n      return changes;\n    },\n\n    /**\n     * The string representation of this timezone.\n     * @return {String}\n     */\n    toString: function toString() {\n      return (this.tznames ? this.tznames : this.tzid);\n    }\n  };\n\n  ICAL.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a, b) {\n    if (a.year < b.year) return -1;\n    else if (a.year > b.year) return 1;\n\n    if (a.month < b.month) return -1;\n    else if (a.month > b.month) return 1;\n\n    if (a.day < b.day) return -1;\n    else if (a.day > b.day) return 1;\n\n    if (a.hour < b.hour) return -1;\n    else if (a.hour > b.hour) return 1;\n\n    if (a.minute < b.minute) return -1;\n    else if (a.minute > b.minute) return 1;\n\n    if (a.second < b.second) return -1;\n    else if (a.second > b.second) return 1;\n\n    return 0;\n  };\n\n  /**\n   * Convert the date/time from one zone to the next.\n   *\n   * @param {ICAL.Time} tt                  The time to convert\n   * @param {ICAL.Timezone} from_zone       The source zone to convert from\n   * @param {ICAL.Timezone} to_zone         The target zone to convert to\n   * @return {ICAL.Time}                    The converted date/time object\n   */\n  ICAL.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {\n    if (tt.isDate ||\n        from_zone.tzid == to_zone.tzid ||\n        from_zone == ICAL.Timezone.localTimezone ||\n        to_zone == ICAL.Timezone.localTimezone) {\n      tt.zone = to_zone;\n      return tt;\n    }\n\n    var utcOffset = from_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, - utcOffset);\n\n    utcOffset = to_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, utcOffset);\n\n    return null;\n  };\n\n  /**\n   * Creates a new ICAL.Timezone instance from the passed data object.\n   *\n   * @param {ICAL.Component|Object} aData options for class\n   * @param {String|ICAL.Component} aData.component\n   *        If aData is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} aData.tzid      The timezone identifier\n   * @param {String} aData.location  The timezone locationw\n   * @param {String} aData.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} aData.latitude  The latitude of the timezone\n   * @param {Number} aData.longitude The longitude of the timezone\n   */\n  ICAL.Timezone.fromData = function icaltimezone_fromData(aData) {\n    var tt = new ICAL.Timezone();\n    return tt.fromData(aData);\n  };\n\n  /**\n   * The instance describing the UTC timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */\n  ICAL.Timezone.utcTimezone = ICAL.Timezone.fromData({\n    tzid: \"UTC\"\n  });\n\n  /**\n   * The instance describing the local timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */\n  ICAL.Timezone.localTimezone = ICAL.Timezone.fromData({\n    tzid: \"floating\"\n  });\n\n  /**\n   * Adjust a timezone change object.\n   * @private\n   * @param {Object} change     The timezone change object\n   * @param {Number} days       The extra amount of days\n   * @param {Number} hours      The extra amount of hours\n   * @param {Number} minutes    The extra amount of minutes\n   * @param {Number} seconds    The extra amount of seconds\n   */\n  ICAL.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {\n    return ICAL.Time.prototype.adjust.call(\n      change,\n      days,\n      hours,\n      minutes,\n      seconds,\n      change\n    );\n  };\n\n  ICAL.Timezone._minimumExpansionYear = -1;\n  ICAL.Timezone.MAX_YEAR = 2035; // TODO this is because of time_t, which we don't need. Still usefull?\n  ICAL.Timezone.EXTRA_COVERAGE = 5;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.TimezoneService = (function() {\n  var zones;\n\n  /**\n   * @classdesc\n   * Singleton class to contain timezones.  Right now it is all manual registry in\n   * the future we may use this class to download timezone information or handle\n   * loading pre-expanded timezones.\n   *\n   * @namespace\n   * @alias ICAL.TimezoneService\n   */\n  var TimezoneService = {\n    get count() {\n      return Object.keys(zones).length;\n    },\n\n    reset: function() {\n      zones = Object.create(null);\n      var utc = ICAL.Timezone.utcTimezone;\n\n      zones.Z = utc;\n      zones.UTC = utc;\n      zones.GMT = utc;\n    },\n\n    /**\n     * Checks if timezone id has been registered.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {Boolean}        False, when not present\n     */\n    has: function(tzid) {\n      return !!zones[tzid];\n    },\n\n    /**\n     * Returns a timezone by its tzid if present.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The timezone, or null if not found\n     */\n    get: function(tzid) {\n      return zones[tzid];\n    },\n\n    /**\n     * Registers a timezone object or component.\n     *\n     * @param {String=} name\n     *        The name of the timezone. Defaults to the component's TZID if not\n     *        passed.\n     * @param {ICAL.Component|ICAL.Timezone} zone\n     *        The initialized zone or vtimezone.\n     */\n    register: function(name, timezone) {\n      if (name instanceof ICAL.Component) {\n        if (name.name === 'vtimezone') {\n          timezone = new ICAL.Timezone(name);\n          name = timezone.tzid;\n        }\n      }\n\n      if (timezone instanceof ICAL.Timezone) {\n        zones[name] = timezone;\n      } else {\n        throw new TypeError('timezone must be ICAL.Timezone or ICAL.Component');\n      }\n    },\n\n    /**\n     * Removes a timezone by its tzid from the list.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The removed timezone, or null if not registered\n     */\n    remove: function(tzid) {\n      return (delete zones[tzid]);\n    }\n  };\n\n  // initialize defaults\n  TimezoneService.reset();\n\n  return TimezoneService;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n\n  /**\n   * @classdesc\n   * iCalendar Time representation (similar to JS Date object).  Fully\n   * independent of system (OS) timezone / time.  Unlike JS Date, the month\n   * January is 1, not zero.\n   *\n   * @example\n   * var time = new ICAL.Time({\n   *   year: 2012,\n   *   month: 10,\n   *   day: 11\n   *   minute: 0,\n   *   second: 0,\n   *   isDate: false\n   * });\n   *\n   *\n   * @alias ICAL.Time\n   * @class\n   * @param {Object} data           Time initialization\n   * @param {Number=} data.year     The year for this date\n   * @param {Number=} data.month    The month for this date\n   * @param {Number=} data.day      The day for this date\n   * @param {Number=} data.hour     The hour for this date\n   * @param {Number=} data.minute   The minute for this date\n   * @param {Number=} data.second   The second for this date\n   * @param {Boolean=} data.isDate  If true, the instance represents a date (as\n   *                                  opposed to a date-time)\n   * @param {ICAL.Timezone} zone timezone this position occurs in\n   */\n  ICAL.Time = function icaltime(data, zone) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n\n    /* time defaults */\n    time.year = 0;\n    time.month = 1;\n    time.day = 1;\n    time.hour = 0;\n    time.minute = 0;\n    time.second = 0;\n    time.isDate = false;\n\n    this.fromData(data, zone);\n  };\n\n  ICAL.Time._dowCache = {};\n  ICAL.Time._wnCache = {};\n\n  ICAL.Time.prototype = {\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltime\"\n     */\n    icalclass: \"icaltime\",\n    _cachedUnixTime: null,\n\n    /**\n     * The type name, to be used in the jCal object. This value may change and\n     * is strictly defined by the {@link ICAL.Time#isDate isDate} member.\n     * @readonly\n     * @type {String}\n     * @default \"date-time\"\n     */\n    get icaltype() {\n      return this.isDate ? 'date' : 'date-time';\n    },\n\n    /**\n     * The timezone for this time.\n     * @type {ICAL.Timezone}\n     */\n    zone: null,\n\n    /**\n     * Internal uses to indicate that a change has been made and the next read\n     * operation must attempt to normalize the value (for example changing the\n     * day to 33).\n     *\n     * @type {Boolean}\n     * @private\n     */\n    _pendingNormalization: false,\n\n    /**\n     * Returns a clone of the time object.\n     *\n     * @return {ICAL.Time}              The cloned object\n     */\n    clone: function() {\n      return new ICAL.Time(this._time, this.zone);\n    },\n\n    /**\n     * Reset the time instance to epoch time\n     */\n    reset: function icaltime_reset() {\n      this.fromData(ICAL.Time.epochTime);\n      this.zone = ICAL.Timezone.utcTimezone;\n    },\n\n    /**\n     * Reset the time instance to the given date/time values.\n     *\n     * @param {Number} year             The year to set\n     * @param {Number} month            The month to set\n     * @param {Number} day              The day to set\n     * @param {Number} hour             The hour to set\n     * @param {Number} minute           The minute to set\n     * @param {Number} second           The second to set\n     * @param {ICAL.Timezone} timezone  The timezone to set\n     */\n    resetTo: function icaltime_resetTo(year, month, day,\n                                       hour, minute, second, timezone) {\n      this.fromData({\n        year: year,\n        month: month,\n        day: day,\n        hour: hour,\n        minute: minute,\n        second: second,\n        zone: timezone\n      });\n    },\n\n    /**\n     * Set up the current instance from the Javascript date value.\n     *\n     * @param {?Date} aDate     The Javascript Date to read, or null to reset\n     * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n     */\n    fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {\n      if (!aDate) {\n        this.reset();\n      } else {\n        if (useUTC) {\n          this.zone = ICAL.Timezone.utcTimezone;\n          this.year = aDate.getUTCFullYear();\n          this.month = aDate.getUTCMonth() + 1;\n          this.day = aDate.getUTCDate();\n          this.hour = aDate.getUTCHours();\n          this.minute = aDate.getUTCMinutes();\n          this.second = aDate.getUTCSeconds();\n        } else {\n          this.zone = ICAL.Timezone.localTimezone;\n          this.year = aDate.getFullYear();\n          this.month = aDate.getMonth() + 1;\n          this.day = aDate.getDate();\n          this.hour = aDate.getHours();\n          this.minute = aDate.getMinutes();\n          this.second = aDate.getSeconds();\n        }\n      }\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData            Time initialization\n     * @param {Number=} aData.year      The year for this date\n     * @param {Number=} aData.month     The month for this date\n     * @param {Number=} aData.day       The day for this date\n     * @param {Number=} aData.hour      The hour for this date\n     * @param {Number=} aData.minute    The minute for this date\n     * @param {Number=} aData.second    The second for this date\n     * @param {Boolean=} aData.isDate   If true, the instance represents a date\n     *                                    (as opposed to a date-time)\n     * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n     */\n    fromData: function fromData(aData, aZone) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (Object.prototype.hasOwnProperty.call(aData, key)) {\n            // ical type cannot be set\n            if (key === 'icaltype') continue;\n            this[key] = aData[key];\n          }\n        }\n      }\n\n      if (aZone) {\n        this.zone = aZone;\n      }\n\n      if (aData && !(\"isDate\" in aData)) {\n        this.isDate = !(\"hour\" in aData);\n      } else if (aData && (\"isDate\" in aData)) {\n        this.isDate = aData.isDate;\n      }\n\n      if (aData && \"timezone\" in aData) {\n        var zone = ICAL.TimezoneService.get(\n          aData.timezone\n        );\n\n        this.zone = zone || ICAL.Timezone.localTimezone;\n      }\n\n      if (aData && \"zone\" in aData) {\n        this.zone = aData.zone;\n      }\n\n      if (!this.zone) {\n        this.zone = ICAL.Timezone.localTimezone;\n      }\n\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Calculate the day of week.\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time.weekDay}\n     */\n    dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;\n      if (dowCacheKey in ICAL.Time._dowCache) {\n        return ICAL.Time._dowCache[dowCacheKey];\n      }\n\n      // Using Zeller's algorithm\n      var q = this.day;\n      var m = this.month + (this.month < 3 ? 12 : 0);\n      var Y = this.year - (this.month < 3 ? 1 : 0);\n\n      var h = (q + Y + ICAL.helpers.trunc(((m + 1) * 26) / 10) + ICAL.helpers.trunc(Y / 4));\n      /* istanbul ignore else */\n      if (true /* gregorian */) {\n        h += ICAL.helpers.trunc(Y / 100) * 6 + ICAL.helpers.trunc(Y / 400);\n      } else {\n        h += 5;\n      }\n\n      // Normalize to 1 = wkst\n      h = ((h + 7 - firstDow) % 7) + 1;\n      ICAL.Time._dowCache[dowCacheKey] = h;\n      return h;\n    },\n\n    /**\n     * Calculate the day of year.\n     * @return {Number}\n     */\n    dayOfYear: function dayOfYear() {\n      var is_leap = (ICAL.Time.isLeapYear(this.year) ? 1 : 0);\n      var diypm = ICAL.Time.daysInYearPassedMonth;\n      return diypm[is_leap][this.month - 1] + this.day;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * week. The resulting ICAL.Time instance is of icaltype date, even if this\n     * is a date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The start of the week (cloned)\n     */\n    startOfWeek: function startOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day -= ((this.dayOfWeek() + 7 - firstDow) % 7);\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the week.\n     * The resulting ICAL.Time instance is of icaltype date, even if this is a\n     * date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The end of the week (cloned)\n     */\n    endOfWeek: function endOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day += (7 - this.dayOfWeek() + firstDow - ICAL.Time.SUNDAY) % 7;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * month. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the month (cloned)\n     */\n    startOfMonth: function startOfMonth() {\n      var result = this.clone();\n      result.day = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * month.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the month (cloned)\n     */\n    endOfMonth: function endOfMonth() {\n      var result = this.clone();\n      result.day = ICAL.Time.daysInMonth(result.month, result.year);\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * year. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the year (cloned)\n     */\n    startOfYear: function startOfYear() {\n      var result = this.clone();\n      result.day = 1;\n      result.month = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * year.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the year (cloned)\n     */\n    endOfYear: function endOfYear() {\n      var result = this.clone();\n      result.day = 31;\n      result.month = 12;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\n     * First calculates the start of the week, then returns the day of year for\n     * this date. If the day falls into the previous year, the day is zero or negative.\n     *\n     * @param {ICAL.Time.weekDay=} aFirstDayOfWeek\n     *        The week start weekday, defaults to SUNDAY\n     * @return {Number}     The calculated day of year\n     */\n    startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {\n      var firstDow = aFirstDayOfWeek || ICAL.Time.SUNDAY;\n      var delta = this.dayOfWeek() - firstDow;\n      if (delta < 0) delta += 7;\n      return this.dayOfYear() - delta;\n    },\n\n    /**\n     * Get the dominical letter for the current year. Letters range from A - G\n     * for common years, and AG to GF for leap years.\n     *\n     * @param {Number} yr           The year to retrieve the letter for\n     * @return {String}             The dominical letter.\n     */\n    getDominicalLetter: function() {\n      return ICAL.Time.getDominicalLetter(this.year);\n    },\n\n    /**\n     * Finds the nthWeekDay relative to the current month (not day).  The\n     * returned value is a day relative the month that this month belongs to so\n     * 1 would indicate the first of the month and 40 would indicate a day in\n     * the following month.\n     *\n     * @param {Number} aDayOfWeek   Day of the week see the day name constants\n     * @param {Number} aPos         Nth occurrence of a given week day values\n     *        of 1 and 0 both indicate the first weekday of that type. aPos may\n     *        be either positive or negative\n     *\n     * @return {Number} numeric value indicating a day relative\n     *                   to the current month of this time object\n     */\n    nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {\n      var daysInMonth = ICAL.Time.daysInMonth(this.month, this.year);\n      var weekday;\n      var pos = aPos;\n\n      var start = 0;\n\n      var otherDay = this.clone();\n\n      if (pos >= 0) {\n        otherDay.day = 1;\n\n        // because 0 means no position has been given\n        // 1 and 0 indicate the same day.\n        if (pos != 0) {\n          // remove the extra numeric value\n          pos--;\n        }\n\n        // set current start offset to current day.\n        start = otherDay.day;\n\n        // find the current day of week\n        var startDow = otherDay.dayOfWeek();\n\n        // calculate the difference between current\n        // day of the week and desired day of the week\n        var offset = aDayOfWeek - startDow;\n\n\n        // if the offset goes into the past\n        // week we add 7 so it goes into the next\n        // week. We only want to go forward in time here.\n        if (offset < 0)\n          // this is really important otherwise we would\n          // end up with dates from in the past.\n          offset += 7;\n\n        // add offset to start so start is the same\n        // day of the week as the desired day of week.\n        start += offset;\n\n        // because we are going to add (and multiply)\n        // the numeric value of the day we subtract it\n        // from the start position so not to add it twice.\n        start -= aDayOfWeek;\n\n        // set week day\n        weekday = aDayOfWeek;\n      } else {\n\n        // then we set it to the last day in the current month\n        otherDay.day = daysInMonth;\n\n        // find the ends weekday\n        var endDow = otherDay.dayOfWeek();\n\n        pos++;\n\n        weekday = (endDow - aDayOfWeek);\n\n        if (weekday < 0) {\n          weekday += 7;\n        }\n\n        weekday = daysInMonth - weekday;\n      }\n\n      weekday += pos * 7;\n\n      return start + weekday;\n    },\n\n    /**\n     * Checks if current time is the nth weekday, relative to the current\n     * month.  Will always return false when rule resolves outside of current\n     * month.\n     *\n     * @param {ICAL.Time.weekDay} aDayOfWeek       Day of week to check\n     * @param {Number} aPos                        Relative position\n     * @return {Boolean}                           True, if it is the nth weekday\n     */\n    isNthWeekDay: function(aDayOfWeek, aPos) {\n      var dow = this.dayOfWeek();\n\n      if (aPos === 0 && dow === aDayOfWeek) {\n        return true;\n      }\n\n      // get pos\n      var day = this.nthWeekDay(aDayOfWeek, aPos);\n\n      if (day === this.day) {\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * Calculates the ISO 8601 week number. The first week of a year is the\n     * week that contains the first Thursday. The year can have 53 weeks, if\n     * January 1st is a Friday.\n     *\n     * Note there are regions where the first week of the year is the one that\n     * starts on January 1st, which may offset the week number. Also, if a\n     * different week start is specified, this will also affect the week\n     * number.\n     *\n     * @see ICAL.Time.weekOneStarts\n     * @param {ICAL.Time.weekDay} aWeekStart        The weekday the week starts with\n     * @return {Number}                             The ISO week number\n     */\n    weekNumber: function weekNumber(aWeekStart) {\n      var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;\n      if (wnCacheKey in ICAL.Time._wnCache) {\n        return ICAL.Time._wnCache[wnCacheKey];\n      }\n      // This function courtesty of Julian Bucknall, published under the MIT license\n      // http://www.boyet.com/articles/publishedarticles/calculatingtheisoweeknumb.html\n      // plus some fixes to be able to use different week starts.\n      var week1;\n\n      var dt = this.clone();\n      dt.isDate = true;\n      var isoyear = this.year;\n\n      if (dt.month == 12 && dt.day > 25) {\n        week1 = ICAL.Time.weekOneStarts(isoyear + 1, aWeekStart);\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n        } else {\n          isoyear++;\n        }\n      } else {\n        week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(--isoyear, aWeekStart);\n        }\n      }\n\n      var daysBetween = (dt.subtractDate(week1).toSeconds() / 86400);\n      var answer = ICAL.helpers.trunc(daysBetween / 7) + 1;\n      ICAL.Time._wnCache[wnCacheKey] = answer;\n      return answer;\n    },\n\n    /**\n     * Adds the duration to the current time. The instance is modified in\n     * place.\n     *\n     * @param {ICAL.Duration} aDuration         The duration to add\n     */\n    addDuration: function icaltime_add(aDuration) {\n      var mult = (aDuration.isNegative ? -1 : 1);\n\n      // because of the duration optimizations it is much\n      // more efficient to grab all the values up front\n      // then set them directly (which will avoid a normalization call).\n      // So we don't actually normalize until we need it.\n      var second = this.second;\n      var minute = this.minute;\n      var hour = this.hour;\n      var day = this.day;\n\n      second += mult * aDuration.seconds;\n      minute += mult * aDuration.minutes;\n      hour += mult * aDuration.hours;\n      day += mult * aDuration.days;\n      day += mult * 7 * aDuration.weeks;\n\n      this.second = second;\n      this.minute = minute;\n      this.hour = hour;\n      this.day = day;\n\n      this._cachedUnixTime = null;\n    },\n\n    /**\n     * Subtract the date details (_excluding_ timezone).  Useful for finding\n     * the relative difference between two time objects excluding their\n     * timezone differences.\n     *\n     * @param {ICAL.Time} aDate     The date to substract\n     * @return {ICAL.Duration}      The difference as a duration\n     */\n    subtractDate: function icaltime_subtract(aDate) {\n      var unixTime = this.toUnixTime() + this.utcOffset();\n      var other = aDate.toUnixTime() + aDate.utcOffset();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n\n    /**\n     * Subtract the date details, taking timezones into account.\n     *\n     * @param {ICAL.Time} aDate  The date to subtract\n     * @return {ICAL.Duration}  The difference in duration\n     */\n    subtractDateTz: function icaltime_subtract_abs(aDate) {\n      var unixTime = this.toUnixTime();\n      var other = aDate.toUnixTime();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n\n    /**\n     * Compares the ICAL.Time instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toUnixTime();\n      var b = other.toUnixTime();\n\n      if (a > b) return 1;\n      if (b > a) return -1;\n      return 0;\n    },\n\n    /**\n     * Compares only the date part of this instance with another one.\n     *\n     * @param {ICAL.Duration} other         The instance to compare with\n     * @param {ICAL.Timezone} tz            The timezone to compare in\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */\n    compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {\n      function cmp(attr) {\n        return ICAL.Time._cmp_attr(a, b, attr);\n      }\n      var a = this.convertToZone(tz);\n      var b = other.convertToZone(tz);\n      var rc = 0;\n\n      if ((rc = cmp(\"year\")) != 0) return rc;\n      if ((rc = cmp(\"month\")) != 0) return rc;\n      if ((rc = cmp(\"day\")) != 0) return rc;\n\n      return rc;\n    },\n\n    /**\n     * Convert the instance into another timezone. The returned ICAL.Time\n     * instance is always a copy.\n     *\n     * @param {ICAL.Timezone} zone      The zone to convert to\n     * @return {ICAL.Time}              The copy, converted to the zone\n     */\n    convertToZone: function convertToZone(zone) {\n      var copy = this.clone();\n      var zone_equals = (this.zone.tzid == zone.tzid);\n\n      if (!this.isDate && !zone_equals) {\n        ICAL.Timezone.convert_time(copy, this.zone, zone);\n      }\n\n      copy.zone = zone;\n      return copy;\n    },\n\n    /**\n     * Calculates the UTC offset of the current date/time in the timezone it is\n     * in.\n     *\n     * @return {Number}     UTC offset in seconds\n     */\n    utcOffset: function utc_offset() {\n      if (this.zone == ICAL.Timezone.localTimezone ||\n          this.zone == ICAL.Timezone.utcTimezone) {\n        return 0;\n      } else {\n        return this.zone.utcOffset(this);\n      }\n    },\n\n    /**\n     * Returns an RFC 5545 compliant ical representation of this object.\n     *\n     * @return {String} ical date/date-time\n     */\n    toICALString: function() {\n      var string = this.toString();\n\n      if (string.length > 10) {\n        return ICAL.design.icalendar.value['date-time'].toICAL(string);\n      } else {\n        return ICAL.design.icalendar.value.date.toICAL(string);\n      }\n    },\n\n    /**\n     * The string representation of this date/time, in jCal form\n     * (including : and - separators).\n     * @return {String}\n     */\n    toString: function toString() {\n      var result = this.year + '-' +\n                   ICAL.helpers.pad2(this.month) + '-' +\n                   ICAL.helpers.pad2(this.day);\n\n      if (!this.isDate) {\n          result += 'T' + ICAL.helpers.pad2(this.hour) + ':' +\n                    ICAL.helpers.pad2(this.minute) + ':' +\n                    ICAL.helpers.pad2(this.second);\n\n        if (this.zone === ICAL.Timezone.utcTimezone) {\n          result += 'Z';\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * Converts the current instance to a Javascript date\n     * @return {Date}\n     */\n    toJSDate: function toJSDate() {\n      if (this.zone == ICAL.Timezone.localTimezone) {\n        if (this.isDate) {\n          return new Date(this.year, this.month - 1, this.day);\n        } else {\n          return new Date(this.year, this.month - 1, this.day,\n                          this.hour, this.minute, this.second, 0);\n        }\n      } else {\n        return new Date(this.toUnixTime() * 1000);\n      }\n    },\n\n    _normalize: function icaltime_normalize() {\n      var isDate = this._time.isDate;\n      if (this._time.isDate) {\n        this._time.hour = 0;\n        this._time.minute = 0;\n        this._time.second = 0;\n      }\n      this.adjust(0, 0, 0, 0);\n\n      return this;\n    },\n\n    /**\n     * Adjust the date/time by the given offset\n     *\n     * @param {Number} aExtraDays       The extra amount of days\n     * @param {Number} aExtraHours      The extra amount of hours\n     * @param {Number} aExtraMinutes    The extra amount of minutes\n     * @param {Number} aExtraSeconds    The extra amount of seconds\n     * @param {Number=} aTime           The time to adjust, defaults to the\n     *                                    current instance.\n     */\n    adjust: function icaltime_adjust(aExtraDays, aExtraHours,\n                                     aExtraMinutes, aExtraSeconds, aTime) {\n\n      var minutesOverflow, hoursOverflow,\n          daysOverflow = 0, yearsOverflow = 0;\n\n      var second, minute, hour, day;\n      var daysInMonth;\n\n      var time = aTime || this._time;\n\n      if (!time.isDate) {\n        second = time.second + aExtraSeconds;\n        time.second = second % 60;\n        minutesOverflow = ICAL.helpers.trunc(second / 60);\n        if (time.second < 0) {\n          time.second += 60;\n          minutesOverflow--;\n        }\n\n        minute = time.minute + aExtraMinutes + minutesOverflow;\n        time.minute = minute % 60;\n        hoursOverflow = ICAL.helpers.trunc(minute / 60);\n        if (time.minute < 0) {\n          time.minute += 60;\n          hoursOverflow--;\n        }\n\n        hour = time.hour + aExtraHours + hoursOverflow;\n\n        time.hour = hour % 24;\n        daysOverflow = ICAL.helpers.trunc(hour / 24);\n        if (time.hour < 0) {\n          time.hour += 24;\n          daysOverflow--;\n        }\n      }\n\n\n      // Adjust month and year first, because we need to know what month the day\n      // is in before adjusting it.\n      if (time.month > 12) {\n        yearsOverflow = ICAL.helpers.trunc((time.month - 1) / 12);\n      } else if (time.month < 1) {\n        yearsOverflow = ICAL.helpers.trunc(time.month / 12) - 1;\n      }\n\n      time.year += yearsOverflow;\n      time.month -= 12 * yearsOverflow;\n\n      // Now take care of the days (and adjust month if needed)\n      day = time.day + aExtraDays + daysOverflow;\n\n      if (day > 0) {\n        for (;;) {\n          daysInMonth = ICAL.Time.daysInMonth(time.month, time.year);\n          if (day <= daysInMonth) {\n            break;\n          }\n\n          time.month++;\n          if (time.month > 12) {\n            time.year++;\n            time.month = 1;\n          }\n\n          day -= daysInMonth;\n        }\n      } else {\n        while (day <= 0) {\n          if (time.month == 1) {\n            time.year--;\n            time.month = 12;\n          } else {\n            time.month--;\n          }\n\n          day += ICAL.Time.daysInMonth(time.month, time.year);\n        }\n      }\n\n      time.day = day;\n\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\n     * Sets up the current instance from unix time, the number of seconds since\n     * January 1st, 1970.\n     *\n     * @param {Number} seconds      The seconds to set up with\n     */\n    fromUnixTime: function fromUnixTime(seconds) {\n      this.zone = ICAL.Timezone.utcTimezone;\n      var epoch = ICAL.Time.epochTime.clone();\n      epoch.adjust(0, 0, 0, seconds);\n\n      this.year = epoch.year;\n      this.month = epoch.month;\n      this.day = epoch.day;\n      this.hour = epoch.hour;\n      this.minute = epoch.minute;\n      this.second = Math.floor(epoch.second);\n\n      this._cachedUnixTime = null;\n    },\n\n    /**\n     * Converts the current instance to seconds since January 1st 1970.\n     *\n     * @return {Number}         Seconds since 1970\n     */\n    toUnixTime: function toUnixTime() {\n      if (this._cachedUnixTime !== null) {\n        return this._cachedUnixTime;\n      }\n      var offset = this.utcOffset();\n\n      // we use the offset trick to ensure\n      // that we are getting the actual UTC time\n      var ms = Date.UTC(\n        this.year,\n        this.month - 1,\n        this.day,\n        this.hour,\n        this.minute,\n        this.second - offset\n      );\n\n      // seconds\n      this._cachedUnixTime = ms / 1000;\n      return this._cachedUnixTime;\n    },\n\n    /**\n     * Converts time to into Object which can be serialized then re-created\n     * using the constructor.\n     *\n     * @example\n     * // toJSON will automatically be called\n     * var json = JSON.stringify(mytime);\n     *\n     * var deserialized = JSON.parse(json);\n     *\n     * var time = new ICAL.Time(deserialized);\n     *\n     * @return {Object}\n     */\n    toJSON: function() {\n      var copy = [\n        'year',\n        'month',\n        'day',\n        'hour',\n        'minute',\n        'second',\n        'isDate'\n      ];\n\n      var result = Object.create(null);\n\n      var i = 0;\n      var len = copy.length;\n      var prop;\n\n      for (; i < len; i++) {\n        prop = copy[i];\n        result[prop] = this[prop];\n      }\n\n      if (this.zone) {\n        result.timezone = this.zone.tzid;\n      }\n\n      return result;\n    }\n\n  };\n\n  (function setupNormalizeAttributes() {\n    // This needs to run before any instances are created!\n    function defineAttr(attr) {\n      Object.defineProperty(ICAL.Time.prototype, attr, {\n        get: function getTimeAttr() {\n          if (this._pendingNormalization) {\n            this._normalize();\n            this._pendingNormalization = false;\n          }\n\n          return this._time[attr];\n        },\n        set: function setTimeAttr(val) {\n          // Check if isDate will be set and if was not set to normalize date.\n          // This avoids losing days when seconds, minutes and hours are zeroed\n          // what normalize will do when time is a date.\n          if (attr === \"isDate\" && val && !this._time.isDate) {\n            this.adjust(0, 0, 0, 0);\n          }\n          this._cachedUnixTime = null;\n          this._pendingNormalization = true;\n          this._time[attr] = val;\n\n          return val;\n        }\n      });\n\n    }\n\n    /* istanbul ignore else */\n    if (\"defineProperty\" in Object) {\n      defineAttr(\"year\");\n      defineAttr(\"month\");\n      defineAttr(\"day\");\n      defineAttr(\"hour\");\n      defineAttr(\"minute\");\n      defineAttr(\"second\");\n      defineAttr(\"isDate\");\n    }\n  })();\n\n  /**\n   * Returns the days in the given month\n   *\n   * @param {Number} month      The month to check\n   * @param {Number} year       The year to check\n   * @return {Number}           The number of days in the month\n   */\n  ICAL.Time.daysInMonth = function icaltime_daysInMonth(month, year) {\n    var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var days = 30;\n\n    if (month < 1 || month > 12) return days;\n\n    days = _daysInMonth[month];\n\n    if (month == 2) {\n      days += ICAL.Time.isLeapYear(year);\n    }\n\n    return days;\n  };\n\n  /**\n   * Checks if the year is a leap year\n   *\n   * @param {Number} year       The year to check\n   * @return {Boolean}          True, if the year is a leap year\n   */\n  ICAL.Time.isLeapYear = function isLeapYear(year) {\n    if (year <= 1752) {\n      return ((year % 4) == 0);\n    } else {\n      return (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0));\n    }\n  };\n\n  /**\n   * Create a new ICAL.Time from the day of year and year. The date is returned\n   * in floating timezone.\n   *\n   * @param {Number} aDayOfYear     The day of year\n   * @param {Number} aYear          The year to create the instance in\n   * @return {ICAL.Time}            The created instance with the calculated date\n   */\n  ICAL.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {\n    var year = aYear;\n    var doy = aDayOfYear;\n    var tt = new ICAL.Time();\n    tt.auto_normalize = false;\n    var is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\n\n    if (doy < 1) {\n      year--;\n      is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\n      doy += ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      return ICAL.Time.fromDayOfYear(doy, year);\n    } else if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][12]) {\n      is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\n      doy -= ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      year++;\n      return ICAL.Time.fromDayOfYear(doy, year);\n    }\n\n    tt.year = year;\n    tt.isDate = true;\n\n    for (var month = 11; month >= 0; month--) {\n      if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][month]) {\n        tt.month = month + 1;\n        tt.day = doy - ICAL.Time.daysInYearPassedMonth[is_leap][month];\n        break;\n      }\n    }\n\n    tt.auto_normalize = true;\n    return tt;\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @deprecated                Use {@link ICAL.Time.fromDateString} instead\n   * @param {String} str        The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */\n  ICAL.Time.fromStringv2 = function fromString(str) {\n    return new ICAL.Time({\n      year: parseInt(str.substr(0, 4), 10),\n      month: parseInt(str.substr(5, 2), 10),\n      day: parseInt(str.substr(8, 2), 10),\n      isDate: true\n    });\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @param {String} aValue     The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */\n  ICAL.Time.fromDateString = function(aValue) {\n    // Dates should have no timezone.\n    // Google likes to sometimes specify Z on dates\n    // we specifically ignore that to avoid issues.\n\n    // YYYY-MM-DD\n    // 2012-10-10\n    return new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      isDate: true\n    });\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date-time string, e.g\n   * 2015-01-02T03:04:05. If a property is specified, the timezone is set up\n   * from the property's TZID parameter.\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */\n  ICAL.Time.fromDateTimeString = function(aValue, prop) {\n    if (aValue.length < 19) {\n      throw new Error(\n        'invalid date-time value: \"' + aValue + '\"'\n      );\n    }\n\n    var zone;\n\n    if (aValue[19] && aValue[19] === 'Z') {\n      zone = 'Z';\n    } else if (prop) {\n      zone = prop.getParameter('tzid');\n    }\n\n    // 2012-10-10T10:10:10(Z)?\n    var time = new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      hour: ICAL.helpers.strictParseInt(aValue.substr(11, 2)),\n      minute: ICAL.helpers.strictParseInt(aValue.substr(14, 2)),\n      second: ICAL.helpers.strictParseInt(aValue.substr(17, 2)),\n      timezone: zone\n    });\n\n    return time;\n  };\n\n  /**\n   * Returns a new ICAL.Time instance from a date or date-time string,\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */\n  ICAL.Time.fromString = function fromString(aValue, aProperty) {\n    if (aValue.length > 10) {\n      return ICAL.Time.fromDateTimeString(aValue, aProperty);\n    } else {\n      return ICAL.Time.fromDateString(aValue);\n    }\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the given Javascript Date.\n   *\n   * @param {?Date} aDate     The Javascript Date to read, or null to reset\n   * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n   */\n  ICAL.Time.fromJSDate = function fromJSDate(aDate, useUTC) {\n    var tt = new ICAL.Time();\n    return tt.fromJSDate(aDate, useUTC);\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the the passed data object.\n   *\n   * @param {Object} aData            Time initialization\n   * @param {Number=} aData.year      The year for this date\n   * @param {Number=} aData.month     The month for this date\n   * @param {Number=} aData.day       The day for this date\n   * @param {Number=} aData.hour      The hour for this date\n   * @param {Number=} aData.minute    The minute for this date\n   * @param {Number=} aData.second    The second for this date\n   * @param {Boolean=} aData.isDate   If true, the instance represents a date\n   *                                    (as opposed to a date-time)\n   * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n   */\n  ICAL.Time.fromData = function fromData(aData, aZone) {\n    var t = new ICAL.Time();\n    return t.fromData(aData, aZone);\n  };\n\n  /**\n   * Creates a new ICAL.Time instance from the current moment.\n   * The instance is floating - has no timezone relation.\n   * To create an instance considering the time zone, call\n   * ICAL.Time.fromJSDate(new Date(), true)\n   * @return {ICAL.Time}\n   */\n  ICAL.Time.now = function icaltime_now() {\n    return ICAL.Time.fromJSDate(new Date(), false);\n  };\n\n  /**\n   * Returns the date on which ISO week number 1 starts.\n   *\n   * @see ICAL.Time#weekNumber\n   * @param {Number} aYear                  The year to search in\n   * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday, used for calculation.\n   * @return {ICAL.Time}                    The date on which week number 1 starts\n   */\n  ICAL.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {\n    var t = ICAL.Time.fromData({\n      year: aYear,\n      month: 1,\n      day: 1,\n      isDate: true\n    });\n\n    var dow = t.dayOfWeek();\n    var wkst = aWeekStart || ICAL.Time.DEFAULT_WEEK_START;\n    if (dow > ICAL.Time.THURSDAY) {\n      t.day += 7;\n    }\n    if (wkst > ICAL.Time.THURSDAY) {\n      t.day -= 7;\n    }\n\n    t.day -= dow - wkst;\n\n    return t;\n  };\n\n  /**\n   * Get the dominical letter for the given year. Letters range from A - G for\n   * common years, and AG to GF for leap years.\n   *\n   * @param {Number} yr           The year to retrieve the letter for\n   * @return {String}             The dominical letter.\n   */\n  ICAL.Time.getDominicalLetter = function(yr) {\n    var LTRS = \"GFEDCBA\";\n    var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;\n    var isLeap = ICAL.Time.isLeapYear(yr);\n    if (isLeap) {\n      return LTRS[(dom + 6) % 7] + LTRS[dom];\n    } else {\n      return LTRS[dom];\n    }\n  };\n\n  /**\n   * January 1st, 1970 as an ICAL.Time.\n   * @type {ICAL.Time}\n   * @constant\n   * @instance\n   */\n  ICAL.Time.epochTime = ICAL.Time.fromData({\n    year: 1970,\n    month: 1,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    isDate: false,\n    timezone: \"Z\"\n  });\n\n  ICAL.Time._cmp_attr = function _cmp_attr(a, b, attr) {\n    if (a[attr] > b[attr]) return 1;\n    if (a[attr] < b[attr]) return -1;\n    return 0;\n  };\n\n  /**\n   * The days that have passed in the year after a given month. The array has\n   * two members, one being an array of passed days for non-leap years, the\n   * other analog for leap years.\n   * @example\n   * var isLeapYear = ICAL.Time.isLeapYear(year);\n   * var passedDays = ICAL.Time.daysInYearPassedMonth[isLeapYear][month];\n   * @type {Array.<Array.<Number>>}\n   */\n  ICAL.Time.daysInYearPassedMonth = [\n    [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],\n    [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]\n  ];\n\n  /**\n   * The weekday, 1 = SUNDAY, 7 = SATURDAY. Access via\n   * ICAL.Time.MONDAY, ICAL.Time.TUESDAY, ...\n   *\n   * @typedef {Number} weekDay\n   * @memberof ICAL.Time\n   */\n\n  ICAL.Time.SUNDAY = 1;\n  ICAL.Time.MONDAY = 2;\n  ICAL.Time.TUESDAY = 3;\n  ICAL.Time.WEDNESDAY = 4;\n  ICAL.Time.THURSDAY = 5;\n  ICAL.Time.FRIDAY = 6;\n  ICAL.Time.SATURDAY = 7;\n\n  /**\n   * The default weekday for the WKST part.\n   * @constant\n   * @default ICAL.Time.MONDAY\n   */\n  ICAL.Time.DEFAULT_WEEK_START = ICAL.Time.MONDAY;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2015 */\n\n\n\n(function() {\n\n  /**\n   * Describes a vCard time, which has slight differences to the ICAL.Time.\n   * Properties can be null if not specified, for example for dates with\n   * reduced accuracy or truncation.\n   *\n   * Note that currently not all methods are correctly re-implemented for\n   * VCardTime. For example, comparison will have undefined results when some\n   * members are null.\n   *\n   * Also, normalization is not yet implemented for this class!\n   *\n   * @alias ICAL.VCardTime\n   * @class\n   * @extends {ICAL.Time}\n   * @param {Object} data                           The data for the time instance\n   * @param {Number=} data.year                     The year for this date\n   * @param {Number=} data.month                    The month for this date\n   * @param {Number=} data.day                      The day for this date\n   * @param {Number=} data.hour                     The hour for this date\n   * @param {Number=} data.minute                   The minute for this date\n   * @param {Number=} data.second                   The second for this date\n   * @param {ICAL.Timezone|ICAL.UtcOffset} zone     The timezone to use\n   * @param {String} icaltype                       The type for this date/time object\n   */\n  ICAL.VCardTime = function(data, zone, icaltype) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n\n    time.year = null;\n    time.month = null;\n    time.day = null;\n    time.hour = null;\n    time.minute = null;\n    time.second = null;\n\n    this.icaltype = icaltype || \"date-and-or-time\";\n\n    this.fromData(data, zone);\n  };\n  ICAL.helpers.inherits(ICAL.Time, ICAL.VCardTime, /** @lends ICAL.VCardTime */ {\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"vcardtime\"\n     */\n    icalclass: \"vcardtime\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @type {String}\n     * @default \"date-and-or-time\"\n     */\n    icaltype: \"date-and-or-time\",\n\n    /**\n     * The timezone. This can either be floating, UTC, or an instance of\n     * ICAL.UtcOffset.\n     * @type {ICAL.Timezone|ICAL.UtcOFfset}\n     */\n    zone: null,\n\n    /**\n     * Returns a clone of the vcard date/time object.\n     *\n     * @return {ICAL.VCardTime}     The cloned object\n     */\n    clone: function() {\n      return new ICAL.VCardTime(this._time, this.zone, this.icaltype);\n    },\n\n    _normalize: function() {\n      return this;\n    },\n\n    /**\n     * @inheritdoc\n     */\n    utcOffset: function() {\n      if (this.zone instanceof ICAL.UtcOffset) {\n        return this.zone.toSeconds();\n      } else {\n        return ICAL.Time.prototype.utcOffset.apply(this, arguments);\n      }\n    },\n\n    /**\n     * Returns an RFC 6350 compliant representation of this object.\n     *\n     * @return {String}         vcard date/time string\n     */\n    toICALString: function() {\n      return ICAL.design.vcard.value[this.icaltype].toICAL(this.toString());\n    },\n\n    /**\n     * The string representation of this date/time, in jCard form\n     * (including : and - separators).\n     * @return {String}\n     */\n    toString: function toString() {\n      var p2 = ICAL.helpers.pad2;\n      var y = this.year, m = this.month, d = this.day;\n      var h = this.hour, mm = this.minute, s = this.second;\n\n      var hasYear = y !== null, hasMonth = m !== null, hasDay = d !== null;\n      var hasHour = h !== null, hasMinute = mm !== null, hasSecond = s !== null;\n\n      var datepart = (hasYear ? p2(y) + (hasMonth || hasDay ? '-' : '') : (hasMonth || hasDay ? '--' : '')) +\n                     (hasMonth ? p2(m) : '') +\n                     (hasDay ? '-' + p2(d) : '');\n      var timepart = (hasHour ? p2(h) : '-') + (hasHour && hasMinute ? ':' : '') +\n                     (hasMinute ? p2(mm) : '') + (!hasHour && !hasMinute ? '-' : '') +\n                     (hasMinute && hasSecond ? ':' : '') +\n                     (hasSecond ? p2(s) : '');\n\n      var zone;\n      if (this.zone === ICAL.Timezone.utcTimezone) {\n        zone = 'Z';\n      } else if (this.zone instanceof ICAL.UtcOffset) {\n        zone = this.zone.toString();\n      } else if (this.zone === ICAL.Timezone.localTimezone) {\n        zone = '';\n      } else if (this.zone instanceof ICAL.Timezone) {\n        var offset = ICAL.UtcOffset.fromSeconds(this.zone.utcOffset(this));\n        zone = offset.toString();\n      } else {\n        zone = '';\n      }\n\n      switch (this.icaltype) {\n        case \"time\":\n          return timepart + zone;\n        case \"date-and-or-time\":\n        case \"date-time\":\n          return datepart + (timepart == '--' ? '' : 'T' + timepart + zone);\n        case \"date\":\n          return datepart;\n      }\n      return null;\n    }\n  });\n\n  /**\n   * Returns a new ICAL.VCardTime instance from a date and/or time string.\n   *\n   * @param {String} aValue     The string to create from\n   * @param {String} aIcalType  The type for this instance, e.g. date-and-or-time\n   * @return {ICAL.VCardTime}   The date/time instance\n   */\n  ICAL.VCardTime.fromDateAndOrTimeString = function(aValue, aIcalType) {\n    function part(v, s, e) {\n      return v ? ICAL.helpers.strictParseInt(v.substr(s, e)) : null;\n    }\n    var parts = aValue.split('T');\n    var dt = parts[0], tmz = parts[1];\n    var splitzone = tmz ? ICAL.design.vcard.value.time._splitZone(tmz) : [];\n    var zone = splitzone[0], tm = splitzone[1];\n\n    var stoi = ICAL.helpers.strictParseInt;\n    var dtlen = dt ? dt.length : 0;\n    var tmlen = tm ? tm.length : 0;\n\n    var hasDashDate = dt && dt[0] == '-' && dt[1] == '-';\n    var hasDashTime = tm && tm[0] == '-';\n\n    var o = {\n      year: hasDashDate ? null : part(dt, 0, 4),\n      month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,\n      day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,\n\n      hour: hasDashTime ? null : part(tm, 0, 2),\n      minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,\n      second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null\n    };\n\n    if (zone == 'Z') {\n      zone = ICAL.Timezone.utcTimezone;\n    } else if (zone && zone[3] == ':') {\n      zone = ICAL.UtcOffset.fromString(zone);\n    } else {\n      zone = null;\n    }\n\n    return new ICAL.VCardTime(o, zone, aIcalType);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n\n(function() {\n  var DOW_MAP = {\n    SU: ICAL.Time.SUNDAY,\n    MO: ICAL.Time.MONDAY,\n    TU: ICAL.Time.TUESDAY,\n    WE: ICAL.Time.WEDNESDAY,\n    TH: ICAL.Time.THURSDAY,\n    FR: ICAL.Time.FRIDAY,\n    SA: ICAL.Time.SATURDAY\n  };\n\n  var REVERSE_DOW_MAP = {};\n  for (var key in DOW_MAP) {\n    /* istanbul ignore else */\n    if (DOW_MAP.hasOwnProperty(key)) {\n      REVERSE_DOW_MAP[DOW_MAP[key]] = key;\n    }\n  }\n\n  var COPY_PARTS = [\"BYSECOND\", \"BYMINUTE\", \"BYHOUR\", \"BYDAY\",\n                    \"BYMONTHDAY\", \"BYYEARDAY\", \"BYWEEKNO\",\n                    \"BYMONTH\", \"BYSETPOS\"];\n\n  /**\n   * @classdesc\n   * This class represents the \"recur\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Recur\n   * @param {Object} data                               An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n   * @param {Number=} data.interval                     The INTERVAL value\n   * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n   * @param {ICAL.Time=} data.until                     The end of the recurrence set\n   * @param {Number=} data.count                        The number of occurrences\n   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n   * @param {Array.<String>=} data.byday                The BYDAY values\n   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n   */\n  ICAL.Recur = function icalrecur(data) {\n    this.wrappedJSObject = this;\n    this.parts = {};\n\n    if (data && typeof(data) === 'object') {\n      this.fromData(data);\n    }\n  };\n\n  ICAL.Recur.prototype = {\n    /**\n     * An object holding the BY-parts of the recurrence rule\n     * @type {Object}\n     */\n    parts: null,\n\n    /**\n     * The interval value for the recurrence rule.\n     * @type {Number}\n     */\n    interval: 1,\n\n    /**\n     * The week start day\n     *\n     * @type {ICAL.Time.weekDay}\n     * @default ICAL.Time.MONDAY\n     */\n    wkst: ICAL.Time.MONDAY,\n\n    /**\n     * The end of the recurrence\n     * @type {?ICAL.Time}\n     */\n    until: null,\n\n    /**\n     * The maximum number of occurrences\n     * @type {?Number}\n     */\n    count: null,\n\n    /**\n     * The frequency value.\n     * @type {ICAL.Recur.frequencyValues}\n     */\n    freq: null,\n\n    /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalrecur\"\n     */\n    icalclass: \"icalrecur\",\n\n    /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"recur\"\n     */\n    icaltype: \"recur\",\n\n    /**\n     * Create a new iterator for this recurrence rule. The passed start date\n     * must be the start date of the event, not the start of the range to\n     * search in.\n     *\n     * @example\n     * var recur = comp.getFirstPropertyValue('rrule');\n     * var dtstart = comp.getFirstPropertyValue('dtstart');\n     * var iter = recur.iterator(dtstart);\n     * for (var next = iter.next(); next; next = iter.next()) {\n     *   if (next.compare(rangeStart) < 0) {\n     *     continue;\n     *   }\n     *   console.log(next.toString());\n     * }\n     *\n     * @param {ICAL.Time} aStart        The item's start date\n     * @return {ICAL.RecurIterator}     The recurrence iterator\n     */\n    iterator: function(aStart) {\n      return new ICAL.RecurIterator({\n        rule: this,\n        dtstart: aStart\n      });\n    },\n\n    /**\n     * Returns a clone of the recurrence object.\n     *\n     * @return {ICAL.Recur}      The cloned object\n     */\n    clone: function clone() {\n      return new ICAL.Recur(this.toJSON());\n    },\n\n    /**\n     * Checks if the current rule is finite, i.e. has a count or until part.\n     *\n     * @return {Boolean}        True, if the rule is finite\n     */\n    isFinite: function isfinite() {\n      return !!(this.count || this.until);\n    },\n\n    /**\n     * Checks if the current rule has a count part, and not limited by an until\n     * part.\n     *\n     * @return {Boolean}        True, if the rule is by count\n     */\n    isByCount: function isbycount() {\n      return !!(this.count && !this.until);\n    },\n\n    /**\n     * Adds a component (part) to the recurrence rule. This is not a component\n     * in the sense of {@link ICAL.Component}, but a part of the recurrence\n     * rule, i.e. BYMONTH.\n     *\n     * @param {String} aType            The name of the component part\n     * @param {Array|String} aValue     The component value\n     */\n    addComponent: function addPart(aType, aValue) {\n      var ucname = aType.toUpperCase();\n      if (ucname in this.parts) {\n        this.parts[ucname].push(aValue);\n      } else {\n        this.parts[ucname] = [aValue];\n      }\n    },\n\n    /**\n     * Sets the component value for the given by-part.\n     *\n     * @param {String} aType        The component part name\n     * @param {Array} aValues       The component values\n     */\n    setComponent: function setComponent(aType, aValues) {\n      this.parts[aType.toUpperCase()] = aValues.slice();\n    },\n\n    /**\n     * Gets (a copy) of the requested component value.\n     *\n     * @param {String} aType        The component part name\n     * @return {Array}              The component part value\n     */\n    getComponent: function getComponent(aType) {\n      var ucname = aType.toUpperCase();\n      return (ucname in this.parts ? this.parts[ucname].slice() : []);\n    },\n\n    /**\n     * Retrieves the next occurrence after the given recurrence id. See the\n     * guide on {@tutorial terminology} for more details.\n     *\n     * NOTE: Currently, this method iterates all occurrences from the start\n     * date. It should not be called in a loop for performance reasons. If you\n     * would like to get more than one occurrence, you can iterate the\n     * occurrences manually, see the example on the\n     * {@link ICAL.Recur#iterator iterator} method.\n     *\n     * @param {ICAL.Time} aStartTime        The start of the event series\n     * @param {ICAL.Time} aRecurrenceId     The date of the last occurrence\n     * @return {ICAL.Time}                  The next occurrence after\n     */\n    getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {\n      var iter = this.iterator(aStartTime);\n      var next, cdt;\n\n      do {\n        next = iter.next();\n      } while (next && next.compare(aRecurrenceId) <= 0);\n\n      if (next && aRecurrenceId.zone) {\n        next.zone = aRecurrenceId.zone;\n      }\n\n      return next;\n    },\n\n    /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} data                               An object with members of the recurrence\n     * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n     * @param {Number=} data.interval                     The INTERVAL value\n     * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n     * @param {ICAL.Time=} data.until                     The end of the recurrence set\n     * @param {Number=} data.count                        The number of occurrences\n     * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n     * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n     * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n     * @param {Array.<String>=} data.byday                The BYDAY values\n     * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n     * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n     * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n     * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n     * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n     */\n    fromData: function(data) {\n      for (var key in data) {\n        var uckey = key.toUpperCase();\n\n        if (uckey in partDesign) {\n          if (Array.isArray(data[key])) {\n            this.parts[uckey] = data[key];\n          } else {\n            this.parts[uckey] = [data[key]];\n          }\n        } else {\n          this[key] = data[key];\n        }\n      }\n\n      if (this.interval && typeof this.interval != \"number\") {\n        optionDesign.INTERVAL(this.interval, this);\n      }\n\n      if (this.wkst && typeof this.wkst != \"number\") {\n        this.wkst = ICAL.Recur.icalDayToNumericDay(this.wkst);\n      }\n\n      if (this.until && !(this.until instanceof ICAL.Time)) {\n        this.until = ICAL.Time.fromString(this.until);\n      }\n    },\n\n    /**\n     * The jCal representation of this recurrence type.\n     * @return {Object}\n     */\n    toJSON: function() {\n      var res = Object.create(null);\n      res.freq = this.freq;\n\n      if (this.count) {\n        res.count = this.count;\n      }\n\n      if (this.interval > 1) {\n        res.interval = this.interval;\n      }\n\n      for (var k in this.parts) {\n        /* istanbul ignore if */\n        if (!this.parts.hasOwnProperty(k)) {\n          continue;\n        }\n        var kparts = this.parts[k];\n        if (Array.isArray(kparts) && kparts.length == 1) {\n          res[k.toLowerCase()] = kparts[0];\n        } else {\n          res[k.toLowerCase()] = ICAL.helpers.clone(this.parts[k]);\n        }\n      }\n\n      if (this.until) {\n        res.until = this.until.toString();\n      }\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        res.wkst = ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n      return res;\n    },\n\n    /**\n     * The string representation of this recurrence rule.\n     * @return {String}\n     */\n    toString: function icalrecur_toString() {\n      // TODO retain order\n      var str = \"FREQ=\" + this.freq;\n      if (this.count) {\n        str += \";COUNT=\" + this.count;\n      }\n      if (this.interval > 1) {\n        str += \";INTERVAL=\" + this.interval;\n      }\n      for (var k in this.parts) {\n        /* istanbul ignore else */\n        if (this.parts.hasOwnProperty(k)) {\n          str += \";\" + k + \"=\" + this.parts[k];\n        }\n      }\n      if (this.until) {\n        str += ';UNTIL=' + this.until.toICALString();\n      }\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        str += ';WKST=' + ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n      return str;\n    }\n  };\n\n  function parseNumericValue(type, min, max, value) {\n    var result = value;\n\n    if (value[0] === '+') {\n      result = value.substr(1);\n    }\n\n    result = ICAL.helpers.strictParseInt(result);\n\n    if (min !== undefined && value < min) {\n      throw new Error(\n        type + ': invalid value \"' + value + '\" must be > ' + min\n      );\n    }\n\n    if (max !== undefined && value > max) {\n      throw new Error(\n        type + ': invalid value \"' + value + '\" must be < ' + min\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Convert an ical representation of a day (SU, MO, etc..)\n   * into a numeric value of that day.\n   *\n   * @param {String} string     The iCalendar day name\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {Number}           Numeric value of given day\n   */\n  ICAL.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {\n    //XXX: this is here so we can deal\n    //     with possibly invalid string values.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    return ((DOW_MAP[string] - firstDow + 7) % 7) + 1;\n  };\n\n  /**\n   * Convert a numeric day value into its ical representation (SU, MO, etc..)\n   *\n   * @param {Number} num        Numeric value of given day\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {String}           The ICAL day value, e.g SU,MO,...\n   */\n  ICAL.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {\n    //XXX: this is here so we can deal with possibly invalid number values.\n    //     Also, this allows consistent mapping between day numbers and day\n    //     names for external users.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    var dow = (num + firstDow - ICAL.Time.SUNDAY);\n    if (dow > 7) {\n      dow -= 7;\n    }\n    return REVERSE_DOW_MAP[dow];\n  };\n\n  var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;\n  var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;\n\n  /**\n   * Possible frequency values for the FREQ part\n   * (YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY)\n   *\n   * @typedef {String} frequencyValues\n   * @memberof ICAL.Recur\n   */\n\n  var ALLOWED_FREQ = ['SECONDLY', 'MINUTELY', 'HOURLY',\n                      'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'];\n\n  var optionDesign = {\n    FREQ: function(value, dict, fmtIcal) {\n      // yes this is actually equal or faster then regex.\n      // upside here is we can enumerate the valid values.\n      if (ALLOWED_FREQ.indexOf(value) !== -1) {\n        dict.freq = value;\n      } else {\n        throw new Error(\n          'invalid frequency \"' + value + '\" expected: \"' +\n          ALLOWED_FREQ.join(', ') + '\"'\n        );\n      }\n    },\n\n    COUNT: function(value, dict, fmtIcal) {\n      dict.count = ICAL.helpers.strictParseInt(value);\n    },\n\n    INTERVAL: function(value, dict, fmtIcal) {\n      dict.interval = ICAL.helpers.strictParseInt(value);\n      if (dict.interval < 1) {\n        // 0 or negative values are not allowed, some engines seem to generate\n        // it though. Assume 1 instead.\n        dict.interval = 1;\n      }\n    },\n\n    UNTIL: function(value, dict, fmtIcal) {\n      if (value.length > 10) {\n        dict.until = ICAL.design.icalendar.value['date-time'].fromICAL(value);\n      } else {\n        dict.until = ICAL.design.icalendar.value.date.fromICAL(value);\n      }\n      if (!fmtIcal) {\n        dict.until = ICAL.Time.fromString(dict.until);\n      }\n    },\n\n    WKST: function(value, dict, fmtIcal) {\n      if (VALID_DAY_NAMES.test(value)) {\n        dict.wkst = ICAL.Recur.icalDayToNumericDay(value);\n      } else {\n        throw new Error('invalid WKST value \"' + value + '\"');\n      }\n    }\n  };\n\n  var partDesign = {\n    BYSECOND: parseNumericValue.bind(this, 'BYSECOND', 0, 60),\n    BYMINUTE: parseNumericValue.bind(this, 'BYMINUTE', 0, 59),\n    BYHOUR: parseNumericValue.bind(this, 'BYHOUR', 0, 23),\n    BYDAY: function(value) {\n      if (VALID_BYDAY_PART.test(value)) {\n        return value;\n      } else {\n        throw new Error('invalid BYDAY value \"' + value + '\"');\n      }\n    },\n    BYMONTHDAY: parseNumericValue.bind(this, 'BYMONTHDAY', -31, 31),\n    BYYEARDAY: parseNumericValue.bind(this, 'BYYEARDAY', -366, 366),\n    BYWEEKNO: parseNumericValue.bind(this, 'BYWEEKNO', -53, 53),\n    BYMONTH: parseNumericValue.bind(this, 'BYMONTH', 1, 12),\n    BYSETPOS: parseNumericValue.bind(this, 'BYSETPOS', -366, 366)\n  };\n\n\n  /**\n   * Creates a new {@link ICAL.Recur} instance from the passed string.\n   *\n   * @param {String} string         The string to parse\n   * @return {ICAL.Recur}           The created recurrence instance\n   */\n  ICAL.Recur.fromString = function(string) {\n    var data = ICAL.Recur._stringToData(string, false);\n    return new ICAL.Recur(data);\n  };\n\n  /**\n   * Creates a new {@link ICAL.Recur} instance using members from the passed\n   * data object.\n   *\n   * @param {Object} aData                              An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} aData.freq    The frequency value\n   * @param {Number=} aData.interval                    The INTERVAL value\n   * @param {ICAL.Time.weekDay=} aData.wkst             The week start value\n   * @param {ICAL.Time=} aData.until                    The end of the recurrence set\n   * @param {Number=} aData.count                       The number of occurrences\n   * @param {Array.<Number>=} aData.bysecond            The seconds for the BYSECOND part\n   * @param {Array.<Number>=} aData.byminute            The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} aData.byhour              The hours for the BYHOUR part\n   * @param {Array.<String>=} aData.byday               The BYDAY values\n   * @param {Array.<Number>=} aData.bymonthday          The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} aData.byyearday           The days for the BYYEARDAY part\n   * @param {Array.<Number>=} aData.byweekno            The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} aData.bymonth             The month for the BYMONTH part\n   * @param {Array.<Number>=} aData.bysetpos            The positionals for the BYSETPOS part\n   */\n  ICAL.Recur.fromData = function(aData) {\n    return new ICAL.Recur(aData);\n  };\n\n  /**\n   * Converts a recurrence string to a data object, suitable for the fromData\n   * method.\n   *\n   * @param {String} string     The string to parse\n   * @param {Boolean} fmtIcal   If true, the string is considered to be an\n   *                              iCalendar string\n   * @return {ICAL.Recur}       The recurrence instance\n   */\n  ICAL.Recur._stringToData = function(string, fmtIcal) {\n    var dict = Object.create(null);\n\n    // split is slower in FF but fast enough.\n    // v8 however this is faster then manual split?\n    var values = string.split(';');\n    var len = values.length;\n\n    for (var i = 0; i < len; i++) {\n      var parts = values[i].split('=');\n      var ucname = parts[0].toUpperCase();\n      var lcname = parts[0].toLowerCase();\n      var name = (fmtIcal ? lcname : ucname);\n      var value = parts[1];\n\n      if (ucname in partDesign) {\n        var partArr = value.split(',');\n        var partArrIdx = 0;\n        var partArrLen = partArr.length;\n\n        for (; partArrIdx < partArrLen; partArrIdx++) {\n          partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);\n        }\n        dict[name] = (partArr.length == 1 ? partArr[0] : partArr);\n      } else if (ucname in optionDesign) {\n        optionDesign[ucname](value, dict, fmtIcal);\n      } else {\n        // Don't swallow unknown values. Just set them as they are.\n        dict[lcname] = value;\n      }\n    }\n\n    return dict;\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.RecurIterator = (function() {\n\n  /**\n   * @classdesc\n   * An iterator for a single recurrence rule. This class usually doesn't have\n   * to be instanciated directly, the convenience method\n   * {@link ICAL.Recur#iterator} can be used.\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration from a previous run\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration\n   * from a previous run.\n   *\n   * @class\n   * @alias ICAL.RecurIterator\n   * @param {Object} options                The iterator options\n   * @param {ICAL.Recur} options.rule       The rule to iterate.\n   * @param {ICAL.Time} options.dtstart     The start date of the event.\n   * @param {Boolean=} options.initialized  When true, assume that options are\n   *        from a previously constructed iterator. Initialization will not be\n   *        repeated.\n   */\n  function icalrecur_iterator(options) {\n    this.fromData(options);\n  }\n\n  icalrecur_iterator.prototype = {\n\n    /**\n     * True when iteration is finished.\n     * @type {Boolean}\n     */\n    completed: false,\n\n    /**\n     * The rule that is being iterated\n     * @type {ICAL.Recur}\n     */\n    rule: null,\n\n    /**\n     * The start date of the event being iterated.\n     * @type {ICAL.Time}\n     */\n    dtstart: null,\n\n    /**\n     * The last occurrence that was returned from the\n     * {@link ICAL.RecurIterator#next} method.\n     * @type {ICAL.Time}\n     */\n    last: null,\n\n    /**\n     * The sequence number from the occurrence\n     * @type {Number}\n     */\n    occurrence_number: 0,\n\n    /**\n     * The indices used for the {@link ICAL.RecurIterator#by_data} object.\n     * @type {Object}\n     * @private\n     */\n    by_indices: null,\n\n    /**\n     * If true, the iterator has already been initialized\n     * @type {Boolean}\n     * @private\n     */\n    initialized: false,\n\n    /**\n     * The initializd by-data.\n     * @type {Object}\n     * @private\n     */\n    by_data: null,\n\n    /**\n     * The expanded yeardays\n     * @type {Array}\n     * @private\n     */\n    days: null,\n\n    /**\n     * The index in the {@link ICAL.RecurIterator#days} array.\n     * @type {Number}\n     * @private\n     */\n    days_index: 0,\n\n    /**\n     * Initialize the recurrence iterator from the passed data object. This\n     * method is usually not called directly, you can initialize the iterator\n     * through the constructor.\n     *\n     * @param {Object} options                The iterator options\n     * @param {ICAL.Recur} options.rule       The rule to iterate.\n     * @param {ICAL.Time} options.dtstart     The start date of the event.\n     * @param {Boolean=} options.initialized  When true, assume that options are\n     *        from a previously constructed iterator. Initialization will not be\n     *        repeated.\n     */\n    fromData: function(options) {\n      this.rule = ICAL.helpers.formatClassType(options.rule, ICAL.Recur);\n\n      if (!this.rule) {\n        throw new Error('iterator requires a (ICAL.Recur) rule');\n      }\n\n      this.dtstart = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n\n      if (!this.dtstart) {\n        throw new Error('iterator requires a (ICAL.Time) dtstart');\n      }\n\n      if (options.by_data) {\n        this.by_data = options.by_data;\n      } else {\n        this.by_data = ICAL.helpers.clone(this.rule.parts, true);\n      }\n\n      if (options.occurrence_number)\n        this.occurrence_number = options.occurrence_number;\n\n      this.days = options.days || [];\n      if (options.last) {\n        this.last = ICAL.helpers.formatClassType(options.last, ICAL.Time);\n      }\n\n      this.by_indices = options.by_indices;\n\n      if (!this.by_indices) {\n        this.by_indices = {\n          \"BYSECOND\": 0,\n          \"BYMINUTE\": 0,\n          \"BYHOUR\": 0,\n          \"BYDAY\": 0,\n          \"BYMONTH\": 0,\n          \"BYWEEKNO\": 0,\n          \"BYMONTHDAY\": 0\n        };\n      }\n\n      this.initialized = options.initialized || false;\n\n      if (!this.initialized) {\n        this.init();\n      }\n    },\n\n    /**\n     * Intialize the iterator\n     * @private\n     */\n    init: function icalrecur_iterator_init() {\n      this.initialized = true;\n      this.last = this.dtstart.clone();\n      var parts = this.by_data;\n\n      if (\"BYDAY\" in parts) {\n        // libical does this earlier when the rule is loaded, but we postpone to\n        // now so we can preserve the original order.\n        this.sort_byday_rules(parts.BYDAY);\n      }\n\n      // If the BYYEARDAY appares, no other date rule part may appear\n      if (\"BYYEARDAY\" in parts) {\n        if (\"BYMONTH\" in parts || \"BYWEEKNO\" in parts ||\n            \"BYMONTHDAY\" in parts || \"BYDAY\" in parts) {\n          throw new Error(\"Invalid BYYEARDAY rule\");\n        }\n      }\n\n      // BYWEEKNO and BYMONTHDAY rule parts may not both appear\n      if (\"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {\n        throw new Error(\"BYWEEKNO does not fit to BYMONTHDAY\");\n      }\n\n      // For MONTHLY recurrences (FREQ=MONTHLY) neither BYYEARDAY nor\n      // BYWEEKNO may appear.\n      if (this.rule.freq == \"MONTHLY\" &&\n          (\"BYYEARDAY\" in parts || \"BYWEEKNO\" in parts)) {\n        throw new Error(\"For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear\");\n      }\n\n      // For WEEKLY recurrences (FREQ=WEEKLY) neither BYMONTHDAY nor\n      // BYYEARDAY may appear.\n      if (this.rule.freq == \"WEEKLY\" &&\n          (\"BYYEARDAY\" in parts || \"BYMONTHDAY\" in parts)) {\n        throw new Error(\"For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear\");\n      }\n\n      // BYYEARDAY may only appear in YEARLY rules\n      if (this.rule.freq != \"YEARLY\" && \"BYYEARDAY\" in parts) {\n        throw new Error(\"BYYEARDAY may only appear in YEARLY rules\");\n      }\n\n      this.last.second = this.setup_defaults(\"BYSECOND\", \"SECONDLY\", this.dtstart.second);\n      this.last.minute = this.setup_defaults(\"BYMINUTE\", \"MINUTELY\", this.dtstart.minute);\n      this.last.hour = this.setup_defaults(\"BYHOUR\", \"HOURLY\", this.dtstart.hour);\n      this.last.day = this.setup_defaults(\"BYMONTHDAY\", \"DAILY\", this.dtstart.day);\n      this.last.month = this.setup_defaults(\"BYMONTH\", \"MONTHLY\", this.dtstart.month);\n\n      if (this.rule.freq == \"WEEKLY\") {\n        if (\"BYDAY\" in parts) {\n          var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);\n          if ((this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0) || wkdy < 0) {\n            // Initial time is after first day of BYDAY data\n            this.last.day += wkdy;\n          }\n        } else {\n          var dayName = ICAL.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());\n          parts.BYDAY = [dayName];\n        }\n      }\n\n      if (this.rule.freq == \"YEARLY\") {\n        for (;;) {\n          this.expand_year_days(this.last.year);\n          if (this.days.length > 0) {\n            break;\n          }\n          this.increment_year(this.rule.interval);\n        }\n\n        this._nextByYearDay();\n      }\n\n      if (this.rule.freq == \"MONTHLY\" && this.has_by_data(\"BYDAY\")) {\n        var tempLast = null;\n        var initLast = this.last.clone();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n\n        // Check every weekday in BYDAY with relative dow and pos.\n        for (var i in this.by_data.BYDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYDAY.hasOwnProperty(i)) {\n            continue;\n          }\n          this.last = initLast.clone();\n          var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i]);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var dayOfMonth = this.last.nthWeekDay(dow, pos);\n\n          // If |pos| >= 6, the byday is invalid for a monthly rule.\n          if (pos >= 6 || pos <= -6) {\n            throw new Error(\"Malformed values in BYDAY part\");\n          }\n\n          // If a Byday with pos=+/-5 is not in the current month it\n          // must be searched in the next months.\n          if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n            // Skip if we have already found a \"last\" in this month.\n            if (tempLast && tempLast.month == initLast.month) {\n              continue;\n            }\n            while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n              this.increment_month();\n              daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n              dayOfMonth = this.last.nthWeekDay(dow, pos);\n            }\n          }\n\n          this.last.day = dayOfMonth;\n          if (!tempLast || this.last.compare(tempLast) < 0) {\n            tempLast = this.last.clone();\n          }\n        }\n        this.last = tempLast.clone();\n\n        //XXX: This feels like a hack, but we need to initialize\n        //     the BYMONTHDAY case correctly and byDayAndMonthDay handles\n        //     this case. It accepts a special flag which will avoid incrementing\n        //     the initial value without the flag days that match the start time\n        //     would be missed.\n        if (this.has_by_data('BYMONTHDAY')) {\n          this._byDayAndMonthDay(true);\n        }\n\n        if (this.last.day > daysInMonth || this.last.day == 0) {\n          throw new Error(\"Malformed values in BYDAY part\");\n        }\n\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        if (this.last.day < 0) {\n          var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n          this.last.day = daysInMonth + this.last.day + 1;\n        }\n      }\n\n    },\n\n    /**\n     * Retrieve the next occurrence from the iterator.\n     * @return {ICAL.Time}\n     */\n    next: function icalrecur_iterator_next() {\n      var before = (this.last ? this.last.clone() : null);\n\n      if ((this.rule.count && this.occurrence_number >= this.rule.count) ||\n          (this.rule.until && this.last.compare(this.rule.until) > 0)) {\n\n        //XXX: right now this is just a flag and has no impact\n        //     we can simplify the above case to check for completed later.\n        this.completed = true;\n\n        return null;\n      }\n\n      if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {\n        // First of all, give the instance that was initialized\n        this.occurrence_number++;\n        return this.last;\n      }\n\n\n      var valid;\n      do {\n        valid = 1;\n\n        switch (this.rule.freq) {\n        case \"SECONDLY\":\n          this.next_second();\n          break;\n        case \"MINUTELY\":\n          this.next_minute();\n          break;\n        case \"HOURLY\":\n          this.next_hour();\n          break;\n        case \"DAILY\":\n          this.next_day();\n          break;\n        case \"WEEKLY\":\n          this.next_week();\n          break;\n        case \"MONTHLY\":\n          valid = this.next_month();\n          break;\n        case \"YEARLY\":\n          this.next_year();\n          break;\n\n        default:\n          return null;\n        }\n      } while (!this.check_contracting_rules() ||\n               this.last.compare(this.dtstart) < 0 ||\n               !valid);\n\n      // TODO is this valid?\n      if (this.last.compare(before) == 0) {\n        throw new Error(\"Same occurrence found twice, protecting \" +\n                        \"you from death by recursion\");\n      }\n\n      if (this.rule.until && this.last.compare(this.rule.until) > 0) {\n        this.completed = true;\n        return null;\n      } else {\n        this.occurrence_number++;\n        return this.last;\n      }\n    },\n\n    next_second: function next_second() {\n      return this.next_generic(\"BYSECOND\", \"SECONDLY\", \"second\", \"minute\");\n    },\n\n    increment_second: function increment_second(inc) {\n      return this.increment_generic(inc, \"second\", 60, \"minute\");\n    },\n\n    next_minute: function next_minute() {\n      return this.next_generic(\"BYMINUTE\", \"MINUTELY\",\n                               \"minute\", \"hour\", \"next_second\");\n    },\n\n    increment_minute: function increment_minute(inc) {\n      return this.increment_generic(inc, \"minute\", 60, \"hour\");\n    },\n\n    next_hour: function next_hour() {\n      return this.next_generic(\"BYHOUR\", \"HOURLY\", \"hour\",\n                               \"monthday\", \"next_minute\");\n    },\n\n    increment_hour: function increment_hour(inc) {\n      this.increment_generic(inc, \"hour\", 24, \"monthday\");\n    },\n\n    next_day: function next_day() {\n      var has_by_day = (\"BYDAY\" in this.by_data);\n      var this_freq = (this.rule.freq == \"DAILY\");\n\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n\n      if (this_freq) {\n        this.increment_monthday(this.rule.interval);\n      } else {\n        this.increment_monthday(1);\n      }\n\n      return 0;\n    },\n\n    next_week: function next_week() {\n      var end_of_data = 0;\n\n      if (this.next_weekday_by_week() == 0) {\n        return end_of_data;\n      }\n\n      if (this.has_by_data(\"BYWEEKNO\")) {\n        var idx = ++this.by_indices.BYWEEKNO;\n\n        if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {\n          this.by_indices.BYWEEKNO = 0;\n          end_of_data = 1;\n        }\n\n        // HACK should be first month of the year\n        this.last.month = 1;\n        this.last.day = 1;\n\n        var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];\n\n        this.last.day += 7 * week_no;\n\n        if (end_of_data) {\n          this.increment_year(1);\n        }\n      } else {\n        // Jump to the next week\n        this.increment_monthday(7 * this.rule.interval);\n      }\n\n      return end_of_data;\n    },\n\n    /**\n     * Normalize each by day rule for a given year/month.\n     * Takes into account ordering and negative rules\n     *\n     * @private\n     * @param {Number} year         Current year.\n     * @param {Number} month        Current month.\n     * @param {Array}  rules        Array of rules.\n     *\n     * @return {Array} sorted and normalized rules.\n     *                 Negative rules will be expanded to their\n     *                 correct positive values for easier processing.\n     */\n    normalizeByMonthDayRules: function(year, month, rules) {\n      var daysInMonth = ICAL.Time.daysInMonth(month, year);\n\n      // XXX: This is probably bad for performance to allocate\n      //      a new array for each month we scan, if possible\n      //      we should try to optimize this...\n      var newRules = [];\n\n      var ruleIdx = 0;\n      var len = rules.length;\n      var rule;\n\n      for (; ruleIdx < len; ruleIdx++) {\n        rule = rules[ruleIdx];\n\n        // if this rule falls outside of given\n        // month discard it.\n        if (Math.abs(rule) > daysInMonth) {\n          continue;\n        }\n\n        // negative case\n        if (rule < 0) {\n          // we add (not subtract it is a negative number)\n          // one from the rule because 1 === last day of month\n          rule = daysInMonth + (rule + 1);\n        } else if (rule === 0) {\n          // skip zero: it is invalid.\n          continue;\n        }\n\n        // only add unique items...\n        if (newRules.indexOf(rule) === -1) {\n          newRules.push(rule);\n        }\n\n      }\n\n      // unique and sort\n      return newRules.sort(function(a, b) { return a - b; });\n    },\n\n    /**\n     * NOTES:\n     * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)\n     * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when\n     * both conditions match a given date (this.last.day) iteration stops.\n     *\n     * @private\n     * @param {Boolean=} isInit     When given true will not increment the\n     *                                current day (this.last).\n     */\n    _byDayAndMonthDay: function(isInit) {\n      var byMonthDay; // setup in initMonth\n      var byDay = this.by_data.BYDAY;\n\n      var date;\n      var dateIdx = 0;\n      var dateLen; // setup in initMonth\n      var dayLen = byDay.length;\n\n      // we are not valid by default\n      var dataIsValid = 0;\n\n      var daysInMonth;\n      var self = this;\n      // we need a copy of this, because a DateTime gets normalized\n      // automatically if the day is out of range. At some points we\n      // set the last day to 0 to start counting.\n      var lastDay = this.last.day;\n\n      function initMonth() {\n        daysInMonth = ICAL.Time.daysInMonth(\n          self.last.month, self.last.year\n        );\n\n        byMonthDay = self.normalizeByMonthDayRules(\n          self.last.year,\n          self.last.month,\n          self.by_data.BYMONTHDAY\n        );\n\n        dateLen = byMonthDay.length;\n\n        // For the case of more than one occurrence in one month\n        // we have to be sure to start searching after the last\n        // found date or at the last BYMONTHDAY, unless we are\n        // initializing the iterator because in this case we have\n        // to consider the last found date too.\n        while (byMonthDay[dateIdx] <= lastDay &&\n               !(isInit && byMonthDay[dateIdx] == lastDay) &&\n               dateIdx < dateLen - 1) {\n          dateIdx++;\n        }\n      }\n\n      function nextMonth() {\n        // since the day is incremented at the start\n        // of the loop below, we need to start at 0\n        lastDay = 0;\n        self.increment_month();\n        dateIdx = 0;\n        initMonth();\n      }\n\n      initMonth();\n\n      // should come after initMonth\n      if (isInit) {\n        lastDay -= 1;\n      }\n\n      // Use a counter to avoid an infinite loop with malformed rules.\n      // Stop checking after 4 years so we consider also a leap year.\n      var monthsCounter = 48;\n\n      while (!dataIsValid && monthsCounter) {\n        monthsCounter--;\n        // increment the current date. This is really\n        // important otherwise we may fall into the infinite\n        // loop trap. The initial date takes care of the case\n        // where the current date is the date we are looking\n        // for.\n        date = lastDay + 1;\n\n        if (date > daysInMonth) {\n          nextMonth();\n          continue;\n        }\n\n        // find next date\n        var next = byMonthDay[dateIdx++];\n\n        // this logic is dependant on the BYMONTHDAYS\n        // being in order (which is done by #normalizeByMonthDayRules)\n        if (next >= date) {\n          // if the next month day is in the future jump to it.\n          lastDay = next;\n        } else {\n          // in this case the 'next' monthday has past\n          // we must move to the month.\n          nextMonth();\n          continue;\n        }\n\n        // Now we can loop through the day rules to see\n        // if one matches the current month date.\n        for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {\n          var parts = this.ruleDayOfWeek(byDay[dayIdx]);\n          var pos = parts[0];\n          var dow = parts[1];\n\n          this.last.day = lastDay;\n          if (this.last.isNthWeekDay(dow, pos)) {\n            // when we find the valid one we can mark\n            // the conditions as met and break the loop.\n            // (Because we have this condition above\n            //  it will also break the parent loop).\n            dataIsValid = 1;\n            break;\n          }\n        }\n\n        // It is completely possible that the combination\n        // cannot be matched in the current month.\n        // When we reach the end of possible combinations\n        // in the current month we iterate to the next one.\n        // since dateIdx is incremented right after getting\n        // \"next\", we don't need dateLen -1 here.\n        if (!dataIsValid && dateIdx === dateLen) {\n          nextMonth();\n          continue;\n        }\n      }\n\n      if (monthsCounter <= 0) {\n        // Checked 4 years without finding a Byday that matches\n        // a Bymonthday. Maybe the rule is not correct.\n        throw new Error(\"Malformed values in BYDAY combined with BYMONTHDAY parts\");\n      }\n\n\n      return dataIsValid;\n    },\n\n    next_month: function next_month() {\n      var this_freq = (this.rule.freq == \"MONTHLY\");\n      var data_valid = 1;\n\n      if (this.next_hour() == 0) {\n        return data_valid;\n      }\n\n      if (this.has_by_data(\"BYDAY\") && this.has_by_data(\"BYMONTHDAY\")) {\n        data_valid = this._byDayAndMonthDay();\n      } else if (this.has_by_data(\"BYDAY\")) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var setpos = 0;\n        var setpos_total = 0;\n\n        if (this.has_by_data(\"BYSETPOS\")) {\n          var last_day = this.last.day;\n          for (var day = 1; day <= daysInMonth; day++) {\n            this.last.day = day;\n            if (this.is_day_in_byday(this.last)) {\n              setpos_total++;\n              if (day <= last_day) {\n                setpos++;\n              }\n            }\n          }\n          this.last.day = last_day;\n        }\n\n        data_valid = 0;\n        for (var day = this.last.day + 1; day <= daysInMonth; day++) {\n          this.last.day = day;\n\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") ||\n                this.check_set_position(++setpos) ||\n                this.check_set_position(setpos - setpos_total - 1)) {\n\n              data_valid = 1;\n              break;\n            }\n          }\n        }\n\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          this.increment_month();\n\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(1)) {\n              data_valid = 1;\n            }\n          } else {\n            data_valid = 0;\n          }\n        }\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        this.by_indices.BYMONTHDAY++;\n\n        if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {\n          this.by_indices.BYMONTHDAY = 0;\n          this.increment_month();\n        }\n\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];\n\n        if (day < 0) {\n          day = daysInMonth + day + 1;\n        }\n\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          data_valid = this.is_day_in_byday(this.last);\n        } else {\n          this.last.day = day;\n        }\n\n      } else {\n        this.increment_month();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        if (this.by_data.BYMONTHDAY[0] > daysInMonth) {\n          data_valid = 0;\n        } else {\n          this.last.day = this.by_data.BYMONTHDAY[0];\n        }\n      }\n\n      return data_valid;\n    },\n\n    next_weekday_by_week: function next_weekday_by_week() {\n      var end_of_data = 0;\n\n      if (this.next_hour() == 0) {\n        return end_of_data;\n      }\n\n      if (!this.has_by_data(\"BYDAY\")) {\n        return 1;\n      }\n\n      for (;;) {\n        var tt = new ICAL.Time();\n        this.by_indices.BYDAY++;\n\n        if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {\n          this.by_indices.BYDAY = 0;\n          end_of_data = 1;\n        }\n\n        var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];\n        var parts = this.ruleDayOfWeek(coded_day);\n        var dow = parts[1];\n\n        dow -= this.rule.wkst;\n\n        if (dow < 0) {\n          dow += 7;\n        }\n\n        tt.year = this.last.year;\n        tt.month = this.last.month;\n        tt.day = this.last.day;\n\n        var startOfWeek = tt.startDoyWeek(this.rule.wkst);\n\n        if (dow + startOfWeek < 1) {\n          // The selected date is in the previous year\n          if (!end_of_data) {\n            continue;\n          }\n        }\n\n        var next = ICAL.Time.fromDayOfYear(startOfWeek + dow,\n                                                  this.last.year);\n\n        /**\n         * The normalization horrors below are due to\n         * the fact that when the year/month/day changes\n         * it can effect the other operations that come after.\n         */\n        this.last.year = next.year;\n        this.last.month = next.month;\n        this.last.day = next.day;\n\n        return end_of_data;\n      }\n    },\n\n    next_year: function next_year() {\n\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n\n      if (++this.days_index == this.days.length) {\n        this.days_index = 0;\n        do {\n          this.increment_year(this.rule.interval);\n          this.expand_year_days(this.last.year);\n        } while (this.days.length == 0);\n      }\n\n      this._nextByYearDay();\n\n      return 1;\n    },\n\n    _nextByYearDay: function _nextByYearDay() {\n        var doy = this.days[this.days_index];\n        var year = this.last.year;\n        if (doy < 1) {\n            // Time.fromDayOfYear(doy, year) indexes relative to the\n            // start of the given year. That is different from the\n            // semantics of BYYEARDAY where negative indexes are an\n            // offset from the end of the given year.\n            doy += 1;\n            year += 1;\n        }\n        var next = ICAL.Time.fromDayOfYear(doy, year);\n        this.last.day = next.day;\n        this.last.month = next.month;\n    },\n\n    /**\n     * @param dow (eg: '1TU', '-1MO')\n     * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday\n     * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart\n     */\n    ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {\n      var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);\n      if (matches) {\n        var pos = parseInt(matches[1] || 0, 10);\n        dow = ICAL.Recur.icalDayToNumericDay(matches[2], aWeekStart);\n        return [pos, dow];\n      } else {\n        return [0, 0];\n      }\n    },\n\n    next_generic: function next_generic(aRuleType, aInterval, aDateAttr,\n                                        aFollowingAttr, aPreviousIncr) {\n      var has_by_rule = (aRuleType in this.by_data);\n      var this_freq = (this.rule.freq == aInterval);\n      var end_of_data = 0;\n\n      if (aPreviousIncr && this[aPreviousIncr]() == 0) {\n        return end_of_data;\n      }\n\n      if (has_by_rule) {\n        this.by_indices[aRuleType]++;\n        var idx = this.by_indices[aRuleType];\n        var dta = this.by_data[aRuleType];\n\n        if (this.by_indices[aRuleType] == dta.length) {\n          this.by_indices[aRuleType] = 0;\n          end_of_data = 1;\n        }\n        this.last[aDateAttr] = dta[this.by_indices[aRuleType]];\n      } else if (this_freq) {\n        this[\"increment_\" + aDateAttr](this.rule.interval);\n      }\n\n      if (has_by_rule && end_of_data && this_freq) {\n        this[\"increment_\" + aFollowingAttr](1);\n      }\n\n      return end_of_data;\n    },\n\n    increment_monthday: function increment_monthday(inc) {\n      for (var i = 0; i < inc; i++) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        this.last.day++;\n\n        if (this.last.day > daysInMonth) {\n          this.last.day -= daysInMonth;\n          this.increment_month();\n        }\n      }\n    },\n\n    increment_month: function increment_month() {\n      this.last.day = 1;\n      if (this.has_by_data(\"BYMONTH\")) {\n        this.by_indices.BYMONTH++;\n\n        if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {\n          this.by_indices.BYMONTH = 0;\n          this.increment_year(1);\n        }\n\n        this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];\n      } else {\n        if (this.rule.freq == \"MONTHLY\") {\n          this.last.month += this.rule.interval;\n        } else {\n          this.last.month++;\n        }\n\n        this.last.month--;\n        var years = ICAL.helpers.trunc(this.last.month / 12);\n        this.last.month %= 12;\n        this.last.month++;\n\n        if (years != 0) {\n          this.increment_year(years);\n        }\n      }\n    },\n\n    increment_year: function increment_year(inc) {\n      this.last.year += inc;\n    },\n\n    increment_generic: function increment_generic(inc, aDateAttr,\n                                                  aFactor, aNextIncrement) {\n      this.last[aDateAttr] += inc;\n      var nextunit = ICAL.helpers.trunc(this.last[aDateAttr] / aFactor);\n      this.last[aDateAttr] %= aFactor;\n      if (nextunit != 0) {\n        this[\"increment_\" + aNextIncrement](nextunit);\n      }\n    },\n\n    has_by_data: function has_by_data(aRuleType) {\n      return (aRuleType in this.rule.parts);\n    },\n\n    expand_year_days: function expand_year_days(aYear) {\n      var t = new ICAL.Time();\n      this.days = [];\n\n      // We need our own copy with a few keys set\n      var parts = {};\n      var rules = [\"BYDAY\", \"BYWEEKNO\", \"BYMONTHDAY\", \"BYMONTH\", \"BYYEARDAY\"];\n      for (var p in rules) {\n        /* istanbul ignore else */\n        if (rules.hasOwnProperty(p)) {\n          var part = rules[p];\n          if (part in this.rule.parts) {\n            parts[part] = this.rule.parts[part];\n          }\n        }\n      }\n\n      if (\"BYMONTH\" in parts && \"BYWEEKNO\" in parts) {\n        var valid = 1;\n        var validWeeks = {};\n        t.year = aYear;\n        t.isDate = true;\n\n        for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {\n          var month = this.by_data.BYMONTH[monthIdx];\n          t.month = month;\n          t.day = 1;\n          var first_week = t.weekNumber(this.rule.wkst);\n          t.day = ICAL.Time.daysInMonth(month, aYear);\n          var last_week = t.weekNumber(this.rule.wkst);\n          for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {\n            validWeeks[monthIdx] = 1;\n          }\n        }\n\n        for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {\n          var weekno = this.by_data.BYWEEKNO[weekIdx];\n          if (weekno < 52) {\n            valid &= validWeeks[weekIdx];\n          } else {\n            valid = 0;\n          }\n        }\n\n        if (valid) {\n          delete parts.BYMONTH;\n        } else {\n          delete parts.BYWEEKNO;\n        }\n      }\n\n      var partCount = Object.keys(parts).length;\n\n      if (partCount == 0) {\n        var t1 = this.dtstart.clone();\n        t1.year = this.last.year;\n        this.days.push(t1.dayOfYear());\n      } else if (partCount == 1 && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var t2 = this.dtstart.clone();\n          t2.year = aYear;\n          t2.month = this.by_data.BYMONTH[monthkey];\n          t2.isDate = true;\n          this.days.push(t2.dayOfYear());\n        }\n      } else if (partCount == 1 && \"BYMONTHDAY\" in parts) {\n        for (var monthdaykey in this.by_data.BYMONTHDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n            continue;\n          }\n          var t3 = this.dtstart.clone();\n          var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n          if (day_ < 0) {\n            var daysInMonth = ICAL.Time.daysInMonth(t3.month, aYear);\n            day_ = day_ + daysInMonth + 1;\n          }\n          t3.day = day_;\n          t3.year = aYear;\n          t3.isDate = true;\n          this.days.push(t3.dayOfYear());\n        }\n      } else if (partCount == 2 &&\n                 \"BYMONTHDAY\" in parts &&\n                 \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var month_ = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month_, aYear);\n          for (var monthdaykey in this.by_data.BYMONTHDAY) {\n            /* istanbul ignore if */\n            if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n              continue;\n            }\n            var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n            if (day_ < 0) {\n              day_ = day_ + daysInMonth + 1;\n            }\n            t.day = day_;\n            t.month = month_;\n            t.year = aYear;\n            t.isDate = true;\n\n            this.days.push(t.dayOfYear());\n          }\n        }\n      } else if (partCount == 1 && \"BYWEEKNO\" in parts) {\n        // TODO unimplemented in libical\n      } else if (partCount == 2 &&\n                 \"BYWEEKNO\" in parts &&\n                 \"BYMONTHDAY\" in parts) {\n        // TODO unimplemented in libical\n      } else if (partCount == 1 && \"BYDAY\" in parts) {\n        this.days = this.days.concat(this.expand_by_day(aYear));\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n          var month = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month, aYear);\n\n          t.year = aYear;\n          t.month = this.by_data.BYMONTH[monthkey];\n          t.day = 1;\n          t.isDate = true;\n\n          var first_dow = t.dayOfWeek();\n          var doy_offset = t.dayOfYear() - 1;\n\n          t.day = daysInMonth;\n          var last_dow = t.dayOfWeek();\n\n          if (this.has_by_data(\"BYSETPOS\")) {\n            var set_pos_counter = 0;\n            var by_month_day = [];\n            for (var day = 1; day <= daysInMonth; day++) {\n              t.day = day;\n              if (this.is_day_in_byday(t)) {\n                by_month_day.push(day);\n              }\n            }\n\n            for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {\n              if (this.check_set_position(spIndex + 1) ||\n                  this.check_set_position(spIndex - by_month_day.length)) {\n                this.days.push(doy_offset + by_month_day[spIndex]);\n              }\n            }\n          } else {\n            for (var daycodedkey in this.by_data.BYDAY) {\n              /* istanbul ignore if */\n              if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {\n                continue;\n              }\n              var coded_day = this.by_data.BYDAY[daycodedkey];\n              var bydayParts = this.ruleDayOfWeek(coded_day);\n              var pos = bydayParts[0];\n              var dow = bydayParts[1];\n              var month_day;\n\n              var first_matching_day = ((dow + 7 - first_dow) % 7) + 1;\n              var last_matching_day = daysInMonth - ((last_dow + 7 - dow) % 7);\n\n              if (pos == 0) {\n                for (var day = first_matching_day; day <= daysInMonth; day += 7) {\n                  this.days.push(doy_offset + day);\n                }\n              } else if (pos > 0) {\n                month_day = first_matching_day + (pos - 1) * 7;\n\n                if (month_day <= daysInMonth) {\n                  this.days.push(doy_offset + month_day);\n                }\n              } else {\n                month_day = last_matching_day + (pos + 1) * 7;\n\n                if (month_day > 0) {\n                  this.days.push(doy_offset + month_day);\n                }\n              }\n            }\n          }\n        }\n        // Return dates in order of occurrence (1,2,3,...) instead\n        // of by groups of weekdays (1,8,15,...,2,9,16,...).\n        this.days.sort(function(a, b) { return a - b; }); // Comparator function allows to sort numbers.\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n          if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 &&\n                 \"BYDAY\" in parts &&\n                 \"BYMONTHDAY\" in parts &&\n                 \"BYMONTH\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n\n          if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 &&\n              this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n          var weekno = tt.weekNumber(this.rule.wkst);\n\n          if (this.by_data.BYWEEKNO.indexOf(weekno)) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 &&\n                 \"BYDAY\" in parts &&\n                 \"BYWEEKNO\" in parts &&\n                 \"BYMONTHDAY\" in parts) {\n        // TODO unimplemted in libical\n      } else if (partCount == 1 && \"BYYEARDAY\" in parts) {\n        this.days = this.days.concat(this.by_data.BYYEARDAY);\n      } else {\n        this.days = [];\n      }\n      return 0;\n    },\n\n    expand_by_day: function expand_by_day(aYear) {\n\n      var days_list = [];\n      var tmp = this.last.clone();\n\n      tmp.year = aYear;\n      tmp.month = 1;\n      tmp.day = 1;\n      tmp.isDate = true;\n\n      var start_dow = tmp.dayOfWeek();\n\n      tmp.month = 12;\n      tmp.day = 31;\n      tmp.isDate = true;\n\n      var end_dow = tmp.dayOfWeek();\n      var end_year_day = tmp.dayOfYear();\n\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n\n        if (pos == 0) {\n          var tmp_start_doy = ((dow + 7 - start_dow) % 7) + 1;\n\n          for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {\n            days_list.push(doy);\n          }\n\n        } else if (pos > 0) {\n          var first;\n          if (dow >= start_dow) {\n            first = dow - start_dow + 1;\n          } else {\n            first = dow - start_dow + 8;\n          }\n\n          days_list.push(first + (pos - 1) * 7);\n        } else {\n          var last;\n          pos = -pos;\n\n          if (dow <= end_dow) {\n            last = end_year_day - end_dow + dow;\n          } else {\n            last = end_year_day - end_dow + dow - 7;\n          }\n\n          days_list.push(last - (pos - 1) * 7);\n        }\n      }\n      return days_list;\n    },\n\n    is_day_in_byday: function is_day_in_byday(tt) {\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n        var this_dow = tt.dayOfWeek();\n\n        if ((pos == 0 && dow == this_dow) ||\n            (tt.nthWeekDay(dow, pos) == tt.day)) {\n          return 1;\n        }\n      }\n\n      return 0;\n    },\n\n    /**\n     * Checks if given value is in BYSETPOS.\n     *\n     * @private\n     * @param {Numeric} aPos position to check for.\n     * @return {Boolean} false unless BYSETPOS rules exist\n     *                   and the given value is present in rules.\n     */\n    check_set_position: function check_set_position(aPos) {\n      if (this.has_by_data('BYSETPOS')) {\n        var idx = this.by_data.BYSETPOS.indexOf(aPos);\n        // negative numbers are not false-y\n        return idx !== -1;\n      }\n      return false;\n    },\n\n    sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {\n      for (var i = 0; i < aRules.length; i++) {\n        for (var j = 0; j < i; j++) {\n          var one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];\n          var two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];\n\n          if (one > two) {\n            var tmp = aRules[i];\n            aRules[i] = aRules[j];\n            aRules[j] = tmp;\n          }\n        }\n      }\n    },\n\n    check_contract_restriction: function check_contract_restriction(aRuleType, v) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n      var pass = false;\n\n      if (aRuleType in this.by_data &&\n          ruleMapValue == icalrecur_iterator.CONTRACT) {\n\n        var ruleType = this.by_data[aRuleType];\n\n        for (var bydatakey in ruleType) {\n          /* istanbul ignore else */\n          if (ruleType.hasOwnProperty(bydatakey)) {\n            if (ruleType[bydatakey] == v) {\n              pass = true;\n              break;\n            }\n          }\n        }\n      } else {\n        // Not a contracting byrule or has no data, test passes\n        pass = true;\n      }\n      return pass;\n    },\n\n    check_contracting_rules: function check_contracting_rules() {\n      var dow = this.last.dayOfWeek();\n      var weekNo = this.last.weekNumber(this.rule.wkst);\n      var doy = this.last.dayOfYear();\n\n      return (this.check_contract_restriction(\"BYSECOND\", this.last.second) &&\n              this.check_contract_restriction(\"BYMINUTE\", this.last.minute) &&\n              this.check_contract_restriction(\"BYHOUR\", this.last.hour) &&\n              this.check_contract_restriction(\"BYDAY\", ICAL.Recur.numericDayToIcalDay(dow)) &&\n              this.check_contract_restriction(\"BYWEEKNO\", weekNo) &&\n              this.check_contract_restriction(\"BYMONTHDAY\", this.last.day) &&\n              this.check_contract_restriction(\"BYMONTH\", this.last.month) &&\n              this.check_contract_restriction(\"BYYEARDAY\", doy));\n    },\n\n    setup_defaults: function setup_defaults(aRuleType, req, deftime) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n\n      if (ruleMapValue != icalrecur_iterator.CONTRACT) {\n        if (!(aRuleType in this.by_data)) {\n          this.by_data[aRuleType] = [deftime];\n        }\n        if (this.rule.freq != req) {\n          return this.by_data[aRuleType][0];\n        }\n      }\n      return deftime;\n    },\n\n    /**\n     * Convert iterator into a serialize-able object.  Will preserve current\n     * iteration sequence to ensure the seamless continuation of the recurrence\n     * rule.\n     * @return {Object}\n     */\n    toJSON: function() {\n      var result = Object.create(null);\n\n      result.initialized = this.initialized;\n      result.rule = this.rule.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.by_data = this.by_data;\n      result.days = this.days;\n      result.last = this.last.toJSON();\n      result.by_indices = this.by_indices;\n      result.occurrence_number = this.occurrence_number;\n\n      return result;\n    }\n  };\n\n  icalrecur_iterator._indexMap = {\n    \"BYSECOND\": 0,\n    \"BYMINUTE\": 1,\n    \"BYHOUR\": 2,\n    \"BYDAY\": 3,\n    \"BYMONTHDAY\": 4,\n    \"BYYEARDAY\": 5,\n    \"BYWEEKNO\": 6,\n    \"BYMONTH\": 7,\n    \"BYSETPOS\": 8\n  };\n\n  icalrecur_iterator._expandMap = {\n    \"SECONDLY\": [1, 1, 1, 1, 1, 1, 1, 1],\n    \"MINUTELY\": [2, 1, 1, 1, 1, 1, 1, 1],\n    \"HOURLY\": [2, 2, 1, 1, 1, 1, 1, 1],\n    \"DAILY\": [2, 2, 2, 1, 1, 1, 1, 1],\n    \"WEEKLY\": [2, 2, 2, 2, 3, 3, 1, 1],\n    \"MONTHLY\": [2, 2, 2, 2, 2, 3, 3, 1],\n    \"YEARLY\": [2, 2, 2, 2, 2, 2, 2, 2]\n  };\n  icalrecur_iterator.UNKNOWN = 0;\n  icalrecur_iterator.CONTRACT = 1;\n  icalrecur_iterator.EXPAND = 2;\n  icalrecur_iterator.ILLEGAL = 3;\n\n  return icalrecur_iterator;\n\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.RecurExpansion = (function() {\n  function formatTime(item) {\n    return ICAL.helpers.formatClassType(item, ICAL.Time);\n  }\n\n  function compareTime(a, b) {\n    return a.compare(b);\n  }\n\n  function isRecurringComponent(comp) {\n    return comp.hasProperty('rdate') ||\n           comp.hasProperty('rrule') ||\n           comp.hasProperty('recurrence-id');\n  }\n\n  /**\n   * @classdesc\n   * Primary class for expanding recurring rules.  Can take multiple rrules,\n   * rdates, exdate(s) and iterate (in order) over each next occurrence.\n   *\n   * Once initialized this class can also be serialized saved and continue\n   * iteration from the last point.\n   *\n   * NOTE: it is intended that this class is to be used\n   *       with ICAL.Event which handles recurrence exceptions.\n   *\n   * @example\n   * // assuming event is a parsed ical component\n   * var event;\n   *\n   * var expand = new ICAL.RecurExpansion({\n   *   component: event,\n   *   dtstart: event.getFirstPropertyValue('dtstart')\n   * });\n   *\n   * // remember there are infinite rules\n   * // so it is a good idea to limit the scope\n   * // of the iterations then resume later on.\n   *\n   * // next is always an ICAL.Time or null\n   * var next;\n   *\n   * while (someCondition && (next = expand.next())) {\n   *   // do something with next\n   * }\n   *\n   * // save instance for later\n   * var json = JSON.stringify(expand);\n   *\n   * //...\n   *\n   * // NOTE: if the component's properties have\n   * //       changed you will need to rebuild the\n   * //       class and start over. This only works\n   * //       when the component's recurrence info is the same.\n   * var expand = new ICAL.RecurExpansion(JSON.parse(json));\n   *\n   * @description\n   * The options object can be filled with the specified initial values. It can\n   * also contain additional members, as a result of serializing a previous\n   * expansion state, as shown in the example.\n   *\n   * @class\n   * @alias ICAL.RecurExpansion\n   * @param {Object} options\n   *        Recurrence expansion options\n   * @param {ICAL.Time} options.dtstart\n   *        Start time of the event\n   * @param {ICAL.Component=} options.component\n   *        Component for expansion, required if not resuming.\n   */\n  function RecurExpansion(options) {\n    this.ruleDates = [];\n    this.exDates = [];\n    this.fromData(options);\n  }\n\n  RecurExpansion.prototype = {\n    /**\n     * True when iteration is fully completed.\n     * @type {Boolean}\n     */\n    complete: false,\n\n    /**\n     * Array of rrule iterators.\n     *\n     * @type {ICAL.RecurIterator[]}\n     * @private\n     */\n    ruleIterators: null,\n\n    /**\n     * Array of rdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */\n    ruleDates: null,\n\n    /**\n     * Array of exdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */\n    exDates: null,\n\n    /**\n     * Current position in ruleDates array.\n     * @type {Number}\n     * @private\n     */\n    ruleDateInc: 0,\n\n    /**\n     * Current position in exDates array\n     * @type {Number}\n     * @private\n     */\n    exDateInc: 0,\n\n    /**\n     * Current negative date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */\n    exDate: null,\n\n    /**\n     * Current additional date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */\n    ruleDate: null,\n\n    /**\n     * Start date of recurring rules.\n     *\n     * @type {ICAL.Time}\n     */\n    dtstart: null,\n\n    /**\n     * Last expanded time\n     *\n     * @type {ICAL.Time}\n     */\n    last: null,\n\n    /**\n     * Initialize the recurrence expansion from the data object. The options\n     * object may also contain additional members, see the\n     * {@link ICAL.RecurExpansion constructor} for more details.\n     *\n     * @param {Object} options\n     *        Recurrence expansion options\n     * @param {ICAL.Time} options.dtstart\n     *        Start time of the event\n     * @param {ICAL.Component=} options.component\n     *        Component for expansion, required if not resuming.\n     */\n    fromData: function(options) {\n      var start = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n\n      if (!start) {\n        throw new Error('.dtstart (ICAL.Time) must be given');\n      } else {\n        this.dtstart = start;\n      }\n\n      if (options.component) {\n        this._init(options.component);\n      } else {\n        this.last = formatTime(options.last) || start.clone();\n\n        if (!options.ruleIterators) {\n          throw new Error('.ruleIterators or .component must be given');\n        }\n\n        this.ruleIterators = options.ruleIterators.map(function(item) {\n          return ICAL.helpers.formatClassType(item, ICAL.RecurIterator);\n        });\n\n        this.ruleDateInc = options.ruleDateInc;\n        this.exDateInc = options.exDateInc;\n\n        if (options.ruleDates) {\n          this.ruleDates = options.ruleDates.map(formatTime);\n          this.ruleDate = this.ruleDates[this.ruleDateInc];\n        }\n\n        if (options.exDates) {\n          this.exDates = options.exDates.map(formatTime);\n          this.exDate = this.exDates[this.exDateInc];\n        }\n\n        if (typeof(options.complete) !== 'undefined') {\n          this.complete = options.complete;\n        }\n      }\n    },\n\n    /**\n     * Retrieve the next occurrence in the series.\n     * @return {ICAL.Time}\n     */\n    next: function() {\n      var iter;\n      var ruleOfDay;\n      var next;\n      var compare;\n\n      var maxTries = 500;\n      var currentTry = 0;\n\n      while (true) {\n        if (currentTry++ > maxTries) {\n          throw new Error(\n            'max tries have occured, rule may be impossible to forfill.'\n          );\n        }\n\n        next = this.ruleDate;\n        iter = this._nextRecurrenceIter(this.last);\n\n        // no more matches\n        // because we increment the rule day or rule\n        // _after_ we choose a value this should be\n        // the only spot where we need to worry about the\n        // end of events.\n        if (!next && !iter) {\n          // there are no more iterators or rdates\n          this.complete = true;\n          break;\n        }\n\n        // no next rule day or recurrence rule is first.\n        if (!next || (iter && next.compare(iter.last) > 0)) {\n          // must be cloned, recur will reuse the time element.\n          next = iter.last.clone();\n          // move to next so we can continue\n          iter.next();\n        }\n\n        // if the ruleDate is still next increment it.\n        if (this.ruleDate === next) {\n          this._nextRuleDay();\n        }\n\n        this.last = next;\n\n        // check the negative rules\n        if (this.exDate) {\n          compare = this.exDate.compare(this.last);\n\n          if (compare < 0) {\n            this._nextExDay();\n          }\n\n          // if the current rule is excluded skip it.\n          if (compare === 0) {\n            this._nextExDay();\n            continue;\n          }\n        }\n\n        //XXX: The spec states that after we resolve the final\n        //     list of dates we execute exdate this seems somewhat counter\n        //     intuitive to what I have seen most servers do so for now\n        //     I exclude based on the original date not the one that may\n        //     have been modified by the exception.\n        return this.last;\n      }\n    },\n\n    /**\n     * Converts object into a serialize-able format. This format can be passed\n     * back into the expansion to resume iteration.\n     * @return {Object}\n     */\n    toJSON: function() {\n      function toJSON(item) {\n        return item.toJSON();\n      }\n\n      var result = Object.create(null);\n      result.ruleIterators = this.ruleIterators.map(toJSON);\n\n      if (this.ruleDates) {\n        result.ruleDates = this.ruleDates.map(toJSON);\n      }\n\n      if (this.exDates) {\n        result.exDates = this.exDates.map(toJSON);\n      }\n\n      result.ruleDateInc = this.ruleDateInc;\n      result.exDateInc = this.exDateInc;\n      result.last = this.last.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.complete = this.complete;\n\n      return result;\n    },\n\n    /**\n     * Extract all dates from the properties in the given component. The\n     * properties will be filtered by the property name.\n     *\n     * @private\n     * @param {ICAL.Component} component        The component to search in\n     * @param {String} propertyName             The property name to search for\n     * @return {ICAL.Time[]}                    The extracted dates.\n     */\n    _extractDates: function(component, propertyName) {\n      function handleProp(prop) {\n        idx = ICAL.helpers.binsearchInsert(\n          result,\n          prop,\n          compareTime\n        );\n\n        // ordered insert\n        result.splice(idx, 0, prop);\n      }\n\n      var result = [];\n      var props = component.getAllProperties(propertyName);\n      var len = props.length;\n      var i = 0;\n      var prop;\n\n      var idx;\n\n      for (; i < len; i++) {\n        props[i].getValues().forEach(handleProp);\n      }\n\n      return result;\n    },\n\n    /**\n     * Initialize the recurrence expansion.\n     *\n     * @private\n     * @param {ICAL.Component} component    The component to initialize from.\n     */\n    _init: function(component) {\n      this.ruleIterators = [];\n\n      this.last = this.dtstart.clone();\n\n      // to provide api consistency non-recurring\n      // events can also use the iterator though it will\n      // only return a single time.\n      if (!isRecurringComponent(component)) {\n        this.ruleDate = this.last.clone();\n        this.complete = true;\n        return;\n      }\n\n      if (component.hasProperty('rdate')) {\n        this.ruleDates = this._extractDates(component, 'rdate');\n\n        // special hack for cases where first rdate is prior\n        // to the start date. We only check for the first rdate.\n        // This is mostly for google's crazy recurring date logic\n        // (contacts birthdays).\n        if ((this.ruleDates[0]) &&\n            (this.ruleDates[0].compare(this.dtstart) < 0)) {\n\n          this.ruleDateInc = 0;\n          this.last = this.ruleDates[0].clone();\n        } else {\n          this.ruleDateInc = ICAL.helpers.binsearchInsert(\n            this.ruleDates,\n            this.last,\n            compareTime\n          );\n        }\n\n        this.ruleDate = this.ruleDates[this.ruleDateInc];\n      }\n\n      if (component.hasProperty('rrule')) {\n        var rules = component.getAllProperties('rrule');\n        var i = 0;\n        var len = rules.length;\n\n        var rule;\n        var iter;\n\n        for (; i < len; i++) {\n          rule = rules[i].getFirstValue();\n          iter = rule.iterator(this.dtstart);\n          this.ruleIterators.push(iter);\n\n          // increment to the next occurrence so future\n          // calls to next return times beyond the initial iteration.\n          // XXX: I find this suspicious might be a bug?\n          iter.next();\n        }\n      }\n\n      if (component.hasProperty('exdate')) {\n        this.exDates = this._extractDates(component, 'exdate');\n        // if we have a .last day we increment the index to beyond it.\n        this.exDateInc = ICAL.helpers.binsearchInsert(\n          this.exDates,\n          this.last,\n          compareTime\n        );\n\n        this.exDate = this.exDates[this.exDateInc];\n      }\n    },\n\n    /**\n     * Advance to the next exdate\n     * @private\n     */\n    _nextExDay: function() {\n      this.exDate = this.exDates[++this.exDateInc];\n    },\n\n    /**\n     * Advance to the next rule date\n     * @private\n     */\n    _nextRuleDay: function() {\n      this.ruleDate = this.ruleDates[++this.ruleDateInc];\n    },\n\n    /**\n     * Find and return the recurrence rule with the most recent event and\n     * return it.\n     *\n     * @private\n     * @return {?ICAL.RecurIterator}    Found iterator.\n     */\n    _nextRecurrenceIter: function() {\n      var iters = this.ruleIterators;\n\n      if (iters.length === 0) {\n        return null;\n      }\n\n      var len = iters.length;\n      var iter;\n      var iterTime;\n      var iterIdx = 0;\n      var chosenIter;\n\n      // loop through each iterator\n      for (; iterIdx < len; iterIdx++) {\n        iter = iters[iterIdx];\n        iterTime = iter.last;\n\n        // if iteration is complete\n        // then we must exclude it from\n        // the search and remove it.\n        if (iter.completed) {\n          len--;\n          if (iterIdx !== 0) {\n            iterIdx--;\n          }\n          iters.splice(iterIdx, 1);\n          continue;\n        }\n\n        // find the most recent possible choice\n        if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {\n          // that iterator is saved\n          chosenIter = iter;\n        }\n      }\n\n      // the chosen iterator is returned but not mutated\n      // this iterator contains the most recent event.\n      return chosenIter;\n    }\n  };\n\n  return RecurExpansion;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.Event = (function() {\n\n  /**\n   * @classdesc\n   * ICAL.js is organized into multiple layers. The bottom layer is a raw jCal\n   * object, followed by the component/property layer. The highest level is the\n   * event representation, which this class is part of. See the\n   * {@tutorial layers} guide for more details.\n   *\n   * @class\n   * @alias ICAL.Event\n   * @param {ICAL.Component=} component         The ICAL.Component to base this event on\n   * @param {Object} options                    Options for this event\n   * @param {Boolean} options.strictExceptions\n   *          When true, will verify exceptions are related by their UUID\n   * @param {Array<ICAL.Component|ICAL.Event>} options.exceptions\n   *          Exceptions to this event, either as components or events. If not\n   *            specified exceptions will automatically be set in relation of\n   *            component's parent\n   */\n  function Event(component, options) {\n    if (!(component instanceof ICAL.Component)) {\n      options = component;\n      component = null;\n    }\n\n    if (component) {\n      this.component = component;\n    } else {\n      this.component = new ICAL.Component('vevent');\n    }\n\n    this._rangeExceptionCache = Object.create(null);\n    this.exceptions = Object.create(null);\n    this.rangeExceptions = [];\n\n    if (options && options.strictExceptions) {\n      this.strictExceptions = options.strictExceptions;\n    }\n\n    if (options && options.exceptions) {\n      options.exceptions.forEach(this.relateException, this);\n    } else if (this.component.parent && !this.isRecurrenceException()) {\n      this.component.parent.getAllSubcomponents('vevent').forEach(function(event) {\n        if (event.hasProperty('recurrence-id')) {\n          this.relateException(event);\n        }\n      }, this);\n    }\n  }\n\n  Event.prototype = {\n\n    THISANDFUTURE: 'THISANDFUTURE',\n\n    /**\n     * List of related event exceptions.\n     *\n     * @type {ICAL.Event[]}\n     */\n    exceptions: null,\n\n    /**\n     * When true, will verify exceptions are related by their UUID.\n     *\n     * @type {Boolean}\n     */\n    strictExceptions: false,\n\n    /**\n     * Relates a given event exception to this object.  If the given component\n     * does not share the UID of this event it cannot be related and will throw\n     * an exception.\n     *\n     * If this component is an exception it cannot have other exceptions\n     * related to it.\n     *\n     * @param {ICAL.Component|ICAL.Event} obj       Component or event\n     */\n    relateException: function(obj) {\n      if (this.isRecurrenceException()) {\n        throw new Error('cannot relate exception to exceptions');\n      }\n\n      if (obj instanceof ICAL.Component) {\n        obj = new ICAL.Event(obj);\n      }\n\n      if (this.strictExceptions && obj.uid !== this.uid) {\n        throw new Error('attempted to relate unrelated exception');\n      }\n\n      var id = obj.recurrenceId.toString();\n\n      // we don't sort or manage exceptions directly\n      // here the recurrence expander handles that.\n      this.exceptions[id] = obj;\n\n      // index RANGE=THISANDFUTURE exceptions so we can\n      // look them up later in getOccurrenceDetails.\n      if (obj.modifiesFuture()) {\n        var item = [\n          obj.recurrenceId.toUnixTime(), id\n        ];\n\n        // we keep them sorted so we can find the nearest\n        // value later on...\n        var idx = ICAL.helpers.binsearchInsert(\n          this.rangeExceptions,\n          item,\n          compareRangeException\n        );\n\n        this.rangeExceptions.splice(idx, 0, item);\n      }\n    },\n\n    /**\n     * Checks if this record is an exception and has the RANGE=THISANDFUTURE\n     * value.\n     *\n     * @return {Boolean}        True, when exception is within range\n     */\n    modifiesFuture: function() {\n      if (!this.component.hasProperty('recurrence-id')) {\n        return false;\n      }\n\n      var range = this.component.getFirstProperty('recurrence-id').getParameter('range');\n      return range === this.THISANDFUTURE;\n    },\n\n    /**\n     * Finds the range exception nearest to the given date.\n     *\n     * @param {ICAL.Time} time usually an occurrence time of an event\n     * @return {?ICAL.Event} the related event/exception or null\n     */\n    findRangeException: function(time) {\n      if (!this.rangeExceptions.length) {\n        return null;\n      }\n\n      var utc = time.toUnixTime();\n      var idx = ICAL.helpers.binsearchInsert(\n        this.rangeExceptions,\n        [utc],\n        compareRangeException\n      );\n\n      idx -= 1;\n\n      // occurs before\n      if (idx < 0) {\n        return null;\n      }\n\n      var rangeItem = this.rangeExceptions[idx];\n\n      /* istanbul ignore next: sanity check only */\n      if (utc < rangeItem[0]) {\n        return null;\n      }\n\n      return rangeItem[1];\n    },\n\n    /**\n     * This object is returned by {@link ICAL.Event#getOccurrenceDetails getOccurrenceDetails}\n     *\n     * @typedef {Object} occurrenceDetails\n     * @memberof ICAL.Event\n     * @property {ICAL.Time} recurrenceId       The passed in recurrence id\n     * @property {ICAL.Event} item              The occurrence\n     * @property {ICAL.Time} startDate          The start of the occurrence\n     * @property {ICAL.Time} endDate            The end of the occurrence\n     */\n\n    /**\n     * Returns the occurrence details based on its start time.  If the\n     * occurrence has an exception will return the details for that exception.\n     *\n     * NOTE: this method is intend to be used in conjunction\n     *       with the {@link ICAL.Event#iterator iterator} method.\n     *\n     * @param {ICAL.Time} occurrence time occurrence\n     * @return {ICAL.Event.occurrenceDetails} Information about the occurrence\n     */\n    getOccurrenceDetails: function(occurrence) {\n      var id = occurrence.toString();\n      var utcId = occurrence.convertToZone(ICAL.Timezone.utcTimezone).toString();\n      var item;\n      var result = {\n        //XXX: Clone?\n        recurrenceId: occurrence\n      };\n\n      if (id in this.exceptions) {\n        item = result.item = this.exceptions[id];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else if (utcId in this.exceptions) {\n        item = this.exceptions[utcId];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else {\n        // range exceptions (RANGE=THISANDFUTURE) have a\n        // lower priority then direct exceptions but\n        // must be accounted for first. Their item is\n        // always the first exception with the range prop.\n        var rangeExceptionId = this.findRangeException(\n          occurrence\n        );\n        var end;\n\n        if (rangeExceptionId) {\n          var exception = this.exceptions[rangeExceptionId];\n\n          // range exception must modify standard time\n          // by the difference (if any) in start/end times.\n          result.item = exception;\n\n          var startDiff = this._rangeExceptionCache[rangeExceptionId];\n\n          if (!startDiff) {\n            var original = exception.recurrenceId.clone();\n            var newStart = exception.startDate.clone();\n\n            // zones must be same otherwise subtract may be incorrect.\n            original.zone = newStart.zone;\n            startDiff = newStart.subtractDate(original);\n\n            this._rangeExceptionCache[rangeExceptionId] = startDiff;\n          }\n\n          var start = occurrence.clone();\n          start.zone = exception.startDate.zone;\n          start.addDuration(startDiff);\n\n          end = start.clone();\n          end.addDuration(exception.duration);\n\n          result.startDate = start;\n          result.endDate = end;\n        } else {\n          // no range exception standard expansion\n          end = occurrence.clone();\n          end.addDuration(this.duration);\n\n          result.endDate = end;\n          result.startDate = occurrence;\n          result.item = this;\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * Builds a recur expansion instance for a specific point in time (defaults\n     * to startDate).\n     *\n     * @param {ICAL.Time} startTime     Starting point for expansion\n     * @return {ICAL.RecurExpansion}    Expansion object\n     */\n    iterator: function(startTime) {\n      return new ICAL.RecurExpansion({\n        component: this.component,\n        dtstart: startTime || this.startDate\n      });\n    },\n\n    /**\n     * Checks if the event is recurring\n     *\n     * @return {Boolean}        True, if event is recurring\n     */\n    isRecurring: function() {\n      var comp = this.component;\n      return comp.hasProperty('rrule') || comp.hasProperty('rdate');\n    },\n\n    /**\n     * Checks if the event describes a recurrence exception. See\n     * {@tutorial terminology} for details.\n     *\n     * @return {Boolean}    True, if the event describes a recurrence exception\n     */\n    isRecurrenceException: function() {\n      return this.component.hasProperty('recurrence-id');\n    },\n\n    /**\n     * Returns the types of recurrences this event may have.\n     *\n     * Returned as an object with the following possible keys:\n     *\n     *    - YEARLY\n     *    - MONTHLY\n     *    - WEEKLY\n     *    - DAILY\n     *    - MINUTELY\n     *    - SECONDLY\n     *\n     * @return {Object.<ICAL.Recur.frequencyValues, Boolean>}\n     *          Object of recurrence flags\n     */\n    getRecurrenceTypes: function() {\n      var rules = this.component.getAllProperties('rrule');\n      var i = 0;\n      var len = rules.length;\n      var result = Object.create(null);\n\n      for (; i < len; i++) {\n        var value = rules[i].getFirstValue();\n        result[value.freq] = true;\n      }\n\n      return result;\n    },\n\n    /**\n     * The uid of this event\n     * @type {String}\n     */\n    get uid() {\n      return this._firstProp('uid');\n    },\n\n    set uid(value) {\n      this._setProp('uid', value);\n    },\n\n    /**\n     * The start date\n     * @type {ICAL.Time}\n     */\n    get startDate() {\n      return this._firstProp('dtstart');\n    },\n\n    set startDate(value) {\n      this._setTime('dtstart', value);\n    },\n\n    /**\n     * The end date. This can be the result directly from the property, or the\n     * end date calculated from start date and duration. Setting the property\n     * will remove any duration properties.\n     * @type {ICAL.Time}\n     */\n    get endDate() {\n      var endDate = this._firstProp('dtend');\n      if (!endDate) {\n          var duration = this._firstProp('duration');\n          endDate = this.startDate.clone();\n          if (duration) {\n              endDate.addDuration(duration);\n          } else if (endDate.isDate) {\n              endDate.day += 1;\n          }\n      }\n      return endDate;\n    },\n\n    set endDate(value) {\n      if (this.component.hasProperty('duration')) {\n        this.component.removeProperty('duration');\n      }\n      this._setTime('dtend', value);\n    },\n\n    /**\n     * The duration. This can be the result directly from the property, or the\n     * duration calculated from start date and end date. Setting the property\n     * will remove any `dtend` properties.\n     * @type {ICAL.Duration}\n     */\n    get duration() {\n      var duration = this._firstProp('duration');\n      if (!duration) {\n        return this.endDate.subtractDateTz(this.startDate);\n      }\n      return duration;\n    },\n\n    set duration(value) {\n      if (this.component.hasProperty('dtend')) {\n        this.component.removeProperty('dtend');\n      }\n\n      this._setProp('duration', value);\n    },\n\n    /**\n     * The location of the event.\n     * @type {String}\n     */\n    get location() {\n      return this._firstProp('location');\n    },\n\n    set location(value) {\n      return this._setProp('location', value);\n    },\n\n    /**\n     * The attendees in the event\n     * @type {ICAL.Property[]}\n     * @readonly\n     */\n    get attendees() {\n      //XXX: This is way lame we should have a better\n      //     data structure for this later.\n      return this.component.getAllProperties('attendee');\n    },\n\n\n    /**\n     * The event summary\n     * @type {String}\n     */\n    get summary() {\n      return this._firstProp('summary');\n    },\n\n    set summary(value) {\n      this._setProp('summary', value);\n    },\n\n    /**\n     * The event description.\n     * @type {String}\n     */\n    get description() {\n      return this._firstProp('description');\n    },\n\n    set description(value) {\n      this._setProp('description', value);\n    },\n\n    /**\n     * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)\n     * @type {String}\n     */\n    get color() {\n      return this._firstProp('color');\n    },\n\n    set color(value) {\n      this._setProp('color', value);\n    },\n\n    /**\n     * The organizer value as an uri. In most cases this is a mailto: uri, but\n     * it can also be something else, like urn:uuid:...\n     * @type {String}\n     */\n    get organizer() {\n      return this._firstProp('organizer');\n    },\n\n    set organizer(value) {\n      this._setProp('organizer', value);\n    },\n\n    /**\n     * The sequence value for this event. Used for scheduling\n     * see {@tutorial terminology}.\n     * @type {Number}\n     */\n    get sequence() {\n      return this._firstProp('sequence');\n    },\n\n    set sequence(value) {\n      this._setProp('sequence', value);\n    },\n\n    /**\n     * The recurrence id for this event. See {@tutorial terminology} for details.\n     * @type {ICAL.Time}\n     */\n    get recurrenceId() {\n      return this._firstProp('recurrence-id');\n    },\n\n    set recurrenceId(value) {\n      this._setTime('recurrence-id', value);\n    },\n\n    /**\n     * Set/update a time property's value.\n     * This will also update the TZID of the property.\n     *\n     * TODO: this method handles the case where we are switching\n     * from a known timezone to an implied timezone (one without TZID).\n     * This does _not_ handle the case of moving between a known\n     *  (by TimezoneService) timezone to an unknown timezone...\n     *\n     * We will not add/remove/update the VTIMEZONE subcomponents\n     *  leading to invalid ICAL data...\n     * @private\n     * @param {String} propName     The property name\n     * @param {ICAL.Time} time      The time to set\n     */\n    _setTime: function(propName, time) {\n      var prop = this.component.getFirstProperty(propName);\n\n      if (!prop) {\n        prop = new ICAL.Property(propName);\n        this.component.addProperty(prop);\n      }\n\n      // utc and local don't get a tzid\n      if (\n        time.zone === ICAL.Timezone.localTimezone ||\n        time.zone === ICAL.Timezone.utcTimezone\n      ) {\n        // remove the tzid\n        prop.removeParameter('tzid');\n      } else {\n        prop.setParameter('tzid', time.zone.tzid);\n      }\n\n      prop.setValue(time);\n    },\n\n    _setProp: function(name, value) {\n      this.component.updatePropertyWithValue(name, value);\n    },\n\n    _firstProp: function(name) {\n      return this.component.getFirstPropertyValue(name);\n    },\n\n    /**\n     * The string representation of this event.\n     * @return {String}\n     */\n    toString: function() {\n      return this.component.toString();\n    }\n\n  };\n\n  function compareRangeException(a, b) {\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    return 0;\n  }\n\n  return Event;\n}());\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n/**\n * This symbol is further described later on\n * @ignore\n */\nICAL.ComponentParser = (function() {\n  /**\n   * @classdesc\n   * The ComponentParser is used to process a String or jCal Object,\n   * firing callbacks for various found components, as well as completion.\n   *\n   * @example\n   * var options = {\n   *   // when false no events will be emitted for type\n   *   parseEvent: true,\n   *   parseTimezone: true\n   * };\n   *\n   * var parser = new ICAL.ComponentParser(options);\n   *\n   * parser.onevent(eventComponent) {\n   *   //...\n   * }\n   *\n   * // ontimezone, etc...\n   *\n   * parser.oncomplete = function() {\n   *\n   * };\n   *\n   * parser.process(stringOrComponent);\n   *\n   * @class\n   * @alias ICAL.ComponentParser\n   * @param {Object=} options        Component parser options\n   * @param {Boolean} options.parseEvent        Whether events should be parsed\n   * @param {Boolean} options.parseTimezeone    Whether timezones should be parsed\n   */\n  function ComponentParser(options) {\n    if (typeof(options) === 'undefined') {\n      options = {};\n    }\n\n    var key;\n    for (key in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(key)) {\n        this[key] = options[key];\n      }\n    }\n  }\n\n  ComponentParser.prototype = {\n\n    /**\n     * When true, parse events\n     *\n     * @type {Boolean}\n     */\n    parseEvent: true,\n\n    /**\n     * When true, parse timezones\n     *\n     * @type {Boolean}\n     */\n    parseTimezone: true,\n\n\n    /* SAX like events here for reference */\n\n    /**\n     * Fired when parsing is complete\n     * @callback\n     */\n    oncomplete: /* istanbul ignore next */ function() {},\n\n    /**\n     * Fired if an error occurs during parsing.\n     *\n     * @callback\n     * @param {Error} err details of error\n     */\n    onerror: /* istanbul ignore next */ function(err) {},\n\n    /**\n     * Fired when a top level component (VTIMEZONE) is found\n     *\n     * @callback\n     * @param {ICAL.Timezone} component     Timezone object\n     */\n    ontimezone: /* istanbul ignore next */ function(component) {},\n\n    /**\n     * Fired when a top level component (VEVENT) is found.\n     *\n     * @callback\n     * @param {ICAL.Event} component    Top level component\n     */\n    onevent: /* istanbul ignore next */ function(component) {},\n\n    /**\n     * Process a string or parse ical object.  This function itself will return\n     * nothing but will start the parsing process.\n     *\n     * Events must be registered prior to calling this method.\n     *\n     * @param {ICAL.Component|String|Object} ical      The component to process,\n     *        either in its final form, as a jCal Object, or string representation\n     */\n    process: function(ical) {\n      //TODO: this is sync now in the future we will have a incremental parser.\n      if (typeof(ical) === 'string') {\n        ical = ICAL.parse(ical);\n      }\n\n      if (!(ical instanceof ICAL.Component)) {\n        ical = new ICAL.Component(ical);\n      }\n\n      var components = ical.getAllSubcomponents();\n      var i = 0;\n      var len = components.length;\n      var component;\n\n      for (; i < len; i++) {\n        component = components[i];\n\n        switch (component.name) {\n          case 'vtimezone':\n            if (this.parseTimezone) {\n              var tzid = component.getFirstPropertyValue('tzid');\n              if (tzid) {\n                this.ontimezone(new ICAL.Timezone({\n                  tzid: tzid,\n                  component: component\n                }));\n              }\n            }\n            break;\n          case 'vevent':\n            if (this.parseEvent) {\n              this.onevent(new ICAL.Event(component));\n            }\n            break;\n          default:\n            continue;\n        }\n      }\n\n      //XXX: ideally we should do a \"nextTick\" here\n      //     so in all cases this is actually async.\n      this.oncomplete();\n    }\n  };\n\n  return ComponentParser;\n}());\n"],"mappings":"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AjB,CADA,IAEAP,IAAI,CAACO,WAAL,CAAiB,eAAjB,CAFP;EAGD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACE,SAASsjB,cAAT,CAAwBpf,OAAxB,EAAiC;IAC/B,KAAKyf,SAAL,GAAiB,EAAjB;IACA,KAAKC,OAAL,GAAe,EAAf;IACA,KAAKttB,QAAL,CAAc4N,OAAd;EACD;;EAEDof,cAAc,CAACv4B,SAAf,GAA2B;IACzB;AACJ;AACA;AACA;IACI84B,QAAQ,EAAE,KALe;;IAOzB;AACJ;AACA;AACA;AACA;AACA;IACIC,aAAa,EAAE,IAbU;;IAezB;AACJ;AACA;AACA;AACA;AACA;IACIH,SAAS,EAAE,IArBc;;IAuBzB;AACJ;AACA;AACA;AACA;AACA;IACIC,OAAO,EAAE,IA7BgB;;IA+BzB;AACJ;AACA;AACA;AACA;IACIG,WAAW,EAAE,CApCY;;IAsCzB;AACJ;AACA;AACA;AACA;IACIC,SAAS,EAAE,CA3Cc;;IA6CzB;AACJ;AACA;AACA;AACA;AACA;IACIC,MAAM,EAAE,IAnDiB;;IAqDzB;AACJ;AACA;AACA;AACA;AACA;IACIC,QAAQ,EAAE,IA3De;;IA6DzB;AACJ;AACA;AACA;AACA;IACIrZ,OAAO,EAAE,IAlEgB;;IAoEzB;AACJ;AACA;AACA;AACA;IACIgQ,IAAI,EAAE,IAzEmB;;IA2EzB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIvkB,QAAQ,EAAE,UAAS4N,OAAT,EAAkB;MAC1B,IAAIpG,KAAK,GAAGnT,IAAI,CAACQ,OAAL,CAAagC,eAAb,CAA6B+W,OAAO,CAAC2G,OAArC,EAA8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"},"metadata":{},"sourceType":"script"}