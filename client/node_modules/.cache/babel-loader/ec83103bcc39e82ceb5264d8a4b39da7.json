{"ast":null,"code":"'use strict';\n\nmodule.exports = findAndReplace;\n\nvar visit = require('unist-util-visit-parents');\n\nvar convert = require('unist-util-is/convert');\n\nvar escape = require('escape-string-regexp');\n\nvar splice = [].splice;\n\nfunction findAndReplace(tree, find, replace, options) {\n  var settings;\n  var schema;\n\n  if (typeof find === 'string' || find && typeof find.exec === 'function') {\n    schema = [[find, replace]];\n  } else {\n    schema = find;\n    options = replace;\n  }\n\n  settings = options || {};\n  search(tree, settings, handlerFactory(toPairs(schema)));\n  return tree;\n\n  function handlerFactory(pairs) {\n    var pair = pairs[0];\n    return handler;\n\n    function handler(node, parent) {\n      var find = pair[0];\n      var replace = pair[1];\n      var nodes = [];\n      var start = 0;\n      var index = parent.children.indexOf(node);\n      var position;\n      var match;\n      var subhandler;\n      var value;\n      find.lastIndex = 0;\n      match = find.exec(node.value);\n\n      while (match) {\n        position = match.index;\n        value = replace.apply(null, [].concat(match, {\n          index: match.index,\n          input: match.input\n        }));\n\n        if (value !== false) {\n          if (start !== position) {\n            nodes.push({\n              type: 'text',\n              value: node.value.slice(start, position)\n            });\n          }\n\n          if (typeof value === 'string' && value.length > 0) {\n            value = {\n              type: 'text',\n              value: value\n            };\n          }\n\n          if (value) {\n            nodes = [].concat(nodes, value);\n          }\n\n          start = position + match[0].length;\n        }\n\n        if (!find.global) {\n          break;\n        }\n\n        match = find.exec(node.value);\n      }\n\n      if (position === undefined) {\n        nodes = [node];\n        index--;\n      } else {\n        if (start < node.value.length) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start)\n          });\n        }\n\n        nodes.unshift(index, 1);\n        splice.apply(parent.children, nodes);\n      }\n\n      if (pairs.length > 1) {\n        subhandler = handlerFactory(pairs.slice(1));\n        position = -1;\n\n        while (++position < nodes.length) {\n          node = nodes[position];\n\n          if (node.type === 'text') {\n            subhandler(node, parent);\n          } else {\n            search(node, settings, subhandler);\n          }\n        }\n      }\n\n      return index + nodes.length + 1;\n    }\n  }\n}\n\nfunction search(tree, settings, handler) {\n  var ignored = convert(settings.ignore || []);\n  var result = [];\n  visit(tree, 'text', visitor);\n  return result;\n\n  function visitor(node, parents) {\n    var index = -1;\n    var parent;\n    var grandparent;\n\n    while (++index < parents.length) {\n      parent = parents[index];\n\n      if (ignored(parent, grandparent ? grandparent.children.indexOf(parent) : undefined, grandparent)) {\n        return;\n      }\n\n      grandparent = parent;\n    }\n\n    return handler(node, grandparent);\n  }\n}\n\nfunction toPairs(schema) {\n  var result = [];\n  var key;\n  var index;\n\n  if (typeof schema !== 'object') {\n    throw new Error('Expected array or object as schema');\n  }\n\n  if ('length' in schema) {\n    index = -1;\n\n    while (++index < schema.length) {\n      result.push([toExpression(schema[index][0]), toFunction(schema[index][1])]);\n    }\n  } else {\n    for (key in schema) {\n      result.push([toExpression(key), toFunction(schema[key])]);\n    }\n  }\n\n  return result;\n}\n\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find;\n}\n\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : returner;\n\n  function returner() {\n    return replace;\n  }\n}","map":{"version":3,"names":["module","exports","findAndReplace","visit","require","convert","escape","splice","tree","find","replace","options","settings","schema","exec","search","handlerFactory","toPairs","pairs","pair","handler","node","parent","nodes","start","index","children","indexOf","position","match","subhandler","value","lastIndex","apply","concat","input","push","type","slice","length","global","undefined","unshift","ignored","ignore","result","visitor","parents","grandparent","key","Error","toExpression","toFunction","RegExp","returner"],"sources":["/Users/cherrie/Desktop/messenger_ver_2/client/node_modules/mdast-util-find-and-replace/index.js"],"sourcesContent":["'use strict'\n\nmodule.exports = findAndReplace\n\nvar visit = require('unist-util-visit-parents')\nvar convert = require('unist-util-is/convert')\nvar escape = require('escape-string-regexp')\n\nvar splice = [].splice\n\nfunction findAndReplace(tree, find, replace, options) {\n  var settings\n  var schema\n\n  if (typeof find === 'string' || (find && typeof find.exec === 'function')) {\n    schema = [[find, replace]]\n  } else {\n    schema = find\n    options = replace\n  }\n\n  settings = options || {}\n\n  search(tree, settings, handlerFactory(toPairs(schema)))\n\n  return tree\n\n  function handlerFactory(pairs) {\n    var pair = pairs[0]\n\n    return handler\n\n    function handler(node, parent) {\n      var find = pair[0]\n      var replace = pair[1]\n      var nodes = []\n      var start = 0\n      var index = parent.children.indexOf(node)\n      var position\n      var match\n      var subhandler\n      var value\n\n      find.lastIndex = 0\n\n      match = find.exec(node.value)\n\n      while (match) {\n        position = match.index\n        value = replace.apply(\n          null,\n          [].concat(match, {index: match.index, input: match.input})\n        )\n\n        if (value !== false) {\n          if (start !== position) {\n            nodes.push({type: 'text', value: node.value.slice(start, position)})\n          }\n\n          if (typeof value === 'string' && value.length > 0) {\n            value = {type: 'text', value: value}\n          }\n\n          if (value) {\n            nodes = [].concat(nodes, value)\n          }\n\n          start = position + match[0].length\n        }\n\n        if (!find.global) {\n          break\n        }\n\n        match = find.exec(node.value)\n      }\n\n      if (position === undefined) {\n        nodes = [node]\n        index--\n      } else {\n        if (start < node.value.length) {\n          nodes.push({type: 'text', value: node.value.slice(start)})\n        }\n\n        nodes.unshift(index, 1)\n        splice.apply(parent.children, nodes)\n      }\n\n      if (pairs.length > 1) {\n        subhandler = handlerFactory(pairs.slice(1))\n        position = -1\n\n        while (++position < nodes.length) {\n          node = nodes[position]\n\n          if (node.type === 'text') {\n            subhandler(node, parent)\n          } else {\n            search(node, settings, subhandler)\n          }\n        }\n      }\n\n      return index + nodes.length + 1\n    }\n  }\n}\n\nfunction search(tree, settings, handler) {\n  var ignored = convert(settings.ignore || [])\n  var result = []\n\n  visit(tree, 'text', visitor)\n\n  return result\n\n  function visitor(node, parents) {\n    var index = -1\n    var parent\n    var grandparent\n\n    while (++index < parents.length) {\n      parent = parents[index]\n\n      if (\n        ignored(\n          parent,\n          grandparent ? grandparent.children.indexOf(parent) : undefined,\n          grandparent\n        )\n      ) {\n        return\n      }\n\n      grandparent = parent\n    }\n\n    return handler(node, grandparent)\n  }\n}\n\nfunction toPairs(schema) {\n  var result = []\n  var key\n  var index\n\n  if (typeof schema !== 'object') {\n    throw new Error('Expected array or object as schema')\n  }\n\n  if ('length' in schema) {\n    index = -1\n\n    while (++index < schema.length) {\n      result.push([\n        toExpression(schema[index][0]),\n        toFunction(schema[index][1])\n      ])\n    }\n  } else {\n    for (key in schema) {\n      result.push([toExpression(key), toFunction(schema[key])])\n    }\n  }\n\n  return result\n}\n\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : returner\n\n  function returner() {\n    return replace\n  }\n}\n"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,cAAjB;;AAEA,IAAIC,KAAK,GAAGC,OAAO,CAAC,0BAAD,CAAnB;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,uBAAD,CAArB;;AACA,IAAIE,MAAM,GAAGF,OAAO,CAAC,sBAAD,CAApB;;AAEA,IAAIG,MAAM,GAAG,GAAGA,MAAhB;;AAEA,SAASL,cAAT,CAAwBM,IAAxB,EAA8BC,IAA9B,EAAoCC,OAApC,EAA6CC,OAA7C,EAAsD;EACpD,IAAIC,QAAJ;EACA,IAAIC,MAAJ;;EAEA,IAAI,OAAOJ,IAAP,KAAgB,QAAhB,IAA6BA,IAAI,IAAI,OAAOA,IAAI,CAACK,IAAZ,KAAqB,UAA9D,EAA2E;IACzED,MAAM,GAAG,CAAC,CAACJ,IAAD,EAAOC,OAAP,CAAD,CAAT;EACD,CAFD,MAEO;IACLG,MAAM,GAAGJ,IAAT;IACAE,OAAO,GAAGD,OAAV;EACD;;EAEDE,QAAQ,GAAGD,OAAO,IAAI,EAAtB;EAEAI,MAAM,CAACP,IAAD,EAAOI,QAAP,EAAiBI,cAAc,CAACC,OAAO,CAACJ,MAAD,CAAR,CAA/B,CAAN;EAEA,OAAOL,IAAP;;EAEA,SAASQ,cAAT,CAAwBE,KAAxB,EAA+B;IAC7B,IAAIC,IAAI,GAAGD,KAAK,CAAC,CAAD,CAAhB;IAEA,OAAOE,OAAP;;IAEA,SAASA,OAAT,CAAiBC,IAAjB,EAAuBC,MAAvB,EAA+B;MAC7B,IAAIb,IAAI,GAAGU,IAAI,CAAC,CAAD,CAAf;MACA,IAAIT,OAAO,GAAGS,IAAI,CAAC,CAAD,CAAlB;MACA,IAAII,KAAK,GAAG,EAAZ;MACA,IAAIC,KAAK,GAAG,CAAZ;MACA,IAAIC,KAAK,GAAGH,MAAM,CAACI,QAAP,CAAgBC,OAAhB,CAAwBN,IAAxB,CAAZ;MACA,IAAIO,QAAJ;MACA,IAAIC,KAAJ;MACA,IAAIC,UAAJ;MACA,IAAIC,KAAJ;MAEAtB,IAAI,CAACuB,SAAL,GAAiB,CAAjB;MAEAH,KAAK,GAAGpB,IAAI,CAACK,IAAL,CAAUO,IAAI,CAACU,KAAf,CAAR;;MAEA,OAAOF,KAAP,EAAc;QACZD,QAAQ,GAAGC,KAAK,CAACJ,KAAjB;QACAM,KAAK,GAAGrB,OAAO,CAACuB,KAAR,CACN,IADM,EAEN,GAAGC,MAAH,CAAUL,KAAV,EAAiB;UAACJ,KAAK,EAAEI,KAAK,CAACJ,KAAd;UAAqBU,KAAK,EAAEN,KAAK,CAACM;QAAlC,CAAjB,CAFM,CAAR;;QAKA,IAAIJ,KAAK,KAAK,KAAd,EAAqB;UACnB,IAAIP,KAAK,KAAKI,QAAd,EAAwB;YACtBL,KAAK,CAACa,IAAN,CAAW;cAACC,IAAI,EAAE,MAAP;cAAeN,KAAK,EAAEV,IAAI,CAACU,KAAL,CAAWO,KAAX,CAAiBd,KAAjB,EAAwBI,QAAxB;YAAtB,CAAX;UACD;;UAED,IAAI,OAAOG,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACQ,MAAN,GAAe,CAAhD,EAAmD;YACjDR,KAAK,GAAG;cAACM,IAAI,EAAE,MAAP;cAAeN,KAAK,EAAEA;YAAtB,CAAR;UACD;;UAED,IAAIA,KAAJ,EAAW;YACTR,KAAK,GAAG,GAAGW,MAAH,CAAUX,KAAV,EAAiBQ,KAAjB,CAAR;UACD;;UAEDP,KAAK,GAAGI,QAAQ,GAAGC,KAAK,CAAC,CAAD,CAAL,CAASU,MAA5B;QACD;;QAED,IAAI,CAAC9B,IAAI,CAAC+B,MAAV,EAAkB;UAChB;QACD;;QAEDX,KAAK,GAAGpB,IAAI,CAACK,IAAL,CAAUO,IAAI,CAACU,KAAf,CAAR;MACD;;MAED,IAAIH,QAAQ,KAAKa,SAAjB,EAA4B;QAC1BlB,KAAK,GAAG,CAACF,IAAD,CAAR;QACAI,KAAK;MACN,CAHD,MAGO;QACL,IAAID,KAAK,GAAGH,IAAI,CAACU,KAAL,CAAWQ,MAAvB,EAA+B;UAC7BhB,KAAK,CAACa,IAAN,CAAW;YAACC,IAAI,EAAE,MAAP;YAAeN,KAAK,EAAEV,IAAI,CAACU,KAAL,CAAWO,KAAX,CAAiBd,KAAjB;UAAtB,CAAX;QACD;;QAEDD,KAAK,CAACmB,OAAN,CAAcjB,KAAd,EAAqB,CAArB;QACAlB,MAAM,CAAC0B,KAAP,CAAaX,MAAM,CAACI,QAApB,EAA8BH,KAA9B;MACD;;MAED,IAAIL,KAAK,CAACqB,MAAN,GAAe,CAAnB,EAAsB;QACpBT,UAAU,GAAGd,cAAc,CAACE,KAAK,CAACoB,KAAN,CAAY,CAAZ,CAAD,CAA3B;QACAV,QAAQ,GAAG,CAAC,CAAZ;;QAEA,OAAO,EAAEA,QAAF,GAAaL,KAAK,CAACgB,MAA1B,EAAkC;UAChClB,IAAI,GAAGE,KAAK,CAACK,QAAD,CAAZ;;UAEA,IAAIP,IAAI,CAACgB,IAAL,KAAc,MAAlB,EAA0B;YACxBP,UAAU,CAACT,IAAD,EAAOC,MAAP,CAAV;UACD,CAFD,MAEO;YACLP,MAAM,CAACM,IAAD,EAAOT,QAAP,EAAiBkB,UAAjB,CAAN;UACD;QACF;MACF;;MAED,OAAOL,KAAK,GAAGF,KAAK,CAACgB,MAAd,GAAuB,CAA9B;IACD;EACF;AACF;;AAED,SAASxB,MAAT,CAAgBP,IAAhB,EAAsBI,QAAtB,EAAgCQ,OAAhC,EAAyC;EACvC,IAAIuB,OAAO,GAAGtC,OAAO,CAACO,QAAQ,CAACgC,MAAT,IAAmB,EAApB,CAArB;EACA,IAAIC,MAAM,GAAG,EAAb;EAEA1C,KAAK,CAACK,IAAD,EAAO,MAAP,EAAesC,OAAf,CAAL;EAEA,OAAOD,MAAP;;EAEA,SAASC,OAAT,CAAiBzB,IAAjB,EAAuB0B,OAAvB,EAAgC;IAC9B,IAAItB,KAAK,GAAG,CAAC,CAAb;IACA,IAAIH,MAAJ;IACA,IAAI0B,WAAJ;;IAEA,OAAO,EAAEvB,KAAF,GAAUsB,OAAO,CAACR,MAAzB,EAAiC;MAC/BjB,MAAM,GAAGyB,OAAO,CAACtB,KAAD,CAAhB;;MAEA,IACEkB,OAAO,CACLrB,MADK,EAEL0B,WAAW,GAAGA,WAAW,CAACtB,QAAZ,CAAqBC,OAArB,CAA6BL,MAA7B,CAAH,GAA0CmB,SAFhD,EAGLO,WAHK,CADT,EAME;QACA;MACD;;MAEDA,WAAW,GAAG1B,MAAd;IACD;;IAED,OAAOF,OAAO,CAACC,IAAD,EAAO2B,WAAP,CAAd;EACD;AACF;;AAED,SAAS/B,OAAT,CAAiBJ,MAAjB,EAAyB;EACvB,IAAIgC,MAAM,GAAG,EAAb;EACA,IAAII,GAAJ;EACA,IAAIxB,KAAJ;;EAEA,IAAI,OAAOZ,MAAP,KAAkB,QAAtB,EAAgC;IAC9B,MAAM,IAAIqC,KAAJ,CAAU,oCAAV,CAAN;EACD;;EAED,IAAI,YAAYrC,MAAhB,EAAwB;IACtBY,KAAK,GAAG,CAAC,CAAT;;IAEA,OAAO,EAAEA,KAAF,GAAUZ,MAAM,CAAC0B,MAAxB,EAAgC;MAC9BM,MAAM,CAACT,IAAP,CAAY,CACVe,YAAY,CAACtC,MAAM,CAACY,KAAD,CAAN,CAAc,CAAd,CAAD,CADF,EAEV2B,UAAU,CAACvC,MAAM,CAACY,KAAD,CAAN,CAAc,CAAd,CAAD,CAFA,CAAZ;IAID;EACF,CATD,MASO;IACL,KAAKwB,GAAL,IAAYpC,MAAZ,EAAoB;MAClBgC,MAAM,CAACT,IAAP,CAAY,CAACe,YAAY,CAACF,GAAD,CAAb,EAAoBG,UAAU,CAACvC,MAAM,CAACoC,GAAD,CAAP,CAA9B,CAAZ;IACD;EACF;;EAED,OAAOJ,MAAP;AACD;;AAED,SAASM,YAAT,CAAsB1C,IAAtB,EAA4B;EAC1B,OAAO,OAAOA,IAAP,KAAgB,QAAhB,GAA2B,IAAI4C,MAAJ,CAAW/C,MAAM,CAACG,IAAD,CAAjB,EAAyB,GAAzB,CAA3B,GAA2DA,IAAlE;AACD;;AAED,SAAS2C,UAAT,CAAoB1C,OAApB,EAA6B;EAC3B,OAAO,OAAOA,OAAP,KAAmB,UAAnB,GAAgCA,OAAhC,GAA0C4C,QAAjD;;EAEA,SAASA,QAAT,GAAoB;IAClB,OAAO5C,OAAP;EACD;AACF"},"metadata":{},"sourceType":"script"}