{"ast":null,"code":"'use strict';\n\nconst StringScanner = require('./StringScanner');\n\nconst syntax = require('./syntax');\n\nconst XmlCdata = require('./XmlCdata');\n\nconst XmlComment = require('./XmlComment');\n\nconst XmlDocument = require('./XmlDocument');\n\nconst XmlElement = require('./XmlElement');\n\nconst XmlProcessingInstruction = require('./XmlProcessingInstruction');\n\nconst XmlText = require('./XmlText');\n\nconst emptyString = '';\n/**\nParses an XML string into an `XmlDocument`.\n\n@private\n*/\n\nclass Parser {\n  /**\n  @param {string} xml\n    XML string to parse.\n   @param {object} [options]\n    Parsing options.\n     @param {boolean} [options.ignoreUndefinedEntities=false]\n    @param {boolean} [options.preserveCdata=false]\n    @param {boolean} [options.preserveComments=false]\n    @param {(entity: string) => string?} [options.resolveUndefinedEntity]\n    @param {boolean} [options.sortAttributes=false]\n  */\n  constructor(xml) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /** @type {XmlDocument} */\n    this.document = new XmlDocument();\n    /** @type {XmlDocument|XmlElement} */\n\n    this.currentNode = this.document;\n    this.options = options;\n    this.scanner = new StringScanner(normalizeXmlString(xml));\n    this.consumeProlog();\n\n    if (!this.consumeElement()) {\n      this.error('Root element is missing or invalid');\n    }\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n\n    if (!this.scanner.isEnd) {\n      this.error('Extra content at the end of the document');\n    }\n  }\n  /**\n  Adds the given `XmlNode` as a child of `this.currentNode`.\n   @param {XmlNode} node\n  */\n\n\n  addNode(node) {\n    node.parent = this.currentNode; // @ts-ignore\n\n    this.currentNode.children.push(node);\n  }\n  /**\n  Adds the given _text_ to the document, either by appending it to a preceding\n  `XmlText` node (if possible) or by creating a new `XmlText` node.\n   @param {string} text\n  */\n\n\n  addText(text) {\n    let {\n      children\n    } = this.currentNode;\n\n    if (children.length > 0) {\n      let prevNode = children[children.length - 1];\n\n      if (prevNode instanceof XmlText) {\n        // The previous node is a text node, so we can append to it and avoid\n        // creating another node.\n        prevNode.text += text;\n        return;\n      }\n    }\n\n    this.addNode(new XmlText(text));\n  }\n  /**\n  Consumes an `AttValue` (attribute value) if possible.\n   @returns {string|false}\n    Contents of the `AttValue` minus quotes, or `false` if nothing was consumed.\n    An empty string indicates that an `AttValue` was consumed but was empty.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n  */\n\n\n  consumeAttributeValue() {\n    let {\n      scanner\n    } = this;\n    let quote = scanner.peek();\n\n    if (quote !== '\"' && quote !== \"'\") {\n      return false;\n    }\n\n    scanner.advance();\n    let chars;\n    let isClosed = false;\n    let value = emptyString;\n    let regex = quote === '\"' ? /[^\"&<]+/y : /[^'&<]+/y;\n\n    matchLoop: while (!scanner.isEnd) {\n      chars = scanner.consumeMatch(regex);\n\n      if (chars) {\n        this.validateChars(chars);\n        value += chars.replace(/[\\t\\r\\n]/g, ' ');\n      }\n\n      let nextChar = scanner.peek();\n\n      switch (nextChar) {\n        case quote:\n          isClosed = true;\n          break matchLoop;\n\n        case '&':\n          value += this.consumeReference();\n          continue;\n\n        case '<':\n          this.error('Unescaped `<` is not allowed in an attribute value');\n          /* istanbul ignore next */\n\n          break;\n\n        case emptyString:\n          this.error('Unclosed attribute');\n          /* istanbul ignore next */\n\n          break;\n      }\n    }\n\n    if (!isClosed) {\n      this.error('Unclosed attribute');\n    }\n\n    scanner.advance();\n    return value;\n  }\n  /**\n  Consumes a CDATA section if possible.\n   @returns {boolean}\n    Whether a CDATA section was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect\n  */\n\n\n  consumeCdataSection() {\n    let {\n      scanner\n    } = this;\n\n    if (!scanner.consumeStringFast('<![CDATA[')) {\n      return false;\n    }\n\n    let text = scanner.consumeUntilString(']]>');\n    this.validateChars(text);\n\n    if (!scanner.consumeStringFast(']]>')) {\n      this.error('Unclosed CDATA section');\n    }\n\n    if (this.options.preserveCdata) {\n      this.addNode(new XmlCdata(text));\n    } else {\n      this.addText(text);\n    }\n\n    return true;\n  }\n  /**\n  Consumes character data if possible.\n   @returns {boolean}\n    Whether character data was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\n  */\n\n\n  consumeCharData() {\n    let {\n      scanner\n    } = this;\n    let charData = scanner.consumeUntilMatch(/<|&|]]>/g);\n\n    if (!charData) {\n      return false;\n    }\n\n    this.validateChars(charData);\n\n    if (scanner.peek() === ']' && scanner.peek(3) === ']]>') {\n      this.error('Element content may not contain the CDATA section close delimiter `]]>`');\n    }\n\n    this.addText(charData);\n    return true;\n  }\n  /**\n  Consumes a comment if possible.\n   @returns {boolean}\n    Whether a comment was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment\n  */\n\n\n  consumeComment() {\n    let {\n      scanner\n    } = this;\n\n    if (!scanner.consumeStringFast('<!--')) {\n      return false;\n    }\n\n    let content = scanner.consumeUntilString('--');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('-->')) {\n      if (scanner.peek(2) === '--') {\n        this.error(\"The string `--` isn't allowed inside a comment\");\n      } else {\n        this.error('Unclosed comment');\n      }\n    }\n\n    if (this.options.preserveComments) {\n      this.addNode(new XmlComment(content.trim()));\n    }\n\n    return true;\n  }\n  /**\n  Consumes a reference in a content context if possible.\n   This differs from `consumeReference()` in that a consumed reference will be\n  added to the document as a text node instead of returned.\n   @returns {boolean}\n    Whether a reference was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc\n  */\n\n\n  consumeContentReference() {\n    let ref = this.consumeReference();\n\n    if (ref) {\n      this.addText(ref);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n  Consumes a doctype declaration if possible.\n   This is a loose implementation since doctype declarations are currently\n  discarded without further parsing.\n   @returns {boolean}\n    Whether a doctype declaration was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd\n  */\n\n\n  consumeDoctypeDeclaration() {\n    let {\n      scanner\n    } = this;\n\n    if (!scanner.consumeStringFast('<!DOCTYPE') || !this.consumeWhitespace()) {\n      return false;\n    }\n\n    scanner.consumeMatch(/[^[>]+/y);\n\n    if (scanner.consumeMatch(/\\[[\\s\\S]+?\\][\\x20\\t\\r\\n]*>/y)) {\n      return true;\n    }\n\n    if (!scanner.consumeStringFast('>')) {\n      this.error('Unclosed doctype declaration');\n    }\n\n    return true;\n  }\n  /**\n  Consumes an element if possible.\n   @returns {boolean}\n    Whether an element was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element\n  */\n\n\n  consumeElement() {\n    let {\n      scanner\n    } = this;\n    let mark = scanner.charIndex;\n\n    if (scanner.peek() !== '<') {\n      return false;\n    }\n\n    scanner.advance();\n    let name = this.consumeName();\n\n    if (!name) {\n      scanner.reset(mark);\n      return false;\n    }\n\n    let attributes = Object.create(null);\n\n    while (this.consumeWhitespace()) {\n      let attrName = this.consumeName();\n\n      if (!attrName) {\n        continue;\n      }\n\n      let attrValue = this.consumeEqual() && this.consumeAttributeValue();\n\n      if (attrValue === false) {\n        this.error('Attribute value expected');\n      }\n\n      if (attrName in attributes) {\n        this.error(`Duplicate attribute: ${attrName}`);\n      }\n\n      if (attrName === 'xml:space' && attrValue !== 'default' && attrValue !== 'preserve') {\n        this.error('Value of the `xml:space` attribute must be \"default\" or \"preserve\"');\n      }\n\n      attributes[attrName] = attrValue;\n    }\n\n    if (this.options.sortAttributes) {\n      let attrNames = Object.keys(attributes).sort();\n      let sortedAttributes = Object.create(null);\n\n      for (let i = 0; i < attrNames.length; ++i) {\n        let attrName = attrNames[i];\n        sortedAttributes[attrName] = attributes[attrName];\n      }\n\n      attributes = sortedAttributes;\n    }\n\n    let isEmpty = Boolean(scanner.consumeStringFast('/>'));\n    let element = new XmlElement(name, attributes);\n    element.parent = this.currentNode;\n\n    if (!isEmpty) {\n      if (!scanner.consumeStringFast('>')) {\n        this.error(`Unclosed start tag for element \\`${name}\\``);\n      }\n\n      this.currentNode = element;\n      this.consumeCharData();\n\n      while (this.consumeElement() || this.consumeContentReference() || this.consumeCdataSection() || this.consumeProcessingInstruction() || this.consumeComment()) {\n        this.consumeCharData();\n      }\n\n      let endTagMark = scanner.charIndex;\n      let endTagName;\n\n      if (!scanner.consumeStringFast('</') || !(endTagName = this.consumeName()) || endTagName !== name) {\n        scanner.reset(endTagMark);\n        this.error(`Missing end tag for element ${name}`);\n      }\n\n      this.consumeWhitespace();\n\n      if (!scanner.consumeStringFast('>')) {\n        this.error(`Unclosed end tag for element ${name}`);\n      }\n\n      this.currentNode = element.parent;\n    }\n\n    this.addNode(element);\n    return true;\n  }\n  /**\n  Consumes an `Eq` production if possible.\n   @returns {boolean}\n    Whether an `Eq` production was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq\n  */\n\n\n  consumeEqual() {\n    this.consumeWhitespace();\n\n    if (this.scanner.consumeStringFast('=')) {\n      this.consumeWhitespace();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n  Consumes `Misc` content if possible.\n   @returns {boolean}\n    Whether anything was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc\n  */\n\n\n  consumeMisc() {\n    return this.consumeComment() || this.consumeProcessingInstruction() || this.consumeWhitespace();\n  }\n  /**\n  Consumes one or more `Name` characters if possible.\n   @returns {string}\n    `Name` characters, or an empty string if none were consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name\n  */\n\n\n  consumeName() {\n    return syntax.isNameStartChar(this.scanner.peek()) ? this.scanner.consumeMatchFn(syntax.isNameChar) : emptyString;\n  }\n  /**\n  Consumes a processing instruction if possible.\n   @returns {boolean}\n    Whether a processing instruction was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi\n  */\n\n\n  consumeProcessingInstruction() {\n    let {\n      scanner\n    } = this;\n    let mark = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<?')) {\n      return false;\n    }\n\n    let name = this.consumeName();\n\n    if (name) {\n      if (name.toLowerCase() === 'xml') {\n        scanner.reset(mark);\n        this.error(\"XML declaration isn't allowed here\");\n      }\n    } else {\n      this.error('Invalid processing instruction');\n    }\n\n    if (!this.consumeWhitespace()) {\n      if (scanner.consumeStringFast('?>')) {\n        this.addNode(new XmlProcessingInstruction(name));\n        return true;\n      }\n\n      this.error('Whitespace is required after a processing instruction name');\n    }\n\n    let content = scanner.consumeUntilString('?>');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('?>')) {\n      this.error('Unterminated processing instruction');\n    }\n\n    this.addNode(new XmlProcessingInstruction(name, content));\n    return true;\n  }\n  /**\n  Consumes a prolog if possible.\n   @returns {boolean}\n    Whether a prolog was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd\n  */\n\n\n  consumeProlog() {\n    let {\n      scanner\n    } = this;\n    let mark = scanner.charIndex;\n    this.consumeXmlDeclaration();\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n\n    if (this.consumeDoctypeDeclaration()) {\n      while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    }\n\n    return mark < scanner.charIndex;\n  }\n  /**\n  Consumes a reference if possible.\n   This differs from `consumeContentReference()` in that a consumed reference\n  will be returned rather than added to the document.\n   @returns {string|false}\n    Parsed reference value, or `false` if nothing was consumed (to distinguish\n    from a reference that resolves to an empty string).\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference\n  */\n\n\n  consumeReference() {\n    let {\n      scanner\n    } = this;\n\n    if (scanner.peek() !== '&') {\n      return false;\n    }\n\n    scanner.advance();\n    let ref = scanner.consumeMatchFn(syntax.isReferenceChar);\n\n    if (scanner.consume() !== ';') {\n      this.error('Unterminated reference (a reference must end with `;`)');\n    }\n\n    let parsedValue;\n\n    if (ref[0] === '#') {\n      // This is a character reference.\n      let codePoint = ref[1] === 'x' ? parseInt(ref.slice(2), 16) // Hex codepoint.\n      : parseInt(ref.slice(1), 10); // Decimal codepoint.\n\n      if (isNaN(codePoint)) {\n        this.error('Invalid character reference');\n      }\n\n      parsedValue = String.fromCodePoint(codePoint);\n\n      if (!syntax.isXmlChar(parsedValue)) {\n        this.error('Character reference resolves to an invalid character');\n      }\n    } else {\n      // This is an entity reference.\n      parsedValue = syntax.predefinedEntities[ref];\n\n      if (parsedValue === undefined) {\n        let {\n          ignoreUndefinedEntities,\n          resolveUndefinedEntity\n        } = this.options;\n        let wrappedRef = `&${ref};`; // for backcompat with <= 2.x\n\n        if (resolveUndefinedEntity) {\n          let resolvedValue = resolveUndefinedEntity(wrappedRef);\n\n          if (resolvedValue !== null && resolvedValue !== undefined) {\n            let type = typeof resolvedValue;\n\n            if (type !== 'string') {\n              throw new TypeError(`\\`resolveUndefinedEntity()\\` must return a string, \\`null\\`, or \\`undefined\\`, but returned a value of type ${type}`);\n            }\n\n            return resolvedValue;\n          }\n        }\n\n        if (ignoreUndefinedEntities) {\n          return wrappedRef;\n        }\n\n        scanner.reset(-wrappedRef.length);\n        this.error(`Named entity isn't defined: ${wrappedRef}`);\n      }\n    }\n\n    return parsedValue;\n  }\n  /**\n  Consumes a `SystemLiteral` if possible.\n   A `SystemLiteral` is similar to an attribute value, but allows the characters\n  `<` and `&` and doesn't replace references.\n   @returns {string|false}\n    Value of the `SystemLiteral` minus quotes, or `false` if nothing was\n    consumed. An empty string indicates that a `SystemLiteral` was consumed but\n    was empty.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral\n  */\n\n\n  consumeSystemLiteral() {\n    let {\n      scanner\n    } = this;\n    let quote = scanner.consumeStringFast('\"') || scanner.consumeStringFast(\"'\");\n\n    if (!quote) {\n      return false;\n    }\n\n    let value = scanner.consumeUntilString(quote);\n    this.validateChars(value);\n\n    if (!scanner.consumeStringFast(quote)) {\n      this.error('Missing end quote');\n    }\n\n    return value;\n  }\n  /**\n  Consumes one or more whitespace characters if possible.\n   @returns {boolean}\n    Whether any whitespace characters were consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\n  */\n\n\n  consumeWhitespace() {\n    return Boolean(this.scanner.consumeMatchFn(syntax.isWhitespace));\n  }\n  /**\n  Consumes an XML declaration if possible.\n   @returns {boolean}\n    Whether an XML declaration was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl\n  */\n\n\n  consumeXmlDeclaration() {\n    let {\n      scanner\n    } = this;\n\n    if (!scanner.consumeStringFast('<?xml')) {\n      return false;\n    }\n\n    if (!this.consumeWhitespace()) {\n      this.error('Invalid XML declaration');\n    }\n\n    let version = Boolean(scanner.consumeStringFast('version')) && this.consumeEqual() && this.consumeSystemLiteral();\n\n    if (version === false) {\n      this.error('XML version is missing or invalid');\n    } else if (!/^1\\.[0-9]+$/.test(version)) {\n      this.error('Invalid character in version number');\n    }\n\n    if (this.consumeWhitespace()) {\n      let encoding = Boolean(scanner.consumeStringFast('encoding')) && this.consumeEqual() && this.consumeSystemLiteral();\n\n      if (encoding) {\n        this.consumeWhitespace();\n      }\n\n      let standalone = Boolean(scanner.consumeStringFast('standalone')) && this.consumeEqual() && this.consumeSystemLiteral();\n\n      if (standalone) {\n        if (standalone !== 'yes' && standalone !== 'no') {\n          this.error('Only \"yes\" and \"no\" are permitted as values of `standalone`');\n        }\n\n        this.consumeWhitespace();\n      }\n    }\n\n    if (!scanner.consumeStringFast('?>')) {\n      this.error('Invalid or unclosed XML declaration');\n    }\n\n    return true;\n  }\n  /**\n  Throws an error at the current scanner position.\n   @param {string} message\n  */\n\n\n  error(message) {\n    let {\n      charIndex,\n      string: xml\n    } = this.scanner;\n    let column = 1;\n    let excerpt = '';\n    let line = 1; // Find the line and column where the error occurred.\n\n    for (let i = 0; i < charIndex; ++i) {\n      let char = xml[i];\n\n      if (char === '\\n') {\n        column = 1;\n        excerpt = '';\n        line += 1;\n      } else {\n        column += 1;\n        excerpt += char;\n      }\n    }\n\n    let eol = xml.indexOf('\\n', charIndex);\n    excerpt += eol === -1 ? xml.slice(charIndex) : xml.slice(charIndex, eol);\n    let excerptStart = 0; // Keep the excerpt below 50 chars, but always keep the error position in\n    // view.\n\n    if (excerpt.length > 50) {\n      if (column < 40) {\n        excerpt = excerpt.slice(0, 50);\n      } else {\n        excerptStart = column - 20;\n        excerpt = excerpt.slice(excerptStart, column + 30);\n      }\n    }\n\n    let err = new Error(`${message} (line ${line}, column ${column})\\n` + `  ${excerpt}\\n` + ' '.repeat(column - excerptStart + 1) + '^\\n');\n    Object.assign(err, {\n      column,\n      excerpt,\n      line,\n      pos: charIndex\n    });\n    throw err;\n  }\n  /**\n  Throws an invalid character error if any character in the given _string_ isn't\n  a valid XML character.\n   @param {string} string\n  */\n\n\n  validateChars(string) {\n    let charIndex = 0;\n\n    for (let char of string) {\n      if (syntax.isNotXmlChar(char)) {\n        this.scanner.reset(-([...string].length - charIndex));\n        this.error('Invalid character');\n      }\n\n      charIndex += 1;\n    }\n  }\n\n}\n\nmodule.exports = Parser; // -- Private Functions --------------------------------------------------------\n\n/**\nNormalizes the given XML string by stripping a byte order mark (if present) and\nreplacing CRLF sequences and lone CR characters with LF characters.\n\n@param {string} xml\n@returns {string}\n*/\n\nfunction normalizeXmlString(xml) {\n  if (xml[0] === '\\uFEFF') {\n    xml = xml.slice(1);\n  }\n\n  return xml.replace(/\\r\\n?/g, '\\n');\n}\n/** @typedef {import('./XmlNode')} XmlNode */","map":{"version":3,"names":["StringScanner","require","syntax","XmlCdata","XmlComment","XmlDocument","XmlElement","XmlProcessingInstruction","XmlText","emptyString","Parser","constructor","xml","options","document","currentNode","scanner","normalizeXmlString","consumeProlog","consumeElement","error","consumeMisc","isEnd","addNode","node","parent","children","push","addText","text","length","prevNode","consumeAttributeValue","quote","peek","advance","chars","isClosed","value","regex","matchLoop","consumeMatch","validateChars","replace","nextChar","consumeReference","consumeCdataSection","consumeStringFast","consumeUntilString","preserveCdata","consumeCharData","charData","consumeUntilMatch","consumeComment","content","preserveComments","trim","consumeContentReference","ref","consumeDoctypeDeclaration","consumeWhitespace","mark","charIndex","name","consumeName","reset","attributes","Object","create","attrName","attrValue","consumeEqual","sortAttributes","attrNames","keys","sort","sortedAttributes","i","isEmpty","Boolean","element","consumeProcessingInstruction","endTagMark","endTagName","isNameStartChar","consumeMatchFn","isNameChar","toLowerCase","consumeXmlDeclaration","isReferenceChar","consume","parsedValue","codePoint","parseInt","slice","isNaN","String","fromCodePoint","isXmlChar","predefinedEntities","undefined","ignoreUndefinedEntities","resolveUndefinedEntity","wrappedRef","resolvedValue","type","TypeError","consumeSystemLiteral","isWhitespace","version","test","encoding","standalone","message","string","column","excerpt","line","char","eol","indexOf","excerptStart","err","Error","repeat","assign","pos","isNotXmlChar","module","exports"],"sources":["/Users/cherrie/Desktop/messenger_ver_2/client/node_modules/@rgrove/parse-xml/src/lib/Parser.js"],"sourcesContent":["'use strict';\n\nconst StringScanner = require('./StringScanner');\nconst syntax = require('./syntax');\nconst XmlCdata = require('./XmlCdata');\nconst XmlComment = require('./XmlComment');\nconst XmlDocument = require('./XmlDocument');\nconst XmlElement = require('./XmlElement');\nconst XmlProcessingInstruction = require('./XmlProcessingInstruction');\nconst XmlText = require('./XmlText');\n\nconst emptyString = '';\n\n/**\nParses an XML string into an `XmlDocument`.\n\n@private\n*/\nclass Parser {\n  /**\n  @param {string} xml\n    XML string to parse.\n\n  @param {object} [options]\n    Parsing options.\n\n    @param {boolean} [options.ignoreUndefinedEntities=false]\n    @param {boolean} [options.preserveCdata=false]\n    @param {boolean} [options.preserveComments=false]\n    @param {(entity: string) => string?} [options.resolveUndefinedEntity]\n    @param {boolean} [options.sortAttributes=false]\n  */\n  constructor(xml, options = {}) {\n    /** @type {XmlDocument} */\n    this.document = new XmlDocument();\n\n    /** @type {XmlDocument|XmlElement} */\n    this.currentNode = this.document;\n\n    this.options = options;\n    this.scanner = new StringScanner(normalizeXmlString(xml));\n\n    this.consumeProlog();\n\n    if (!this.consumeElement()) {\n      this.error('Root element is missing or invalid');\n    }\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    if (!this.scanner.isEnd) {\n      this.error('Extra content at the end of the document');\n    }\n  }\n\n  /**\n  Adds the given `XmlNode` as a child of `this.currentNode`.\n\n  @param {XmlNode} node\n  */\n  addNode(node) {\n    node.parent = this.currentNode;\n\n    // @ts-ignore\n    this.currentNode.children.push(node);\n  }\n\n  /**\n  Adds the given _text_ to the document, either by appending it to a preceding\n  `XmlText` node (if possible) or by creating a new `XmlText` node.\n\n  @param {string} text\n  */\n  addText(text) {\n    let { children } = this.currentNode;\n\n    if (children.length > 0) {\n      let prevNode = children[children.length - 1];\n\n      if (prevNode instanceof XmlText) {\n        // The previous node is a text node, so we can append to it and avoid\n        // creating another node.\n        prevNode.text += text;\n        return;\n      }\n    }\n\n    this.addNode(new XmlText(text));\n  }\n\n  /**\n  Consumes an `AttValue` (attribute value) if possible.\n\n  @returns {string|false}\n    Contents of the `AttValue` minus quotes, or `false` if nothing was consumed.\n    An empty string indicates that an `AttValue` was consumed but was empty.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n  */\n  consumeAttributeValue() {\n    let { scanner } = this;\n    let quote = scanner.peek();\n\n    if (quote !== '\"' && quote !== \"'\") {\n      return false;\n    }\n\n    scanner.advance();\n\n    let chars;\n    let isClosed = false;\n    let value = emptyString;\n    let regex = quote === '\"'\n      ? /[^\"&<]+/y\n      : /[^'&<]+/y;\n\n    matchLoop: while (!scanner.isEnd) {\n      chars = scanner.consumeMatch(regex);\n\n      if (chars) {\n        this.validateChars(chars);\n        value += chars.replace(/[\\t\\r\\n]/g, ' ');\n      }\n\n      let nextChar = scanner.peek();\n\n      switch (nextChar) {\n        case quote:\n          isClosed = true;\n          break matchLoop;\n\n        case '&':\n          value += this.consumeReference();\n          continue;\n\n        case '<':\n          this.error('Unescaped `<` is not allowed in an attribute value'); /* istanbul ignore next */\n          break;\n\n        case emptyString:\n          this.error('Unclosed attribute'); /* istanbul ignore next */\n          break;\n\n      }\n    }\n\n    if (!isClosed) {\n      this.error('Unclosed attribute');\n    }\n\n    scanner.advance();\n    return value;\n  }\n\n  /**\n  Consumes a CDATA section if possible.\n\n  @returns {boolean}\n    Whether a CDATA section was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect\n  */\n  consumeCdataSection() {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<![CDATA[')) {\n      return false;\n    }\n\n    let text = scanner.consumeUntilString(']]>');\n    this.validateChars(text);\n\n    if (!scanner.consumeStringFast(']]>')) {\n      this.error('Unclosed CDATA section');\n    }\n\n    if (this.options.preserveCdata) {\n      this.addNode(new XmlCdata(text));\n    } else {\n      this.addText(text);\n    }\n\n    return true;\n  }\n\n  /**\n  Consumes character data if possible.\n\n  @returns {boolean}\n    Whether character data was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\n  */\n  consumeCharData() {\n    let { scanner } = this;\n    let charData = scanner.consumeUntilMatch(/<|&|]]>/g);\n\n    if (!charData) {\n      return false;\n    }\n\n    this.validateChars(charData);\n\n    if (scanner.peek() === ']' && scanner.peek(3) === ']]>') {\n      this.error('Element content may not contain the CDATA section close delimiter `]]>`');\n    }\n\n    this.addText(charData);\n    return true;\n  }\n\n  /**\n  Consumes a comment if possible.\n\n  @returns {boolean}\n    Whether a comment was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment\n  */\n  consumeComment() {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<!--')) {\n      return false;\n    }\n\n    let content = scanner.consumeUntilString('--');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('-->')) {\n      if (scanner.peek(2) === '--') {\n        this.error(\"The string `--` isn't allowed inside a comment\");\n      } else {\n        this.error('Unclosed comment');\n      }\n    }\n\n    if (this.options.preserveComments) {\n      this.addNode(new XmlComment(content.trim()));\n    }\n\n    return true;\n  }\n\n  /**\n  Consumes a reference in a content context if possible.\n\n  This differs from `consumeReference()` in that a consumed reference will be\n  added to the document as a text node instead of returned.\n\n  @returns {boolean}\n    Whether a reference was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc\n  */\n  consumeContentReference() {\n    let ref = this.consumeReference();\n\n    if (ref) {\n      this.addText(ref);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n  Consumes a doctype declaration if possible.\n\n  This is a loose implementation since doctype declarations are currently\n  discarded without further parsing.\n\n  @returns {boolean}\n    Whether a doctype declaration was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd\n  */\n  consumeDoctypeDeclaration() {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<!DOCTYPE')\n        || !this.consumeWhitespace()) {\n\n      return false;\n    }\n\n    scanner.consumeMatch(/[^[>]+/y);\n\n    if (scanner.consumeMatch(/\\[[\\s\\S]+?\\][\\x20\\t\\r\\n]*>/y)) {\n      return true;\n    }\n\n    if (!scanner.consumeStringFast('>')) {\n      this.error('Unclosed doctype declaration');\n    }\n\n    return true;\n  }\n\n  /**\n  Consumes an element if possible.\n\n  @returns {boolean}\n    Whether an element was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element\n  */\n  consumeElement() {\n    let { scanner } = this;\n    let mark = scanner.charIndex;\n\n    if (scanner.peek() !== '<') {\n      return false;\n    }\n\n    scanner.advance();\n    let name = this.consumeName();\n\n    if (!name) {\n      scanner.reset(mark);\n      return false;\n    }\n\n    let attributes = Object.create(null);\n\n    while (this.consumeWhitespace()) {\n      let attrName = this.consumeName();\n\n      if (!attrName) {\n        continue;\n      }\n\n      let attrValue = this.consumeEqual()\n        && this.consumeAttributeValue();\n\n      if (attrValue === false) {\n        this.error('Attribute value expected');\n      }\n\n      if (attrName in attributes) {\n        this.error(`Duplicate attribute: ${attrName}`);\n      }\n\n      if (attrName === 'xml:space'\n          && attrValue !== 'default'\n          && attrValue !== 'preserve') {\n\n        this.error('Value of the `xml:space` attribute must be \"default\" or \"preserve\"');\n      }\n\n      attributes[attrName] = attrValue;\n    }\n\n    if (this.options.sortAttributes) {\n      let attrNames = Object.keys(attributes).sort();\n      let sortedAttributes = Object.create(null);\n\n      for (let i = 0; i < attrNames.length; ++i) {\n        let attrName = attrNames[i];\n        sortedAttributes[attrName] = attributes[attrName];\n      }\n\n      attributes = sortedAttributes;\n    }\n\n    let isEmpty = Boolean(scanner.consumeStringFast('/>'));\n    let element = new XmlElement(name, attributes);\n\n    element.parent = this.currentNode;\n\n    if (!isEmpty) {\n      if (!scanner.consumeStringFast('>')) {\n        this.error(`Unclosed start tag for element \\`${name}\\``);\n      }\n\n      this.currentNode = element;\n      this.consumeCharData();\n\n      while (\n        this.consumeElement()\n          || this.consumeContentReference()\n          || this.consumeCdataSection()\n          || this.consumeProcessingInstruction()\n          || this.consumeComment()\n      ) {\n        this.consumeCharData();\n      }\n\n      let endTagMark = scanner.charIndex;\n      let endTagName;\n\n      if (!scanner.consumeStringFast('</')\n          || !(endTagName = this.consumeName())\n          || endTagName !== name) {\n\n        scanner.reset(endTagMark);\n        this.error(`Missing end tag for element ${name}`);\n      }\n\n      this.consumeWhitespace();\n\n      if (!scanner.consumeStringFast('>')) {\n        this.error(`Unclosed end tag for element ${name}`);\n      }\n\n      this.currentNode = element.parent;\n    }\n\n    this.addNode(element);\n    return true;\n  }\n\n  /**\n  Consumes an `Eq` production if possible.\n\n  @returns {boolean}\n    Whether an `Eq` production was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq\n  */\n  consumeEqual() {\n    this.consumeWhitespace();\n\n    if (this.scanner.consumeStringFast('=')) {\n      this.consumeWhitespace();\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n  Consumes `Misc` content if possible.\n\n  @returns {boolean}\n    Whether anything was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc\n  */\n  consumeMisc() {\n    return this.consumeComment()\n      || this.consumeProcessingInstruction()\n      || this.consumeWhitespace();\n  }\n\n  /**\n  Consumes one or more `Name` characters if possible.\n\n  @returns {string}\n    `Name` characters, or an empty string if none were consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name\n  */\n  consumeName() {\n    return syntax.isNameStartChar(this.scanner.peek())\n      ? this.scanner.consumeMatchFn(syntax.isNameChar)\n      : emptyString;\n  }\n\n  /**\n  Consumes a processing instruction if possible.\n\n  @returns {boolean}\n    Whether a processing instruction was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi\n  */\n  consumeProcessingInstruction() {\n    let { scanner } = this;\n    let mark = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<?')) {\n      return false;\n    }\n\n    let name = this.consumeName();\n\n    if (name) {\n      if (name.toLowerCase() === 'xml') {\n        scanner.reset(mark);\n        this.error(\"XML declaration isn't allowed here\");\n      }\n    } else {\n      this.error('Invalid processing instruction');\n    }\n\n    if (!this.consumeWhitespace()) {\n      if (scanner.consumeStringFast('?>')) {\n        this.addNode(new XmlProcessingInstruction(name));\n        return true;\n      }\n\n      this.error('Whitespace is required after a processing instruction name');\n    }\n\n    let content = scanner.consumeUntilString('?>');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('?>')) {\n      this.error('Unterminated processing instruction');\n    }\n\n    this.addNode(new XmlProcessingInstruction(name, content));\n    return true;\n  }\n\n  /**\n  Consumes a prolog if possible.\n\n  @returns {boolean}\n    Whether a prolog was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd\n  */\n  consumeProlog() {\n    let { scanner } = this;\n    let mark = scanner.charIndex;\n\n    this.consumeXmlDeclaration();\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    if (this.consumeDoctypeDeclaration()) {\n      while (this.consumeMisc()) {} // eslint-disable-line no-empty\n    }\n\n    return mark < scanner.charIndex;\n  }\n\n  /**\n  Consumes a reference if possible.\n\n  This differs from `consumeContentReference()` in that a consumed reference\n  will be returned rather than added to the document.\n\n  @returns {string|false}\n    Parsed reference value, or `false` if nothing was consumed (to distinguish\n    from a reference that resolves to an empty string).\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference\n  */\n  consumeReference() {\n    let { scanner } = this;\n\n    if (scanner.peek() !== '&') {\n      return false;\n    }\n\n    scanner.advance();\n\n    let ref = scanner.consumeMatchFn(syntax.isReferenceChar);\n\n    if (scanner.consume() !== ';') {\n      this.error('Unterminated reference (a reference must end with `;`)');\n    }\n\n    let parsedValue;\n\n    if (ref[0] === '#') {\n      // This is a character reference.\n      let codePoint = ref[1] === 'x'\n        ? parseInt(ref.slice(2), 16) // Hex codepoint.\n        : parseInt(ref.slice(1), 10); // Decimal codepoint.\n\n      if (isNaN(codePoint)) {\n        this.error('Invalid character reference');\n      }\n\n      parsedValue = String.fromCodePoint(codePoint);\n\n      if (!syntax.isXmlChar(parsedValue)) {\n        this.error('Character reference resolves to an invalid character');\n      }\n    } else {\n      // This is an entity reference.\n      parsedValue = syntax.predefinedEntities[ref];\n\n      if (parsedValue === undefined) {\n        let {\n          ignoreUndefinedEntities,\n          resolveUndefinedEntity\n        } = this.options;\n\n        let wrappedRef = `&${ref};`; // for backcompat with <= 2.x\n\n        if (resolveUndefinedEntity) {\n          let resolvedValue = resolveUndefinedEntity(wrappedRef);\n\n          if (resolvedValue !== null && resolvedValue !== undefined) {\n            let type = typeof resolvedValue;\n\n            if (type !== 'string') {\n              throw new TypeError(`\\`resolveUndefinedEntity()\\` must return a string, \\`null\\`, or \\`undefined\\`, but returned a value of type ${type}`);\n            }\n\n            return resolvedValue;\n          }\n        }\n\n        if (ignoreUndefinedEntities) {\n          return wrappedRef;\n        }\n\n        scanner.reset(-wrappedRef.length);\n        this.error(`Named entity isn't defined: ${wrappedRef}`);\n      }\n    }\n\n    return parsedValue;\n  }\n\n  /**\n  Consumes a `SystemLiteral` if possible.\n\n  A `SystemLiteral` is similar to an attribute value, but allows the characters\n  `<` and `&` and doesn't replace references.\n\n  @returns {string|false}\n    Value of the `SystemLiteral` minus quotes, or `false` if nothing was\n    consumed. An empty string indicates that a `SystemLiteral` was consumed but\n    was empty.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral\n  */\n  consumeSystemLiteral() {\n    let { scanner } = this;\n    let quote = scanner.consumeStringFast('\"') || scanner.consumeStringFast(\"'\");\n\n    if (!quote) {\n      return false;\n    }\n\n    let value = scanner.consumeUntilString(quote);\n    this.validateChars(value);\n\n    if (!scanner.consumeStringFast(quote)) {\n      this.error('Missing end quote');\n    }\n\n    return value;\n  }\n\n  /**\n  Consumes one or more whitespace characters if possible.\n\n  @returns {boolean}\n    Whether any whitespace characters were consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\n  */\n  consumeWhitespace() {\n    return Boolean(this.scanner.consumeMatchFn(syntax.isWhitespace));\n  }\n\n  /**\n  Consumes an XML declaration if possible.\n\n  @returns {boolean}\n    Whether an XML declaration was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl\n  */\n  consumeXmlDeclaration() {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<?xml')) {\n      return false;\n    }\n\n    if (!this.consumeWhitespace()) {\n      this.error('Invalid XML declaration');\n    }\n\n    let version = Boolean(scanner.consumeStringFast('version'))\n      && this.consumeEqual()\n      && this.consumeSystemLiteral();\n\n    if (version === false) {\n      this.error('XML version is missing or invalid');\n    } else if (!/^1\\.[0-9]+$/.test(version)) {\n      this.error('Invalid character in version number');\n    }\n\n    if (this.consumeWhitespace()) {\n      let encoding = Boolean(scanner.consumeStringFast('encoding'))\n        && this.consumeEqual()\n        && this.consumeSystemLiteral();\n\n      if (encoding) {\n        this.consumeWhitespace();\n      }\n\n      let standalone = Boolean(scanner.consumeStringFast('standalone'))\n        && this.consumeEqual()\n        && this.consumeSystemLiteral();\n\n      if (standalone) {\n        if (standalone !== 'yes' && standalone !== 'no') {\n          this.error('Only \"yes\" and \"no\" are permitted as values of `standalone`');\n        }\n\n        this.consumeWhitespace();\n      }\n    }\n\n    if (!scanner.consumeStringFast('?>')) {\n      this.error('Invalid or unclosed XML declaration');\n    }\n\n    return true;\n  }\n\n  /**\n  Throws an error at the current scanner position.\n\n  @param {string} message\n  */\n  error(message) {\n    let { charIndex, string: xml } = this.scanner;\n    let column = 1;\n    let excerpt = '';\n    let line = 1;\n\n    // Find the line and column where the error occurred.\n    for (let i = 0; i < charIndex; ++i) {\n      let char = xml[i];\n\n      if (char === '\\n') {\n        column = 1;\n        excerpt = '';\n        line += 1;\n      } else {\n        column += 1;\n        excerpt += char;\n      }\n    }\n\n    let eol = xml.indexOf('\\n', charIndex);\n\n    excerpt += eol === -1\n      ? xml.slice(charIndex)\n      : xml.slice(charIndex, eol);\n\n    let excerptStart = 0;\n\n    // Keep the excerpt below 50 chars, but always keep the error position in\n    // view.\n    if (excerpt.length > 50) {\n      if (column < 40) {\n        excerpt = excerpt.slice(0, 50);\n      } else {\n        excerptStart = column - 20;\n        excerpt = excerpt.slice(excerptStart, column + 30);\n      }\n    }\n\n    let err = new Error(\n      `${message} (line ${line}, column ${column})\\n`\n        + `  ${excerpt}\\n`\n        + ' '.repeat(column - excerptStart + 1) + '^\\n'\n    );\n\n    Object.assign(err, {\n      column,\n      excerpt,\n      line,\n      pos: charIndex\n    });\n\n    throw err;\n  }\n\n  /**\n  Throws an invalid character error if any character in the given _string_ isn't\n  a valid XML character.\n\n  @param {string} string\n  */\n  validateChars(string) {\n    let charIndex = 0;\n\n    for (let char of string) {\n      if (syntax.isNotXmlChar(char)) {\n        this.scanner.reset(-([ ...string ].length - charIndex));\n        this.error('Invalid character');\n      }\n\n      charIndex += 1;\n    }\n  }\n}\n\nmodule.exports = Parser;\n\n// -- Private Functions --------------------------------------------------------\n\n/**\nNormalizes the given XML string by stripping a byte order mark (if present) and\nreplacing CRLF sequences and lone CR characters with LF characters.\n\n@param {string} xml\n@returns {string}\n*/\nfunction normalizeXmlString(xml) {\n  if (xml[0] === '\\uFEFF') {\n    xml = xml.slice(1);\n  }\n\n  return xml.replace(/\\r\\n?/g, '\\n');\n}\n\n/** @typedef {import('./XmlNode')} XmlNode */\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}