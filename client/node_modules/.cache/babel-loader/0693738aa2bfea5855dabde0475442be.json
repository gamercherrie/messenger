{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.stateify = exports.TokenState = exports.CharacterState = undefined;\n\nvar _class = require('../utils/class');\n\nfunction createStateClass() {\n  return function (tClass) {\n    this.j = [];\n    this.T = tClass || null;\n  };\n}\n/**\n\tA simple state machine that can emit token classes\n\n\tThe `j` property in this class refers to state jumps. It's a\n\tmultidimensional array where for each element:\n\n\t* index [0] is a symbol or class of symbols to transition to.\n\t* index [1] is a State instance which matches\n\n\tThe type of symbol will depend on the target implementation for this class.\n\tIn Linkify, we have a two-stage scanner. Each stage uses this state machine\n\tbut with a slighly different (polymorphic) implementation.\n\n\tThe `T` property refers to the token class.\n\n\tTODO: Can the `on` and `next` methods be combined?\n\n\t@class BaseState\n*/\n\n\nvar BaseState = createStateClass();\nBaseState.prototype = {\n  defaultTransition: false,\n\n  /**\n  \t@method constructor\n  \t@param {Class} tClass Pass in the kind of token to emit if there are\n  \t\tno jumps after this state and the state is accepting.\n  */\n\n  /**\n  \tOn the given symbol(s), this machine should go to the given state\n  \t\t@method on\n  \t@param {Array|Mixed} symbol\n  \t@param {BaseState} state Note that the type of this state should be the\n  \t\tsame as the current instance (i.e., don't pass in a different\n  \t\tsubclass)\n  */\n  on: function on(symbol, state) {\n    if (symbol instanceof Array) {\n      for (var i = 0; i < symbol.length; i++) {\n        this.j.push([symbol[i], state]);\n      }\n\n      return this;\n    }\n\n    this.j.push([symbol, state]);\n    return this;\n  },\n\n  /**\n  \tGiven the next item, returns next state for that item\n  \t@method next\n  \t@param {Mixed} item Should be an instance of the symbols handled by\n  \t\tthis particular machine.\n  \t@return {State} state Returns false if no jumps are available\n  */\n  next: function next(item) {\n    for (var i = 0; i < this.j.length; i++) {\n      var jump = this.j[i];\n      var symbol = jump[0]; // Next item to check for\n\n      var state = jump[1]; // State to jump to if items match\n      // compare item with symbol\n\n      if (this.test(item, symbol)) {\n        return state;\n      }\n    } // Nowhere left to jump!\n\n\n    return this.defaultTransition;\n  },\n\n  /**\n  \tDoes this state accept?\n  \t`true` only of `this.T` exists\n  \t\t@method accepts\n  \t@return {Boolean}\n  */\n  accepts: function accepts() {\n    return !!this.T;\n  },\n\n  /**\n  \tDetermine whether a given item \"symbolizes\" the symbol, where symbol is\n  \ta class of items handled by this state machine.\n  \t\tThis method should be overriden in extended classes.\n  \t\t@method test\n  \t@param {Mixed} item Does this item match the given symbol?\n  \t@param {Mixed} symbol\n  \t@return {Boolean}\n  */\n  test: function test(item, symbol) {\n    return item === symbol;\n  },\n\n  /**\n  \tEmit the token for this State (just return it in this case)\n  \tIf this emits a token, this instance is an accepting state\n  \t@method emit\n  \t@return {Class} T\n  */\n  emit: function emit() {\n    return this.T;\n  }\n};\n/**\n\tState machine for string-based input\n\n\t@class CharacterState\n\t@extends BaseState\n*/\n\nvar CharacterState = (0, _class.inherits)(BaseState, createStateClass(), {\n  /**\n  \tDoes the given character match the given character or regular\n  \texpression?\n  \t\t@method test\n  \t@param {String} char\n  \t@param {String|RegExp} charOrRegExp\n  \t@return {Boolean}\n  */\n  test: function test(character, charOrRegExp) {\n    return character === charOrRegExp || charOrRegExp instanceof RegExp && charOrRegExp.test(character);\n  }\n});\n/**\n\tState machine for input in the form of TextTokens\n\n\t@class TokenState\n\t@extends BaseState\n*/\n\nvar TokenState = (0, _class.inherits)(BaseState, createStateClass(), {\n  /**\n   * Similar to `on`, but returns the state the results in the transition from\n   * the given item\n   * @method jump\n   * @param {Mixed} item\n   * @param {Token} [token]\n   * @return state\n   */\n  jump: function jump(token) {\n    var tClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var state = this.next(new token('')); // dummy temp token\n\n    if (state === this.defaultTransition) {\n      // Make a new state!\n      state = new this.constructor(tClass);\n      this.on(token, state);\n    } else if (tClass) {\n      state.T = tClass;\n    }\n\n    return state;\n  },\n\n  /**\n  \tIs the given token an instance of the given token class?\n  \t\t@method test\n  \t@param {TextToken} token\n  \t@param {Class} tokenClass\n  \t@return {Boolean}\n  */\n  test: function test(token, tokenClass) {\n    return token instanceof tokenClass;\n  }\n});\n/**\n\tGiven a non-empty target string, generates states (if required) for each\n\tconsecutive substring of characters in str starting from the beginning of\n\tthe string. The final state will have a special value, as specified in\n\toptions. All other \"in between\" substrings will have a default end state.\n\n\tThis turns the state machine into a Trie-like data structure (rather than a\n\tintelligently-designed DFA).\n\n\tNote that I haven't really tried these with any strings other than\n\tDOMAIN.\n\n\t@param {String} str\n\t@param {CharacterState} start State to jump from the first character\n\t@param {Class} endToken Token class to emit when the given string has been\n\t\tmatched and no more jumps exist.\n\t@param {Class} defaultToken \"Filler token\", or which token type to emit when\n\t\twe don't have a full match\n\t@return {Array} list of newly-created states\n*/\n\nfunction stateify(str, start, endToken, defaultToken) {\n  var i = 0,\n      len = str.length,\n      state = start,\n      newStates = [],\n      nextState = void 0; // Find the next state without a jump to the next character\n\n  while (i < len && (nextState = state.next(str[i]))) {\n    state = nextState;\n    i++;\n  }\n\n  if (i >= len) {\n    return [];\n  } // no new tokens were added\n\n\n  while (i < len - 1) {\n    nextState = new CharacterState(defaultToken);\n    newStates.push(nextState);\n    state.on(str[i], nextState);\n    state = nextState;\n    i++;\n  }\n\n  nextState = new CharacterState(endToken);\n  newStates.push(nextState);\n  state.on(str[len - 1], nextState);\n  return newStates;\n}\n\nexports.CharacterState = CharacterState;\nexports.TokenState = TokenState;\nexports.stateify = stateify;","map":{"version":3,"names":["exports","__esModule","stateify","TokenState","CharacterState","undefined","_class","require","createStateClass","tClass","j","T","BaseState","prototype","defaultTransition","on","symbol","state","Array","i","length","push","next","item","jump","test","accepts","emit","inherits","character","charOrRegExp","RegExp","token","arguments","constructor","tokenClass","str","start","endToken","defaultToken","len","newStates","nextState"],"sources":["/Users/cherrie/Desktop/messenger_ver_2/client/node_modules/linkifyjs/lib/linkify/core/state.js"],"sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.stateify = exports.TokenState = exports.CharacterState = undefined;\n\nvar _class = require('../utils/class');\n\nfunction createStateClass() {\n\treturn function (tClass) {\n\t\tthis.j = [];\n\t\tthis.T = tClass || null;\n\t};\n}\n\n/**\n\tA simple state machine that can emit token classes\n\n\tThe `j` property in this class refers to state jumps. It's a\n\tmultidimensional array where for each element:\n\n\t* index [0] is a symbol or class of symbols to transition to.\n\t* index [1] is a State instance which matches\n\n\tThe type of symbol will depend on the target implementation for this class.\n\tIn Linkify, we have a two-stage scanner. Each stage uses this state machine\n\tbut with a slighly different (polymorphic) implementation.\n\n\tThe `T` property refers to the token class.\n\n\tTODO: Can the `on` and `next` methods be combined?\n\n\t@class BaseState\n*/\nvar BaseState = createStateClass();\nBaseState.prototype = {\n\tdefaultTransition: false,\n\n\t/**\n \t@method constructor\n \t@param {Class} tClass Pass in the kind of token to emit if there are\n \t\tno jumps after this state and the state is accepting.\n */\n\n\t/**\n \tOn the given symbol(s), this machine should go to the given state\n \t\t@method on\n \t@param {Array|Mixed} symbol\n \t@param {BaseState} state Note that the type of this state should be the\n \t\tsame as the current instance (i.e., don't pass in a different\n \t\tsubclass)\n */\n\ton: function on(symbol, state) {\n\t\tif (symbol instanceof Array) {\n\t\t\tfor (var i = 0; i < symbol.length; i++) {\n\t\t\t\tthis.j.push([symbol[i], state]);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tthis.j.push([symbol, state]);\n\t\treturn this;\n\t},\n\n\n\t/**\n \tGiven the next item, returns next state for that item\n \t@method next\n \t@param {Mixed} item Should be an instance of the symbols handled by\n \t\tthis particular machine.\n \t@return {State} state Returns false if no jumps are available\n */\n\tnext: function next(item) {\n\t\tfor (var i = 0; i < this.j.length; i++) {\n\t\t\tvar jump = this.j[i];\n\t\t\tvar symbol = jump[0]; // Next item to check for\n\t\t\tvar state = jump[1]; // State to jump to if items match\n\n\t\t\t// compare item with symbol\n\t\t\tif (this.test(item, symbol)) {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t}\n\n\t\t// Nowhere left to jump!\n\t\treturn this.defaultTransition;\n\t},\n\n\n\t/**\n \tDoes this state accept?\n \t`true` only of `this.T` exists\n \t\t@method accepts\n \t@return {Boolean}\n */\n\taccepts: function accepts() {\n\t\treturn !!this.T;\n\t},\n\n\n\t/**\n \tDetermine whether a given item \"symbolizes\" the symbol, where symbol is\n \ta class of items handled by this state machine.\n \t\tThis method should be overriden in extended classes.\n \t\t@method test\n \t@param {Mixed} item Does this item match the given symbol?\n \t@param {Mixed} symbol\n \t@return {Boolean}\n */\n\ttest: function test(item, symbol) {\n\t\treturn item === symbol;\n\t},\n\n\n\t/**\n \tEmit the token for this State (just return it in this case)\n \tIf this emits a token, this instance is an accepting state\n \t@method emit\n \t@return {Class} T\n */\n\temit: function emit() {\n\t\treturn this.T;\n\t}\n};\n\n/**\n\tState machine for string-based input\n\n\t@class CharacterState\n\t@extends BaseState\n*/\nvar CharacterState = (0, _class.inherits)(BaseState, createStateClass(), {\n\t/**\n \tDoes the given character match the given character or regular\n \texpression?\n \t\t@method test\n \t@param {String} char\n \t@param {String|RegExp} charOrRegExp\n \t@return {Boolean}\n */\n\ttest: function test(character, charOrRegExp) {\n\t\treturn character === charOrRegExp || charOrRegExp instanceof RegExp && charOrRegExp.test(character);\n\t}\n});\n\n/**\n\tState machine for input in the form of TextTokens\n\n\t@class TokenState\n\t@extends BaseState\n*/\nvar TokenState = (0, _class.inherits)(BaseState, createStateClass(), {\n\n\t/**\n  * Similar to `on`, but returns the state the results in the transition from\n  * the given item\n  * @method jump\n  * @param {Mixed} item\n  * @param {Token} [token]\n  * @return state\n  */\n\tjump: function jump(token) {\n\t\tvar tClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t\tvar state = this.next(new token('')); // dummy temp token\n\t\tif (state === this.defaultTransition) {\n\t\t\t// Make a new state!\n\t\t\tstate = new this.constructor(tClass);\n\t\t\tthis.on(token, state);\n\t\t} else if (tClass) {\n\t\t\tstate.T = tClass;\n\t\t}\n\t\treturn state;\n\t},\n\n\n\t/**\n \tIs the given token an instance of the given token class?\n \t\t@method test\n \t@param {TextToken} token\n \t@param {Class} tokenClass\n \t@return {Boolean}\n */\n\ttest: function test(token, tokenClass) {\n\t\treturn token instanceof tokenClass;\n\t}\n});\n\n/**\n\tGiven a non-empty target string, generates states (if required) for each\n\tconsecutive substring of characters in str starting from the beginning of\n\tthe string. The final state will have a special value, as specified in\n\toptions. All other \"in between\" substrings will have a default end state.\n\n\tThis turns the state machine into a Trie-like data structure (rather than a\n\tintelligently-designed DFA).\n\n\tNote that I haven't really tried these with any strings other than\n\tDOMAIN.\n\n\t@param {String} str\n\t@param {CharacterState} start State to jump from the first character\n\t@param {Class} endToken Token class to emit when the given string has been\n\t\tmatched and no more jumps exist.\n\t@param {Class} defaultToken \"Filler token\", or which token type to emit when\n\t\twe don't have a full match\n\t@return {Array} list of newly-created states\n*/\nfunction stateify(str, start, endToken, defaultToken) {\n\tvar i = 0,\n\t    len = str.length,\n\t    state = start,\n\t    newStates = [],\n\t    nextState = void 0;\n\n\t// Find the next state without a jump to the next character\n\twhile (i < len && (nextState = state.next(str[i]))) {\n\t\tstate = nextState;\n\t\ti++;\n\t}\n\n\tif (i >= len) {\n\t\treturn [];\n\t} // no new tokens were added\n\n\twhile (i < len - 1) {\n\t\tnextState = new CharacterState(defaultToken);\n\t\tnewStates.push(nextState);\n\t\tstate.on(str[i], nextState);\n\t\tstate = nextState;\n\t\ti++;\n\t}\n\n\tnextState = new CharacterState(endToken);\n\tnewStates.push(nextState);\n\tstate.on(str[len - 1], nextState);\n\n\treturn newStates;\n}\n\nexports.CharacterState = CharacterState;\nexports.TokenState = TokenState;\nexports.stateify = stateify;"],"mappings":"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"},"metadata":{},"sourceType":"script"}